{"ast":null,"code":"/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */function $c5a24bc478652b5f$export$1005530eda016c13(node, collection) {\n  // New API: call collection.getChildren with the node key.\n  if (typeof collection.getChildren === 'function') return collection.getChildren(node.key);\n  // Old API: access childNodes directly.\n  return node.childNodes;\n}\nfunction $c5a24bc478652b5f$export$fbdeaa6a76694f71(iterable) {\n  return $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, 0);\n}\nfunction $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, index) {\n  if (index < 0) return undefined;\n  let i = 0;\n  for (let item of iterable) {\n    if (i === index) return item;\n    i++;\n  }\n}\nfunction $c5a24bc478652b5f$export$7475b2c64539e4cf(iterable) {\n  let lastItem = undefined;\n  for (let value of iterable) lastItem = value;\n  return lastItem;\n}\nfunction $c5a24bc478652b5f$export$8c434b3a7a4dad6(collection, a, b) {\n  // If the two nodes have the same parent, compare their indices.\n  if (a.parentKey === b.parentKey) return a.index - b.index;\n  // Otherwise, collect all of the ancestors from each node, and find the first one that doesn't match starting from the root.\n  // Include the base nodes in case we are comparing nodes of different levels so that we can compare the higher node to the lower level node's\n  // ancestor of the same level\n  let aAncestors = [...$c5a24bc478652b5f$var$getAncestors(collection, a), a];\n  let bAncestors = [...$c5a24bc478652b5f$var$getAncestors(collection, b), b];\n  let firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex((a, i) => a !== bAncestors[i]);\n  if (firstNonMatchingAncestor !== -1) {\n    // Compare the indices of two children within the common ancestor.\n    a = aAncestors[firstNonMatchingAncestor];\n    b = bAncestors[firstNonMatchingAncestor];\n    return a.index - b.index;\n  }\n  // If there isn't a non matching ancestor, we might be in a case where one of the nodes is the ancestor of the other.\n  if (aAncestors.findIndex(node => node === b) >= 0) return 1;else if (bAncestors.findIndex(node => node === a) >= 0) return -1;\n  // ðŸ¤·\n  return -1;\n}\nfunction $c5a24bc478652b5f$var$getAncestors(collection, node) {\n  let parents = [];\n  while ((node === null || node === void 0 ? void 0 : node.parentKey) != null) {\n    node = collection.getItem(node.parentKey);\n    parents.unshift(node);\n  }\n  return parents;\n}\nexport { $c5a24bc478652b5f$export$1005530eda016c13 as getChildNodes, $c5a24bc478652b5f$export$fbdeaa6a76694f71 as getFirstItem, $c5a24bc478652b5f$export$5f3398f8733f90e2 as getNthItem, $c5a24bc478652b5f$export$7475b2c64539e4cf as getLastItem, $c5a24bc478652b5f$export$8c434b3a7a4dad6 as compareNodeOrder };","map":{"version":3,"mappings":"AAAA;;;;;;;;;;GAcO,SAASA,0CAAiBC,IAAa,EAAEC,UAA+B;EAC7E;EACA,IAAI,OAAOA,WAAWC,WAAW,KAAK,YACpC,OAAOD,WAAWC,WAAW,CAACF,KAAKG,GAAG;EAGxC;EACA,OAAOH,KAAKI,UAAU;AACxB;AAEO,SAASC,0CAAgBC,QAAqB;EACnD,OAAOC,0CAAWD,UAAU;AAC9B;AAEO,SAASC,0CAAcD,QAAqB,EAAEE,KAAa;EAChE,IAAIA,QAAQ,GACV,OAAOC;EAGT,IAAIC,IAAI;EACR,KAAK,IAAIC,QAAQL,UAAU;IACzB,IAAII,MAAMF,OACR,OAAOG;IAGTD;EACF;AACF;AAEO,SAASE,0CAAeN,QAAqB;EAClD,IAAIO,WAAWJ;EACf,KAAK,IAAIK,SAASR,UAChBO,WAAWC;EAGb,OAAOD;AACT;AAEO,SAASE,yCAAoBd,UAA+B,EAAEe,CAAU,EAAEC,CAAU;EACzF;EACA,IAAID,EAAEE,SAAS,KAAKD,EAAEC,SAAS,EAC7B,OAAOF,EAAER,KAAK,GAAGS,EAAET,KAAK;EAG1B;EACA;EACA;EACA,IAAIW,aAAa,IAAIC,mCAAanB,YAAYe,IAAIA,EAAE;EACpD,IAAIK,aAAa,IAAID,mCAAanB,YAAYgB,IAAIA,EAAE;EACpD,IAAIK,2BAA2BH,WAAWI,KAAK,CAAC,GAAGF,WAAWG,MAAM,EAAEC,SAAS,CAAC,CAACT,GAAGN,MAAMM,MAAMK,UAAU,CAACX,EAAE;EAC7G,IAAIY,6BAA6B,IAAI;IACnC;IACAN,IAAIG,UAAU,CAACG,yBAAyB;IACxCL,IAAII,UAAU,CAACC,yBAAyB;IACxC,OAAON,EAAER,KAAK,GAAGS,EAAET,KAAK;EAC1B;EAEA;EACA,IAAIW,WAAWM,SAAS,CAACzB,QAAQA,SAASiB,MAAM,GAC9C,OAAO,OACF,IAAII,WAAWI,SAAS,CAACzB,QAAQA,SAASgB,MAAM,GACrD,OAAO;EAGT;EACA,OAAO;AACT;AAEA,SAASI,mCAAgBnB,UAA+B,EAAED,IAAa;EACrE,IAAI0B,UAAU,EAAE;EAEhB,OAAO,kDAAMR,SAAS,KAAI,MAAM;IAC9BlB,OAAOC,WAAW0B,OAAO,CAAC3B,KAAKkB,SAAS;IACxCQ,QAAQE,OAAO,CAAC5B;EAClB;EAEA,OAAO0B;AACT","names":["$c5a24bc478652b5f$export$1005530eda016c13","node","collection","getChildren","key","childNodes","$c5a24bc478652b5f$export$fbdeaa6a76694f71","iterable","$c5a24bc478652b5f$export$5f3398f8733f90e2","index","undefined","i","item","$c5a24bc478652b5f$export$7475b2c64539e4cf","lastItem","value","$c5a24bc478652b5f$export$8c434b3a7a4dad6","a","b","parentKey","aAncestors","$c5a24bc478652b5f$var$getAncestors","bAncestors","firstNonMatchingAncestor","slice","length","findIndex","parents","getItem","unshift"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-stately\\collections\\dist\\packages\\@react-stately\\collections\\src\\getChildNodes.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport type {Collection, Node} from '@react-types/shared';\n\nexport function getChildNodes<T>(node: Node<T>, collection: Collection<Node<T>>): Iterable<Node<T>> {\n  // New API: call collection.getChildren with the node key.\n  if (typeof collection.getChildren === 'function') {\n    return collection.getChildren(node.key);\n  }\n\n  // Old API: access childNodes directly.\n  return node.childNodes;\n}\n\nexport function getFirstItem<T>(iterable: Iterable<T>): T | undefined {\n  return getNthItem(iterable, 0);\n}\n\nexport function getNthItem<T>(iterable: Iterable<T>, index: number): T | undefined {\n  if (index < 0) {\n    return undefined;\n  }\n\n  let i = 0;\n  for (let item of iterable) {\n    if (i === index) {\n      return item;\n    }\n\n    i++;\n  }\n}\n\nexport function getLastItem<T>(iterable: Iterable<T>): T | undefined {\n  let lastItem = undefined;\n  for (let value of iterable) {\n    lastItem = value;\n  }\n\n  return lastItem;\n}\n\nexport function compareNodeOrder<T>(collection: Collection<Node<T>>, a: Node<T>, b: Node<T>) {\n  // If the two nodes have the same parent, compare their indices.\n  if (a.parentKey === b.parentKey) {\n    return a.index - b.index;\n  }\n\n  // Otherwise, collect all of the ancestors from each node, and find the first one that doesn't match starting from the root.\n  // Include the base nodes in case we are comparing nodes of different levels so that we can compare the higher node to the lower level node's\n  // ancestor of the same level\n  let aAncestors = [...getAncestors(collection, a), a];\n  let bAncestors = [...getAncestors(collection, b), b];\n  let firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex((a, i) => a !== bAncestors[i]);\n  if (firstNonMatchingAncestor !== -1) {\n    // Compare the indices of two children within the common ancestor.\n    a = aAncestors[firstNonMatchingAncestor];\n    b = bAncestors[firstNonMatchingAncestor];\n    return a.index - b.index;\n  }\n\n  // If there isn't a non matching ancestor, we might be in a case where one of the nodes is the ancestor of the other.\n  if (aAncestors.findIndex(node => node === b) >= 0) {\n    return 1;\n  } else if (bAncestors.findIndex(node => node === a) >= 0) {\n    return -1;\n  }\n\n  // ðŸ¤·\n  return -1;\n}\n\nfunction getAncestors<T>(collection: Collection<Node<T>>, node: Node<T>): Node<T>[] {\n  let parents = [];\n\n  while (node?.parentKey != null) {\n    node = collection.getItem(node.parentKey);\n    parents.unshift(node);\n  }\n\n  return parents;\n}\n"]},"metadata":{},"sourceType":"module"}