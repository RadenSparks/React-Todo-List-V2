{"ast":null,"code":"import { menuData as $d5336fe17ce95402$export$6f49b4016bfc8d56 } from \"./useMenu.mjs\";\nimport { useRouter as $7Kjv5$useRouter, useSlotId as $7Kjv5$useSlotId, filterDOMProps as $7Kjv5$filterDOMProps, useLinkProps as $7Kjv5$useLinkProps, mergeProps as $7Kjv5$mergeProps } from \"@react-aria/utils\";\nimport { getItemCount as $7Kjv5$getItemCount } from \"@react-stately/collections\";\nimport { usePress as $7Kjv5$usePress, useHover as $7Kjv5$useHover, isFocusVisible as $7Kjv5$isFocusVisible, useKeyboard as $7Kjv5$useKeyboard, useFocus as $7Kjv5$useFocus } from \"@react-aria/interactions\";\nimport { useSelectableItem as $7Kjv5$useSelectableItem } from \"@react-aria/selection\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $a2e5df62f93c7633$export$9d32628fc2aea7da(props, state, ref) {\n  let {\n    key: key,\n    closeOnSelect: closeOnSelect,\n    isVirtualized: isVirtualized,\n    'aria-haspopup': hasPopup,\n    onPressStart: pressStartProp,\n    onPressUp: pressUpProp,\n    onPress: onPress,\n    onPressChange: onPressChange,\n    onPressEnd: onPressEnd,\n    onHoverStart: hoverStartProp,\n    onHoverChange: onHoverChange,\n    onHoverEnd: onHoverEnd,\n    onKeyDown: onKeyDown,\n    onKeyUp: onKeyUp,\n    onFocus: onFocus,\n    onFocusChange: onFocusChange,\n    onBlur: onBlur\n  } = props;\n  let isTrigger = !!hasPopup;\n  var _props_isDisabled;\n  let isDisabled = (_props_isDisabled = props.isDisabled) !== null && _props_isDisabled !== void 0 ? _props_isDisabled : state.selectionManager.isDisabled(key);\n  var _props_isSelected;\n  let isSelected = (_props_isSelected = props.isSelected) !== null && _props_isSelected !== void 0 ? _props_isSelected : state.selectionManager.isSelected(key);\n  let data = (0, $d5336fe17ce95402$export$6f49b4016bfc8d56).get(state);\n  let item = state.collection.getItem(key);\n  let onClose = props.onClose || data.onClose;\n  let router = (0, $7Kjv5$useRouter)();\n  let performAction = e => {\n    var _item_props;\n    if (isTrigger) return;\n    if (item === null || item === void 0 ? void 0 : (_item_props = item.props) === null || _item_props === void 0 ? void 0 : _item_props.onAction) item.props.onAction();\n    if (props.onAction) props.onAction(key);else if (data.onAction) data.onAction(key);\n    if (e.target instanceof HTMLAnchorElement) router.open(e.target, e, item.props.href, item.props.routerOptions);\n  };\n  let role = 'menuitem';\n  if (!isTrigger) {\n    if (state.selectionManager.selectionMode === 'single') role = 'menuitemradio';else if (state.selectionManager.selectionMode === 'multiple') role = 'menuitemcheckbox';\n  }\n  let labelId = (0, $7Kjv5$useSlotId)();\n  let descriptionId = (0, $7Kjv5$useSlotId)();\n  let keyboardId = (0, $7Kjv5$useSlotId)();\n  let ariaProps = {\n    'aria-disabled': isDisabled || undefined,\n    role: role,\n    'aria-label': props['aria-label'],\n    'aria-labelledby': labelId,\n    'aria-describedby': [descriptionId, keyboardId].filter(Boolean).join(' ') || undefined,\n    'aria-controls': props['aria-controls'],\n    'aria-haspopup': hasPopup,\n    'aria-expanded': props['aria-expanded']\n  };\n  if (state.selectionManager.selectionMode !== 'none' && !isTrigger) ariaProps['aria-checked'] = isSelected;\n  if (isVirtualized) {\n    ariaProps['aria-posinset'] = item === null || item === void 0 ? void 0 : item.index;\n    ariaProps['aria-setsize'] = (0, $7Kjv5$getItemCount)(state.collection);\n  }\n  let onPressStart = e => {\n    if (e.pointerType === 'keyboard') performAction(e);\n    pressStartProp === null || pressStartProp === void 0 ? void 0 : pressStartProp(e);\n  };\n  let onPressUp = e => {\n    if (e.pointerType !== 'keyboard') {\n      performAction(e);\n      // Pressing a menu item should close by default in single selection mode but not multiple\n      // selection mode, except if overridden by the closeOnSelect prop.\n      if (!isTrigger && onClose && (closeOnSelect !== null && closeOnSelect !== void 0 ? closeOnSelect : state.selectionManager.selectionMode !== 'multiple' || state.selectionManager.isLink(key))) onClose();\n    }\n    pressUpProp === null || pressUpProp === void 0 ? void 0 : pressUpProp(e);\n  };\n  let {\n    itemProps: itemProps,\n    isFocused: isFocused\n  } = (0, $7Kjv5$useSelectableItem)({\n    selectionManager: state.selectionManager,\n    key: key,\n    ref: ref,\n    shouldSelectOnPressUp: true,\n    allowsDifferentPressOrigin: true,\n    // Disable all handling of links in useSelectable item\n    // because we handle it ourselves. The behavior of menus\n    // is slightly different from other collections because\n    // actions are performed on key down rather than key up.\n    linkBehavior: 'none'\n  });\n  let {\n    pressProps: pressProps,\n    isPressed: isPressed\n  } = (0, $7Kjv5$usePress)({\n    onPressStart: onPressStart,\n    onPress: onPress,\n    onPressUp: onPressUp,\n    onPressChange: onPressChange,\n    onPressEnd: onPressEnd,\n    isDisabled: isDisabled\n  });\n  let {\n    hoverProps: hoverProps\n  } = (0, $7Kjv5$useHover)({\n    isDisabled: isDisabled,\n    onHoverStart(e) {\n      if (!(0, $7Kjv5$isFocusVisible)()) {\n        state.selectionManager.setFocused(true);\n        state.selectionManager.setFocusedKey(key);\n      }\n      hoverStartProp === null || hoverStartProp === void 0 ? void 0 : hoverStartProp(e);\n    },\n    onHoverChange: onHoverChange,\n    onHoverEnd: onHoverEnd\n  });\n  let {\n    keyboardProps: keyboardProps\n  } = (0, $7Kjv5$useKeyboard)({\n    onKeyDown: e => {\n      // Ignore repeating events, which may have started on the menu trigger before moving\n      // focus to the menu item. We want to wait for a second complete key press sequence.\n      if (e.repeat) {\n        e.continuePropagation();\n        return;\n      }\n      switch (e.key) {\n        case ' ':\n          if (!isDisabled && state.selectionManager.selectionMode === 'none' && !isTrigger && closeOnSelect !== false && onClose) onClose();\n          break;\n        case 'Enter':\n          // The Enter key should always close on select, except if overridden.\n          if (!isDisabled && closeOnSelect !== false && !isTrigger && onClose) onClose();\n          break;\n        default:\n          if (!isTrigger) e.continuePropagation();\n          onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e);\n          break;\n      }\n    },\n    onKeyUp: onKeyUp\n  });\n  let {\n    focusProps: focusProps\n  } = (0, $7Kjv5$useFocus)({\n    onBlur: onBlur,\n    onFocus: onFocus,\n    onFocusChange: onFocusChange\n  });\n  let domProps = (0, $7Kjv5$filterDOMProps)(item.props);\n  delete domProps.id;\n  let linkProps = (0, $7Kjv5$useLinkProps)(item.props);\n  return {\n    menuItemProps: {\n      ...ariaProps,\n      ...(0, $7Kjv5$mergeProps)(domProps, linkProps, isTrigger ? {\n        onFocus: itemProps.onFocus,\n        'data-key': itemProps['data-key']\n      } : itemProps, pressProps, hoverProps, keyboardProps, focusProps),\n      tabIndex: itemProps.tabIndex != null ? -1 : undefined\n    },\n    labelProps: {\n      id: labelId\n    },\n    descriptionProps: {\n      id: descriptionId\n    },\n    keyboardShortcutProps: {\n      id: keyboardId\n    },\n    isFocused: isFocused,\n    isSelected: isSelected,\n    isPressed: isPressed,\n    isDisabled: isDisabled\n  };\n}\nexport { $a2e5df62f93c7633$export$9d32628fc2aea7da as useMenuItem };","map":{"version":3,"mappings":"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","names":["$a2e5df62f93c7633$export$9d32628fc2aea7da","props","state","ref","key","closeOnSelect","isVirtualized","hasPopup","onPressStart","pressStartProp","onPressUp","pressUpProp","onPress","onPressChange","onPressEnd","onHoverStart","hoverStartProp","onHoverChange","onHoverEnd","onKeyDown","onKeyUp","onFocus","onFocusChange","onBlur","isTrigger","_props_isDisabled","isDisabled","selectionManager","_props_isSelected","isSelected","data","get","item","collection","getItem","onClose","router","performAction","e","_item_props","onAction","target","HTMLAnchorElement","open","href","routerOptions","role","selectionMode","labelId","descriptionId","keyboardId","ariaProps","undefined","filter","Boolean","join","index","pointerType","isLink","itemProps","isFocused","shouldSelectOnPressUp","allowsDifferentPressOrigin","linkBehavior","pressProps","isPressed","hoverProps","setFocused","setFocusedKey","keyboardProps","repeat","continuePropagation","focusProps","domProps","id","linkProps","menuItemProps","tabIndex","labelProps","descriptionProps","keyboardShortcutProps"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-aria\\menu\\dist\\packages\\@react-aria\\menu\\src\\useMenuItem.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, DOMProps, FocusableElement, FocusEvents, HoverEvents, Key, KeyboardEvents, PressEvent, PressEvents, RouterOptions} from '@react-types/shared';\nimport {filterDOMProps, mergeProps, useLinkProps, useRouter, useSlotId} from '@react-aria/utils';\nimport {getItemCount} from '@react-stately/collections';\nimport {isFocusVisible, useFocus, useHover, useKeyboard, usePress} from '@react-aria/interactions';\nimport {menuData} from './useMenu';\nimport {RefObject} from 'react';\nimport {TreeState} from '@react-stately/tree';\nimport {useSelectableItem} from '@react-aria/selection';\n\nexport interface MenuItemAria {\n  /** Props for the menu item element. */\n  menuItemProps: DOMAttributes,\n\n  /** Props for the main text element inside the menu item. */\n  labelProps: DOMAttributes,\n\n  /** Props for the description text element inside the menu item, if any. */\n  descriptionProps: DOMAttributes,\n\n  /** Props for the keyboard shortcut text element inside the item, if any. */\n  keyboardShortcutProps: DOMAttributes,\n\n  /** Whether the item is currently focused. */\n  isFocused: boolean,\n  /** Whether the item is currently selected. */\n  isSelected: boolean,\n  /** Whether the item is currently in a pressed state. */\n  isPressed: boolean,\n  /** Whether the item is disabled. */\n  isDisabled: boolean\n}\n\nexport interface AriaMenuItemProps extends DOMProps, PressEvents, HoverEvents, KeyboardEvents, FocusEvents  {\n  /**\n   * Whether the menu item is disabled.\n   * @deprecated - pass disabledKeys to useTreeState instead.\n   */\n  isDisabled?: boolean,\n\n  /**\n   * Whether the menu item is selected.\n   * @deprecated - pass selectedKeys to useTreeState instead.\n   */\n  isSelected?: boolean,\n\n  /** A screen reader only label for the menu item. */\n  'aria-label'?: string,\n\n  /** The unique key for the menu item. */\n  key?: Key,\n\n  /**\n   * Handler that is called when the menu should close after selecting an item.\n   * @deprecated - pass to the menu instead.\n   */\n  onClose?: () => void,\n\n  /**\n   * Whether the menu should close when the menu item is selected.\n   * @default true\n   */\n  closeOnSelect?: boolean,\n\n  /** Whether the menu item is contained in a virtual scrolling menu. */\n  isVirtualized?: boolean,\n\n  /**\n   * Handler that is called when the user activates the item.\n   * @deprecated - pass to the menu instead.\n   */\n  onAction?: (key: Key) => void,\n\n  /** What kind of popup the item opens. */\n  'aria-haspopup'?: 'menu' | 'dialog',\n\n  /** Indicates whether the menu item's popup element is expanded or collapsed. */\n  'aria-expanded'?: boolean | 'true' | 'false',\n\n  /** Identifies the menu item's popup element whose contents or presence is controlled by the menu item. */\n  'aria-controls'?: string\n}\n\n/**\n * Provides the behavior and accessibility implementation for an item in a menu.\n * See `useMenu` for more details about menus.\n * @param props - Props for the item.\n * @param state - State for the menu, as returned by `useTreeState`.\n */\nexport function useMenuItem<T>(props: AriaMenuItemProps, state: TreeState<T>, ref: RefObject<FocusableElement>): MenuItemAria {\n  let {\n    key,\n    closeOnSelect,\n    isVirtualized,\n    'aria-haspopup': hasPopup,\n    onPressStart: pressStartProp,\n    onPressUp: pressUpProp,\n    onPress,\n    onPressChange,\n    onPressEnd,\n    onHoverStart: hoverStartProp,\n    onHoverChange,\n    onHoverEnd,\n    onKeyDown,\n    onKeyUp,\n    onFocus,\n    onFocusChange,\n    onBlur\n  } = props;\n\n  let isTrigger = !!hasPopup;\n  let isDisabled = props.isDisabled ?? state.selectionManager.isDisabled(key);\n  let isSelected = props.isSelected ?? state.selectionManager.isSelected(key);\n  let data = menuData.get(state);\n  let item = state.collection.getItem(key);\n  let onClose = props.onClose || data.onClose;\n  let router = useRouter();\n  let performAction = (e: PressEvent) => {\n    if (isTrigger) {\n      return;\n    }\n\n    if (item?.props?.onAction) {\n      item.props.onAction();\n    }\n\n    if (props.onAction) {\n      props.onAction(key);\n    } else if (data.onAction) {\n      data.onAction(key);\n    }\n\n    if (e.target instanceof HTMLAnchorElement) {\n      router.open(e.target, e, item.props.href, item.props.routerOptions as RouterOptions);\n    }\n  };\n\n  let role = 'menuitem';\n  if (!isTrigger) {\n    if (state.selectionManager.selectionMode === 'single') {\n      role = 'menuitemradio';\n    } else if (state.selectionManager.selectionMode === 'multiple') {\n      role = 'menuitemcheckbox';\n    }\n  }\n\n  let labelId = useSlotId();\n  let descriptionId = useSlotId();\n  let keyboardId = useSlotId();\n\n  let ariaProps = {\n    'aria-disabled': isDisabled || undefined,\n    role,\n    'aria-label': props['aria-label'],\n    'aria-labelledby': labelId,\n    'aria-describedby': [descriptionId, keyboardId].filter(Boolean).join(' ') || undefined,\n    'aria-controls': props['aria-controls'],\n    'aria-haspopup': hasPopup,\n    'aria-expanded': props['aria-expanded']\n  };\n\n  if (state.selectionManager.selectionMode !== 'none' && !isTrigger) {\n    ariaProps['aria-checked'] = isSelected;\n  }\n\n  if (isVirtualized) {\n    ariaProps['aria-posinset'] = item?.index;\n    ariaProps['aria-setsize'] = getItemCount(state.collection);\n  }\n\n  let onPressStart = (e: PressEvent) => {\n    if (e.pointerType === 'keyboard') {\n      performAction(e);\n    }\n\n    pressStartProp?.(e);\n  };\n\n  let onPressUp = (e: PressEvent) => {\n    if (e.pointerType !== 'keyboard') {\n      performAction(e);\n\n      // Pressing a menu item should close by default in single selection mode but not multiple\n      // selection mode, except if overridden by the closeOnSelect prop.\n      if (!isTrigger && onClose && (closeOnSelect ?? (state.selectionManager.selectionMode !== 'multiple' || state.selectionManager.isLink(key)))) {\n        onClose();\n      }\n    }\n\n    pressUpProp?.(e);\n  };\n\n  let {itemProps, isFocused} = useSelectableItem({\n    selectionManager: state.selectionManager,\n    key,\n    ref,\n    shouldSelectOnPressUp: true,\n    allowsDifferentPressOrigin: true,\n    // Disable all handling of links in useSelectable item\n    // because we handle it ourselves. The behavior of menus\n    // is slightly different from other collections because\n    // actions are performed on key down rather than key up.\n    linkBehavior: 'none'\n  });\n\n  let {pressProps, isPressed} = usePress({\n    onPressStart,\n    onPress,\n    onPressUp,\n    onPressChange,\n    onPressEnd,\n    isDisabled\n  });\n  let {hoverProps} = useHover({\n    isDisabled,\n    onHoverStart(e) {\n      if (!isFocusVisible()) {\n        state.selectionManager.setFocused(true);\n        state.selectionManager.setFocusedKey(key);\n      }\n      hoverStartProp?.(e);\n    },\n    onHoverChange,\n    onHoverEnd\n  });\n\n  let {keyboardProps} = useKeyboard({\n    onKeyDown: (e) => {\n      // Ignore repeating events, which may have started on the menu trigger before moving\n      // focus to the menu item. We want to wait for a second complete key press sequence.\n      if (e.repeat) {\n        e.continuePropagation();\n        return;\n      }\n\n      switch (e.key) {\n        case ' ':\n          if (!isDisabled && state.selectionManager.selectionMode === 'none' && !isTrigger && closeOnSelect !== false && onClose) {\n            onClose();\n          }\n          break;\n        case 'Enter':\n          // The Enter key should always close on select, except if overridden.\n          if (!isDisabled && closeOnSelect !== false && !isTrigger && onClose) {\n            onClose();\n          }\n          break;\n        default:\n          if (!isTrigger) {\n            e.continuePropagation();\n          }\n\n          onKeyDown?.(e);\n          break;\n      }\n    },\n    onKeyUp\n  });\n\n  let {focusProps} = useFocus({onBlur, onFocus, onFocusChange});\n  let domProps = filterDOMProps(item.props);\n  delete domProps.id;\n  let linkProps = useLinkProps(item.props);\n\n  return {\n    menuItemProps: {\n      ...ariaProps,\n      ...mergeProps(domProps, linkProps, isTrigger ? {onFocus: itemProps.onFocus, 'data-key': itemProps['data-key']} : itemProps, pressProps, hoverProps, keyboardProps, focusProps),\n      tabIndex: itemProps.tabIndex != null ? -1 : undefined\n    },\n    labelProps: {\n      id: labelId\n    },\n    descriptionProps: {\n      id: descriptionId\n    },\n    keyboardShortcutProps: {\n      id: keyboardId\n    },\n    isFocused,\n    isSelected,\n    isPressed,\n    isDisabled\n  };\n}\n"]},"metadata":{},"sourceType":"module"}