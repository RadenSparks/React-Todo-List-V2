{"ast":null,"code":"import { createContext as $69F46$createContext, useMemo as $69F46$useMemo, useContext as $69F46$useContext, useState as $69F46$useState, useRef as $69F46$useRef, useEffect as $69F46$useEffect } from \"react\";\n\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nconst $e5be200c675c3b3a$export$aca958c65c314e6c = {\n  badInput: false,\n  customError: false,\n  patternMismatch: false,\n  rangeOverflow: false,\n  rangeUnderflow: false,\n  stepMismatch: false,\n  tooLong: false,\n  tooShort: false,\n  typeMismatch: false,\n  valueMissing: false,\n  valid: true\n};\nconst $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE = {\n  ...$e5be200c675c3b3a$export$aca958c65c314e6c,\n  customError: true,\n  valid: false\n};\nconst $e5be200c675c3b3a$export$dad6ae84456c676a = {\n  isInvalid: false,\n  validationDetails: $e5be200c675c3b3a$export$aca958c65c314e6c,\n  validationErrors: []\n};\nconst $e5be200c675c3b3a$export$571b5131b7e65c11 = (0, $69F46$createContext)({});\nconst $e5be200c675c3b3a$export$a763b9476acd3eb = '__formValidationState' + Date.now();\nfunction $e5be200c675c3b3a$export$fc1a364ae1f3ff10(props) {\n  // Private prop for parent components to pass state to children.\n  if (props[$e5be200c675c3b3a$export$a763b9476acd3eb]) {\n    let {\n      realtimeValidation: realtimeValidation,\n      displayValidation: displayValidation,\n      updateValidation: updateValidation,\n      resetValidation: resetValidation,\n      commitValidation: commitValidation\n    } = props[$e5be200c675c3b3a$export$a763b9476acd3eb];\n    return {\n      realtimeValidation: realtimeValidation,\n      displayValidation: displayValidation,\n      updateValidation: updateValidation,\n      resetValidation: resetValidation,\n      commitValidation: commitValidation\n    };\n  }\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return $e5be200c675c3b3a$var$useFormValidationStateImpl(props);\n}\nfunction $e5be200c675c3b3a$var$useFormValidationStateImpl(props) {\n  let {\n    isInvalid: isInvalid,\n    validationState: validationState,\n    name: name,\n    value: value,\n    builtinValidation: builtinValidation,\n    validate: validate,\n    validationBehavior = 'aria'\n  } = props;\n  // backward compatibility.\n  if (validationState) isInvalid || (isInvalid = validationState === 'invalid');\n  // If the isInvalid prop is controlled, update validation result in realtime.\n  let controlledError = isInvalid !== undefined ? {\n    isInvalid: isInvalid,\n    validationErrors: [],\n    validationDetails: $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE\n  } : null;\n  // Perform custom client side validation.\n  let clientError = (0, $69F46$useMemo)(() => $e5be200c675c3b3a$var$getValidationResult($e5be200c675c3b3a$var$runValidate(validate, value)), [validate, value]);\n  if (builtinValidation === null || builtinValidation === void 0 ? void 0 : builtinValidation.validationDetails.valid) builtinValidation = null;\n  // Get relevant server errors from the form.\n  let serverErrors = (0, $69F46$useContext)($e5be200c675c3b3a$export$571b5131b7e65c11);\n  let serverErrorMessages = (0, $69F46$useMemo)(() => {\n    if (name) return Array.isArray(name) ? name.flatMap(name => $e5be200c675c3b3a$var$asArray(serverErrors[name])) : $e5be200c675c3b3a$var$asArray(serverErrors[name]);\n    return [];\n  }, [serverErrors, name]);\n  // Show server errors when the form gets a new value, and clear when the user changes the value.\n  let [lastServerErrors, setLastServerErrors] = (0, $69F46$useState)(serverErrors);\n  let [isServerErrorCleared, setServerErrorCleared] = (0, $69F46$useState)(false);\n  if (serverErrors !== lastServerErrors) {\n    setLastServerErrors(serverErrors);\n    setServerErrorCleared(false);\n  }\n  let serverError = (0, $69F46$useMemo)(() => $e5be200c675c3b3a$var$getValidationResult(isServerErrorCleared ? [] : serverErrorMessages), [isServerErrorCleared, serverErrorMessages]);\n  // Track the next validation state in a ref until commitValidation is called.\n  let nextValidation = (0, $69F46$useRef)($e5be200c675c3b3a$export$dad6ae84456c676a);\n  let [currentValidity, setCurrentValidity] = (0, $69F46$useState)($e5be200c675c3b3a$export$dad6ae84456c676a);\n  let lastError = (0, $69F46$useRef)($e5be200c675c3b3a$export$dad6ae84456c676a);\n  let commitValidation = () => {\n    if (!commitQueued) return;\n    setCommitQueued(false);\n    let error = clientError || builtinValidation || nextValidation.current;\n    if (!$e5be200c675c3b3a$var$isEqualValidation(error, lastError.current)) {\n      lastError.current = error;\n      setCurrentValidity(error);\n    }\n  };\n  let [commitQueued, setCommitQueued] = (0, $69F46$useState)(false);\n  (0, $69F46$useEffect)(commitValidation);\n  // realtimeValidation is used to update the native input element's state based on custom validation logic.\n  // displayValidation is the currently displayed validation state that the user sees (e.g. on input change/form submit).\n  // With validationBehavior=\"aria\", all errors are displayed in realtime rather than on submit.\n  let realtimeValidation = controlledError || serverError || clientError || builtinValidation || $e5be200c675c3b3a$export$dad6ae84456c676a;\n  let displayValidation = validationBehavior === 'native' ? controlledError || serverError || currentValidity : controlledError || serverError || clientError || builtinValidation || currentValidity;\n  return {\n    realtimeValidation: realtimeValidation,\n    displayValidation: displayValidation,\n    updateValidation(value) {\n      // If validationBehavior is 'aria', update in realtime. Otherwise, store in a ref until commit.\n      if (validationBehavior === 'aria' && !$e5be200c675c3b3a$var$isEqualValidation(currentValidity, value)) setCurrentValidity(value);else nextValidation.current = value;\n    },\n    resetValidation() {\n      // Update the currently displayed validation state to valid on form reset,\n      // even if the native validity says it isn't. It'll show again on the next form submit.\n      let error = $e5be200c675c3b3a$export$dad6ae84456c676a;\n      if (!$e5be200c675c3b3a$var$isEqualValidation(error, lastError.current)) {\n        lastError.current = error;\n        setCurrentValidity(error);\n      }\n      // Do not commit validation after the next render. This avoids a condition where\n      // useSelect calls commitValidation inside an onReset handler.\n      if (validationBehavior === 'native') setCommitQueued(false);\n      setServerErrorCleared(true);\n    },\n    commitValidation() {\n      // Commit validation state so the user sees it on blur/change/submit. Also clear any server errors.\n      // Wait until after the next render to commit so that the latest value has been validated.\n      if (validationBehavior === 'native') setCommitQueued(true);\n      setServerErrorCleared(true);\n    }\n  };\n}\nfunction $e5be200c675c3b3a$var$asArray(v) {\n  if (!v) return [];\n  return Array.isArray(v) ? v : [v];\n}\nfunction $e5be200c675c3b3a$var$runValidate(validate, value) {\n  if (typeof validate === 'function') {\n    let e = validate(value);\n    if (e && typeof e !== 'boolean') return $e5be200c675c3b3a$var$asArray(e);\n  }\n  return [];\n}\nfunction $e5be200c675c3b3a$var$getValidationResult(errors) {\n  return errors.length ? {\n    isInvalid: true,\n    validationErrors: errors,\n    validationDetails: $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE\n  } : null;\n}\nfunction $e5be200c675c3b3a$var$isEqualValidation(a, b) {\n  if (a === b) return true;\n  return a && b && a.isInvalid === b.isInvalid && a.validationErrors.length === b.validationErrors.length && a.validationErrors.every((a, i) => a === b.validationErrors[i]) && Object.entries(a.validationDetails).every(_ref => {\n    let [k, v] = _ref;\n    return b.validationDetails[k] === v;\n  });\n}\nfunction $e5be200c675c3b3a$export$75ee7c75d68f5b0e() {\n  let errors = new Set();\n  let isInvalid = false;\n  let validationDetails = {\n    ...$e5be200c675c3b3a$export$aca958c65c314e6c\n  };\n  for (var _len = arguments.length, results = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n    results[_key2] = arguments[_key2];\n  }\n  for (let v of results) {\n    var _validationDetails, _key;\n    for (let e of v.validationErrors) errors.add(e);\n    // Only these properties apply for checkboxes.\n    isInvalid || (isInvalid = v.isInvalid);\n    for (let key in validationDetails) (_validationDetails = validationDetails)[_key = key] || (_validationDetails[_key] = v.validationDetails[key]);\n  }\n  validationDetails.valid = !isInvalid;\n  return {\n    isInvalid: isInvalid,\n    validationErrors: [...errors],\n    validationDetails: validationDetails\n  };\n}\nexport { $e5be200c675c3b3a$export$aca958c65c314e6c as VALID_VALIDITY_STATE, $e5be200c675c3b3a$export$dad6ae84456c676a as DEFAULT_VALIDATION_RESULT, $e5be200c675c3b3a$export$571b5131b7e65c11 as FormValidationContext, $e5be200c675c3b3a$export$a763b9476acd3eb as privateValidationStateProp, $e5be200c675c3b3a$export$fc1a364ae1f3ff10 as useFormValidationState, $e5be200c675c3b3a$export$75ee7c75d68f5b0e as mergeValidation };","map":{"version":3,"mappings":"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","names":["$e5be200c675c3b3a$export$aca958c65c314e6c","badInput","customError","patternMismatch","rangeOverflow","rangeUnderflow","stepMismatch","tooLong","tooShort","typeMismatch","valueMissing","valid","$e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE","$e5be200c675c3b3a$export$dad6ae84456c676a","isInvalid","validationDetails","validationErrors","$e5be200c675c3b3a$export$571b5131b7e65c11","$e5be200c675c3b3a$export$a763b9476acd3eb","Date","now","$e5be200c675c3b3a$export$fc1a364ae1f3ff10","props","realtimeValidation","displayValidation","updateValidation","resetValidation","commitValidation","$e5be200c675c3b3a$var$useFormValidationStateImpl","validationState","name","value","builtinValidation","validate","validationBehavior","controlledError","undefined","clientError","$e5be200c675c3b3a$var$getValidationResult","$e5be200c675c3b3a$var$runValidate","serverErrors","serverErrorMessages","Array","isArray","flatMap","$e5be200c675c3b3a$var$asArray","lastServerErrors","setLastServerErrors","isServerErrorCleared","setServerErrorCleared","serverError","nextValidation","currentValidity","setCurrentValidity","lastError","commitQueued","setCommitQueued","error","current","$e5be200c675c3b3a$var$isEqualValidation","v","e","errors","length","a","b","every","i","Object","entries","_ref","k","$e5be200c675c3b3a$export$75ee7c75d68f5b0e","Set","results","_validationDetails","_key","add","key"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-stately\\form\\dist\\packages\\@react-stately\\form\\src\\useFormValidationState.ts"],"sourcesContent":["/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {createContext, useContext, useEffect, useMemo, useRef, useState} from 'react';\nimport {Validation, ValidationErrors, ValidationFunction, ValidationResult} from '@react-types/shared';\n\nexport const VALID_VALIDITY_STATE: ValidityState = {\n  badInput: false,\n  customError: false,\n  patternMismatch: false,\n  rangeOverflow: false,\n  rangeUnderflow: false,\n  stepMismatch: false,\n  tooLong: false,\n  tooShort: false,\n  typeMismatch: false,\n  valueMissing: false,\n  valid: true\n};\n\nconst CUSTOM_VALIDITY_STATE: ValidityState = {\n  ...VALID_VALIDITY_STATE,\n  customError: true,\n  valid: false\n};\n\nexport const DEFAULT_VALIDATION_RESULT: ValidationResult = {\n  isInvalid: false,\n  validationDetails: VALID_VALIDITY_STATE,\n  validationErrors: []\n};\n\nexport const FormValidationContext = createContext<ValidationErrors>({});\n\nexport const privateValidationStateProp = '__formValidationState' + Date.now();\n\ninterface FormValidationProps<T> extends Validation<T> {\n  builtinValidation?: ValidationResult,\n  name?: string | string[],\n  value: T\n}\n\nexport interface FormValidationState {\n  /** Realtime validation results, updated as the user edits the value. */\n  realtimeValidation: ValidationResult,\n  /** Currently displayed validation results, updated when the user commits their changes. */\n  displayValidation: ValidationResult,\n  /** Updates the current validation result. Not displayed to the user until `commitValidation` is called. */\n  updateValidation(result: ValidationResult): void,\n  /** Resets the displayed validation state to valid when the user resets the form. */\n  resetValidation(): void,\n  /** Commits the realtime validation so it is displayed to the user. */\n  commitValidation(): void\n}\n\nexport function useFormValidationState<T>(props: FormValidationProps<T>): FormValidationState {\n  // Private prop for parent components to pass state to children.\n  if (props[privateValidationStateProp]) {\n    let {realtimeValidation, displayValidation, updateValidation, resetValidation, commitValidation} = props[privateValidationStateProp] as FormValidationState;\n    return {realtimeValidation, displayValidation, updateValidation, resetValidation, commitValidation};\n  }\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return useFormValidationStateImpl(props);\n}\n\nfunction useFormValidationStateImpl<T>(props: FormValidationProps<T>): FormValidationState {\n  let {isInvalid, validationState, name, value, builtinValidation, validate, validationBehavior = 'aria'} = props;\n\n  // backward compatibility.\n  if (validationState) {\n    isInvalid ||= validationState === 'invalid';\n  }\n\n  // If the isInvalid prop is controlled, update validation result in realtime.\n  let controlledError: ValidationResult | null = isInvalid !== undefined ? {\n    isInvalid,\n    validationErrors: [],\n    validationDetails: CUSTOM_VALIDITY_STATE\n  } : null;\n\n  // Perform custom client side validation.\n  let clientError: ValidationResult | null = useMemo(() => getValidationResult(runValidate(validate, value)), [validate, value]);\n\n  if (builtinValidation?.validationDetails.valid) {\n    builtinValidation = null;\n  }\n\n  // Get relevant server errors from the form.\n  let serverErrors = useContext(FormValidationContext);\n  let serverErrorMessages = useMemo(() => {\n    if (name) {\n      return Array.isArray(name) ? name.flatMap(name => asArray(serverErrors[name])) : asArray(serverErrors[name]);\n    }\n    return [];\n  }, [serverErrors, name]);\n\n  // Show server errors when the form gets a new value, and clear when the user changes the value.\n  let [lastServerErrors, setLastServerErrors] = useState(serverErrors);\n  let [isServerErrorCleared, setServerErrorCleared] = useState(false);\n  if (serverErrors !== lastServerErrors) {\n    setLastServerErrors(serverErrors);\n    setServerErrorCleared(false);\n  }\n\n  let serverError: ValidationResult | null = useMemo(() =>\n    getValidationResult(isServerErrorCleared ? [] : serverErrorMessages),\n    [isServerErrorCleared, serverErrorMessages]\n  );\n\n  // Track the next validation state in a ref until commitValidation is called.\n  let nextValidation = useRef(DEFAULT_VALIDATION_RESULT);\n  let [currentValidity, setCurrentValidity] = useState(DEFAULT_VALIDATION_RESULT);\n\n  let lastError = useRef(DEFAULT_VALIDATION_RESULT);\n  let commitValidation = () => {\n    if (!commitQueued) {\n      return;\n    }\n\n    setCommitQueued(false);\n    let error = clientError || builtinValidation || nextValidation.current;\n    if (!isEqualValidation(error, lastError.current)) {\n      lastError.current = error;\n      setCurrentValidity(error);\n    }\n  };\n\n  let [commitQueued, setCommitQueued] = useState(false);\n  useEffect(commitValidation);\n\n  // realtimeValidation is used to update the native input element's state based on custom validation logic.\n  // displayValidation is the currently displayed validation state that the user sees (e.g. on input change/form submit).\n  // With validationBehavior=\"aria\", all errors are displayed in realtime rather than on submit.\n  let realtimeValidation = controlledError || serverError || clientError || builtinValidation || DEFAULT_VALIDATION_RESULT;\n  let displayValidation = validationBehavior === 'native'\n    ? controlledError || serverError || currentValidity\n    : controlledError || serverError || clientError || builtinValidation || currentValidity;\n\n  return {\n    realtimeValidation,\n    displayValidation,\n    updateValidation(value) {\n      // If validationBehavior is 'aria', update in realtime. Otherwise, store in a ref until commit.\n      if (validationBehavior === 'aria' && !isEqualValidation(currentValidity, value)) {\n        setCurrentValidity(value);\n      } else {\n        nextValidation.current = value;\n      }\n    },\n    resetValidation() {\n      // Update the currently displayed validation state to valid on form reset,\n      // even if the native validity says it isn't. It'll show again on the next form submit.\n      let error = DEFAULT_VALIDATION_RESULT;\n      if (!isEqualValidation(error, lastError.current)) {\n        lastError.current = error;\n        setCurrentValidity(error);\n      }\n\n      // Do not commit validation after the next render. This avoids a condition where\n      // useSelect calls commitValidation inside an onReset handler.\n      if (validationBehavior === 'native') {\n        setCommitQueued(false);\n      }\n\n      setServerErrorCleared(true);\n    },\n    commitValidation() {\n      // Commit validation state so the user sees it on blur/change/submit. Also clear any server errors.\n      // Wait until after the next render to commit so that the latest value has been validated.\n      if (validationBehavior === 'native') {\n        setCommitQueued(true);\n      }\n      setServerErrorCleared(true);\n    }\n  };\n}\n\nfunction asArray<T>(v: T | T[]): T[] {\n  if (!v) {\n    return [];\n  }\n\n  return Array.isArray(v) ? v : [v];\n}\n\nfunction runValidate<T>(validate: ValidationFunction<T>, value: T): string[] {\n  if (typeof validate === 'function') {\n    let e = validate(value);\n    if (e && typeof e !== 'boolean') {\n      return asArray(e);\n    }\n  }\n\n  return [];\n}\n\nfunction getValidationResult(errors: string[]): ValidationResult | null {\n  return errors.length ? {\n    isInvalid: true,\n    validationErrors: errors,\n    validationDetails: CUSTOM_VALIDITY_STATE\n  } : null;\n}\n\nfunction isEqualValidation(a: ValidationResult | null, b: ValidationResult | null): boolean {\n  if (a === b) {\n    return true;\n  }\n\n  return a && b\n    && a.isInvalid === b.isInvalid\n    && a.validationErrors.length === b.validationErrors.length\n    && a.validationErrors.every((a, i) => a === b.validationErrors[i])\n    && Object.entries(a.validationDetails).every(([k, v]) => b.validationDetails[k] === v);\n}\n\nexport function mergeValidation(...results: ValidationResult[]): ValidationResult {\n  let errors = new Set<string>();\n  let isInvalid = false;\n  let validationDetails = {\n    ...VALID_VALIDITY_STATE\n  };\n\n  for (let v of results) {\n    for (let e of v.validationErrors) {\n      errors.add(e);\n    }\n\n    // Only these properties apply for checkboxes.\n    isInvalid ||= v.isInvalid;\n    for (let key in validationDetails) {\n      validationDetails[key] ||= v.validationDetails[key];\n    }\n  }\n\n  validationDetails.valid = !isInvalid;\n  return {\n    isInvalid,\n    validationErrors: [...errors],\n    validationDetails\n  };\n}\n"]},"metadata":{},"sourceType":"module"}