{"ast":null,"code":"import { hookData as $16f0b7bb276bc17e$export$653eddfc964b0f8a } from \"./useDateField.mjs\";\nimport { useDisplayNames as $3aeceb3a64eb8358$export$d42c60378c8168f8 } from \"./useDisplayNames.mjs\";\nimport { toCalendar as $4d1jn$toCalendar, CalendarDate as $4d1jn$CalendarDate } from \"@internationalized/date\";\nimport { isMac as $4d1jn$isMac, scrollIntoViewport as $4d1jn$scrollIntoViewport, getScrollParent as $4d1jn$getScrollParent, useEvent as $4d1jn$useEvent, useLayoutEffect as $4d1jn$useLayoutEffect, isIOS as $4d1jn$isIOS, useId as $4d1jn$useId, useLabels as $4d1jn$useLabels, mergeProps as $4d1jn$mergeProps } from \"@react-aria/utils\";\nimport { NumberParser as $4d1jn$NumberParser } from \"@internationalized/number\";\nimport $4d1jn$react, { useRef as $4d1jn$useRef, useMemo as $4d1jn$useMemo } from \"react\";\nimport { useLocale as $4d1jn$useLocale, useDateFormatter as $4d1jn$useDateFormatter, useFilter as $4d1jn$useFilter } from \"@react-aria/i18n\";\nimport { useSpinButton as $4d1jn$useSpinButton } from \"@react-aria/spinbutton\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $32489daedd52963e$export$1315d136e6f7581(segment, state, ref) {\n  let enteredKeys = (0, $4d1jn$useRef)('');\n  let {\n    locale: locale\n  } = (0, $4d1jn$useLocale)();\n  let displayNames = (0, $3aeceb3a64eb8358$export$d42c60378c8168f8)();\n  let {\n    ariaLabel: ariaLabel,\n    ariaLabelledBy: ariaLabelledBy,\n    ariaDescribedBy: ariaDescribedBy,\n    focusManager: focusManager\n  } = (0, $16f0b7bb276bc17e$export$653eddfc964b0f8a).get(state);\n  let textValue = segment.isPlaceholder ? '' : segment.text;\n  let options = (0, $4d1jn$useMemo)(() => state.dateFormatter.resolvedOptions(), [state.dateFormatter]);\n  let monthDateFormatter = (0, $4d1jn$useDateFormatter)({\n    month: 'long',\n    timeZone: options.timeZone\n  });\n  let hourDateFormatter = (0, $4d1jn$useDateFormatter)({\n    hour: 'numeric',\n    hour12: options.hour12,\n    timeZone: options.timeZone\n  });\n  if (segment.type === 'month' && !segment.isPlaceholder) {\n    let monthTextValue = monthDateFormatter.format(state.dateValue);\n    textValue = monthTextValue !== textValue ? `${textValue} \\u{2013} ${monthTextValue}` : monthTextValue;\n  } else if (segment.type === 'hour' && !segment.isPlaceholder) textValue = hourDateFormatter.format(state.dateValue);\n  let {\n    spinButtonProps: spinButtonProps\n  } = (0, $4d1jn$useSpinButton)({\n    // The ARIA spec says aria-valuenow is optional if there's no value, but aXe seems to require it.\n    // This doesn't seem to have any negative effects with real AT since we also use aria-valuetext.\n    // https://github.com/dequelabs/axe-core/issues/3505\n    value: segment.value,\n    textValue: textValue,\n    minValue: segment.minValue,\n    maxValue: segment.maxValue,\n    isDisabled: state.isDisabled,\n    isReadOnly: state.isReadOnly || !segment.isEditable,\n    isRequired: state.isRequired,\n    onIncrement: () => {\n      enteredKeys.current = '';\n      state.increment(segment.type);\n    },\n    onDecrement: () => {\n      enteredKeys.current = '';\n      state.decrement(segment.type);\n    },\n    onIncrementPage: () => {\n      enteredKeys.current = '';\n      state.incrementPage(segment.type);\n    },\n    onDecrementPage: () => {\n      enteredKeys.current = '';\n      state.decrementPage(segment.type);\n    },\n    onIncrementToMax: () => {\n      enteredKeys.current = '';\n      state.setSegment(segment.type, segment.maxValue);\n    },\n    onDecrementToMin: () => {\n      enteredKeys.current = '';\n      state.setSegment(segment.type, segment.minValue);\n    }\n  });\n  let parser = (0, $4d1jn$useMemo)(() => new (0, $4d1jn$NumberParser)(locale, {\n    maximumFractionDigits: 0\n  }), [locale]);\n  let backspace = () => {\n    if (segment.text === segment.placeholder) focusManager.focusPrevious();\n    if (parser.isValidPartialNumber(segment.text) && !state.isReadOnly && !segment.isPlaceholder) {\n      let newValue = segment.text.slice(0, -1);\n      let parsed = parser.parse(newValue);\n      newValue = parsed === 0 ? '' : newValue;\n      if (newValue.length === 0 || parsed === 0) state.clearSegment(segment.type);else state.setSegment(segment.type, parsed);\n      enteredKeys.current = newValue;\n    } else if (segment.type === 'dayPeriod') state.clearSegment(segment.type);\n  };\n  let onKeyDown = e => {\n    // Firefox does not fire selectstart for Ctrl/Cmd + A\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1742153\n    if (e.key === 'a' && ((0, $4d1jn$isMac)() ? e.metaKey : e.ctrlKey)) e.preventDefault();\n    if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) return;\n    switch (e.key) {\n      case 'Backspace':\n      case 'Delete':\n        // Safari on iOS does not fire beforeinput for the backspace key because the cursor is at the start.\n        e.preventDefault();\n        e.stopPropagation();\n        backspace();\n        break;\n    }\n  };\n  // Safari dayPeriod option doesn't work...\n  let {\n    startsWith: startsWith\n  } = (0, $4d1jn$useFilter)({\n    sensitivity: 'base'\n  });\n  let amPmFormatter = (0, $4d1jn$useDateFormatter)({\n    hour: 'numeric',\n    hour12: true\n  });\n  let am = (0, $4d1jn$useMemo)(() => {\n    let date = new Date();\n    date.setHours(0);\n    return amPmFormatter.formatToParts(date).find(part => part.type === 'dayPeriod').value;\n  }, [amPmFormatter]);\n  let pm = (0, $4d1jn$useMemo)(() => {\n    let date = new Date();\n    date.setHours(12);\n    return amPmFormatter.formatToParts(date).find(part => part.type === 'dayPeriod').value;\n  }, [amPmFormatter]);\n  // Get a list of formatted era names so users can type the first character to choose one.\n  let eraFormatter = (0, $4d1jn$useDateFormatter)({\n    year: 'numeric',\n    era: 'narrow',\n    timeZone: 'UTC'\n  });\n  let eras = (0, $4d1jn$useMemo)(() => {\n    if (segment.type !== 'era') return [];\n    let date = (0, $4d1jn$toCalendar)(new (0, $4d1jn$CalendarDate)(1, 1, 1), state.calendar);\n    let eras = state.calendar.getEras().map(era => {\n      let eraDate = date.set({\n        year: 1,\n        month: 1,\n        day: 1,\n        era: era\n      }).toDate('UTC');\n      let parts = eraFormatter.formatToParts(eraDate);\n      let formatted = parts.find(p => p.type === 'era').value;\n      return {\n        era: era,\n        formatted: formatted\n      };\n    });\n    // Remove the common prefix from formatted values. This is so that in calendars with eras like\n    // ERA0 and ERA1 (e.g. Ethiopic), users can press \"0\" and \"1\" to select an era. In other cases,\n    // the first letter is used.\n    let prefixLength = $32489daedd52963e$var$commonPrefixLength(eras.map(era => era.formatted));\n    if (prefixLength) for (let era of eras) era.formatted = era.formatted.slice(prefixLength);\n    return eras;\n  }, [eraFormatter, state.calendar, segment.type]);\n  let onInput = key => {\n    if (state.isDisabled || state.isReadOnly) return;\n    let newValue = enteredKeys.current + key;\n    switch (segment.type) {\n      case 'dayPeriod':\n        if (startsWith(am, key)) state.setSegment('dayPeriod', 0);else if (startsWith(pm, key)) state.setSegment('dayPeriod', 12);else break;\n        focusManager.focusNext();\n        break;\n      case 'era':\n        {\n          let matched = eras.find(e => startsWith(e.formatted, key));\n          if (matched) {\n            state.setSegment('era', matched.era);\n            focusManager.focusNext();\n          }\n          break;\n        }\n      case 'day':\n      case 'hour':\n      case 'minute':\n      case 'second':\n      case 'month':\n      case 'year':\n        {\n          if (!parser.isValidPartialNumber(newValue)) return;\n          let numberValue = parser.parse(newValue);\n          let segmentValue = numberValue;\n          let allowsZero = segment.minValue === 0;\n          if (segment.type === 'hour' && state.dateFormatter.resolvedOptions().hour12) {\n            switch (state.dateFormatter.resolvedOptions().hourCycle) {\n              case 'h11':\n                if (numberValue > 11) segmentValue = parser.parse(key);\n                break;\n              case 'h12':\n                allowsZero = false;\n                if (numberValue > 12) segmentValue = parser.parse(key);\n                break;\n            }\n            if (segment.value >= 12 && numberValue > 1) numberValue += 12;\n          } else if (numberValue > segment.maxValue) segmentValue = parser.parse(key);\n          if (isNaN(numberValue)) return;\n          let shouldSetValue = segmentValue !== 0 || allowsZero;\n          if (shouldSetValue) state.setSegment(segment.type, segmentValue);\n          if (Number(numberValue + '0') > segment.maxValue || newValue.length >= String(segment.maxValue).length) {\n            enteredKeys.current = '';\n            if (shouldSetValue) focusManager.focusNext();\n          } else enteredKeys.current = newValue;\n          break;\n        }\n    }\n  };\n  let onFocus = () => {\n    enteredKeys.current = '';\n    (0, $4d1jn$scrollIntoViewport)(ref.current, {\n      containingElement: (0, $4d1jn$getScrollParent)(ref.current)\n    });\n    // Collapse selection to start or Chrome won't fire input events.\n    let selection = window.getSelection();\n    selection.collapse(ref.current);\n  };\n  let compositionRef = (0, $4d1jn$useRef)('');\n  // @ts-ignore - TODO: possibly old TS version? doesn't fail in my editor...\n  (0, $4d1jn$useEvent)(ref, 'beforeinput', e => {\n    e.preventDefault();\n    switch (e.inputType) {\n      case 'deleteContentBackward':\n      case 'deleteContentForward':\n        if (parser.isValidPartialNumber(segment.text) && !state.isReadOnly) backspace();\n        break;\n      case 'insertCompositionText':\n        // insertCompositionText cannot be canceled.\n        // Record the current state of the element so we can restore it in the `input` event below.\n        compositionRef.current = ref.current.textContent;\n        // Safari gets stuck in a composition state unless we also assign to the value here.\n        // eslint-disable-next-line no-self-assign\n        ref.current.textContent = ref.current.textContent;\n        break;\n      default:\n        if (e.data != null) onInput(e.data);\n        break;\n    }\n  });\n  (0, $4d1jn$useEvent)(ref, 'input', e => {\n    let {\n      inputType: inputType,\n      data: data\n    } = e;\n    switch (inputType) {\n      case 'insertCompositionText':\n        // Reset the DOM to how it was in the beforeinput event.\n        ref.current.textContent = compositionRef.current;\n        // Android sometimes fires key presses of letters as composition events. Need to handle am/pm keys here too.\n        // Can also happen e.g. with Pinyin keyboard on iOS.\n        if (startsWith(am, data) || startsWith(pm, data)) onInput(data);\n        break;\n    }\n  });\n  (0, $4d1jn$useLayoutEffect)(() => {\n    let element = ref.current;\n    return () => {\n      // If the focused segment is removed, focus the previous one, or the next one if there was no previous one.\n      if (document.activeElement === element) {\n        let prev = focusManager.focusPrevious();\n        if (!prev) focusManager.focusNext();\n      }\n    };\n  }, [ref, focusManager]);\n  // spinbuttons cannot be focused with VoiceOver on iOS.\n  let touchPropOverrides = (0, $4d1jn$isIOS)() || segment.type === 'timeZoneName' ? {\n    role: 'textbox',\n    'aria-valuemax': null,\n    'aria-valuemin': null,\n    'aria-valuetext': null,\n    'aria-valuenow': null\n  } : {};\n  // Only apply aria-describedby to the first segment, unless the field is invalid. This avoids it being\n  // read every time the user navigates to a new segment.\n  let firstSegment = (0, $4d1jn$useMemo)(() => state.segments.find(s => s.isEditable), [state.segments]);\n  if (segment !== firstSegment && !state.isInvalid) ariaDescribedBy = undefined;\n  let id = (0, $4d1jn$useId)();\n  let isEditable = !state.isDisabled && !state.isReadOnly && segment.isEditable;\n  // Prepend the label passed from the field to each segment name.\n  // This is needed because VoiceOver on iOS does not announce groups.\n  let name = segment.type === 'literal' ? '' : displayNames.of(segment.type);\n  let labelProps = (0, $4d1jn$useLabels)({\n    'aria-label': `${name}${ariaLabel ? `, ${ariaLabel}` : ''}${ariaLabelledBy ? ', ' : ''}`,\n    'aria-labelledby': ariaLabelledBy\n  });\n  // Literal segments should not be visible to screen readers. We don't really need any of the above,\n  // but the rules of hooks mean hooks cannot be conditional so we have to put this condition here.\n  if (segment.type === 'literal') return {\n    segmentProps: {\n      'aria-hidden': true\n    }\n  };\n  return {\n    segmentProps: (0, $4d1jn$mergeProps)(spinButtonProps, labelProps, {\n      id: id,\n      ...touchPropOverrides,\n      'aria-invalid': state.isInvalid ? 'true' : undefined,\n      'aria-describedby': ariaDescribedBy,\n      'aria-readonly': state.isReadOnly || !segment.isEditable ? 'true' : undefined,\n      'data-placeholder': segment.isPlaceholder || undefined,\n      contentEditable: isEditable,\n      suppressContentEditableWarning: isEditable,\n      spellCheck: isEditable ? 'false' : undefined,\n      autoCapitalize: isEditable ? 'off' : undefined,\n      autoCorrect: isEditable ? 'off' : undefined,\n      // Capitalization was changed in React 17...\n      [parseInt((0, $4d1jn$react).version, 10) >= 17 ? 'enterKeyHint' : 'enterkeyhint']: isEditable ? 'next' : undefined,\n      inputMode: state.isDisabled || segment.type === 'dayPeriod' || segment.type === 'era' || !isEditable ? undefined : 'numeric',\n      tabIndex: state.isDisabled ? undefined : 0,\n      onKeyDown: onKeyDown,\n      onFocus: onFocus,\n      style: {\n        caretColor: 'transparent'\n      },\n      // Prevent pointer events from reaching useDatePickerGroup, and allow native browser behavior to focus the segment.\n      onPointerDown(e) {\n        e.stopPropagation();\n      },\n      onMouseDown(e) {\n        e.stopPropagation();\n      }\n    })\n  };\n}\nfunction $32489daedd52963e$var$commonPrefixLength(strings) {\n  // Sort the strings, and compare the characters in the first and last to find the common prefix.\n  strings.sort();\n  let first = strings[0];\n  let last = strings[strings.length - 1];\n  for (let i = 0; i < first.length; i++) {\n    if (first[i] !== last[i]) return i;\n  }\n  return 0;\n}\nexport { $32489daedd52963e$export$1315d136e6f7581 as useDateSegment };","map":{"version":3,"mappings":"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","names":["$32489daedd52963e$export$1315d136e6f7581","segment","state","ref","enteredKeys","locale","displayNames","ariaLabel","ariaLabelledBy","ariaDescribedBy","focusManager","get","textValue","isPlaceholder","text","options","dateFormatter","resolvedOptions","monthDateFormatter","month","timeZone","hourDateFormatter","hour","hour12","type","monthTextValue","format","dateValue","spinButtonProps","value","minValue","maxValue","isDisabled","isReadOnly","isEditable","isRequired","onIncrement","current","increment","onDecrement","decrement","onIncrementPage","incrementPage","onDecrementPage","decrementPage","onIncrementToMax","setSegment","onDecrementToMin","parser","maximumFractionDigits","backspace","placeholder","focusPrevious","isValidPartialNumber","newValue","slice","parsed","parse","length","clearSegment","onKeyDown","e","key","metaKey","ctrlKey","preventDefault","shiftKey","altKey","stopPropagation","startsWith","sensitivity","amPmFormatter","am","date","Date","setHours","formatToParts","find","part","pm","eraFormatter","year","era","eras","calendar","getEras","map","eraDate","set","day","toDate","parts","formatted","p","prefixLength","$32489daedd52963e$var$commonPrefixLength","onInput","focusNext","matched","numberValue","segmentValue","allowsZero","hourCycle","isNaN","shouldSetValue","Number","String","onFocus","containingElement","selection","window","getSelection","collapse","compositionRef","inputType","textContent","data","element","document","activeElement","prev","touchPropOverrides","role","firstSegment","segments","s","isInvalid","undefined","id","name","of","labelProps","segmentProps","contentEditable","suppressContentEditableWarning","spellCheck","autoCapitalize","autoCorrect","parseInt","version","inputMode","tabIndex","style","caretColor","onPointerDown","onMouseDown","strings","sort","first","last","i"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-aria\\datepicker\\dist\\packages\\@react-aria\\datepicker\\src\\useDateSegment.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CalendarDate, toCalendar} from '@internationalized/date';\nimport {DateFieldState, DateSegment} from '@react-stately/datepicker';\nimport {DOMAttributes} from '@react-types/shared';\nimport {getScrollParent, isIOS, isMac, mergeProps, scrollIntoViewport, useEvent, useId, useLabels, useLayoutEffect} from '@react-aria/utils';\nimport {hookData} from './useDateField';\nimport {NumberParser} from '@internationalized/number';\nimport React, {RefObject, useMemo, useRef} from 'react';\nimport {useDateFormatter, useFilter, useLocale} from '@react-aria/i18n';\nimport {useDisplayNames} from './useDisplayNames';\nimport {useSpinButton} from '@react-aria/spinbutton';\n\nexport interface DateSegmentAria {\n  /** Props for the segment element. */\n  segmentProps: DOMAttributes\n}\n\n/**\n * Provides the behavior and accessibility implementation for a segment in a date field.\n * A date segment displays an individual unit of a date and time, and allows users to edit\n * the value by typing or using the arrow keys to increment and decrement.\n */\nexport function useDateSegment(segment: DateSegment, state: DateFieldState, ref: RefObject<HTMLElement>): DateSegmentAria {\n  let enteredKeys = useRef('');\n  let {locale} = useLocale();\n  let displayNames = useDisplayNames();\n  let {ariaLabel, ariaLabelledBy, ariaDescribedBy, focusManager} = hookData.get(state);\n\n  let textValue = segment.isPlaceholder ? '' : segment.text;\n  let options = useMemo(() => state.dateFormatter.resolvedOptions(), [state.dateFormatter]);\n  let monthDateFormatter = useDateFormatter({month: 'long', timeZone: options.timeZone});\n  let hourDateFormatter = useDateFormatter({\n    hour: 'numeric',\n    hour12: options.hour12,\n    timeZone: options.timeZone\n  });\n\n  if (segment.type === 'month' && !segment.isPlaceholder) {\n    let monthTextValue = monthDateFormatter.format(state.dateValue);\n    textValue = monthTextValue !== textValue ? `${textValue} – ${monthTextValue}` : monthTextValue;\n  } else if (segment.type === 'hour' && !segment.isPlaceholder) {\n    textValue = hourDateFormatter.format(state.dateValue);\n  }\n\n  let {spinButtonProps} = useSpinButton({\n    // The ARIA spec says aria-valuenow is optional if there's no value, but aXe seems to require it.\n    // This doesn't seem to have any negative effects with real AT since we also use aria-valuetext.\n    // https://github.com/dequelabs/axe-core/issues/3505\n    value: segment.value,\n    textValue,\n    minValue: segment.minValue,\n    maxValue: segment.maxValue,\n    isDisabled: state.isDisabled,\n    isReadOnly: state.isReadOnly || !segment.isEditable,\n    isRequired: state.isRequired,\n    onIncrement: () => {\n      enteredKeys.current = '';\n      state.increment(segment.type);\n    },\n    onDecrement: () => {\n      enteredKeys.current = '';\n      state.decrement(segment.type);\n    },\n    onIncrementPage: () => {\n      enteredKeys.current = '';\n      state.incrementPage(segment.type);\n    },\n    onDecrementPage: () => {\n      enteredKeys.current = '';\n      state.decrementPage(segment.type);\n    },\n    onIncrementToMax: () => {\n      enteredKeys.current = '';\n      state.setSegment(segment.type, segment.maxValue);\n    },\n    onDecrementToMin: () => {\n      enteredKeys.current = '';\n      state.setSegment(segment.type, segment.minValue);\n    }\n  });\n\n  let parser = useMemo(() => new NumberParser(locale, {maximumFractionDigits: 0}), [locale]);\n\n  let backspace = () => {\n    if (segment.text === segment.placeholder) {\n      focusManager.focusPrevious();\n    }\n    if (parser.isValidPartialNumber(segment.text) && !state.isReadOnly && !segment.isPlaceholder) {\n      let newValue = segment.text.slice(0, -1);\n      let parsed = parser.parse(newValue);\n      newValue = parsed === 0 ? '' : newValue;\n      if (newValue.length === 0 || parsed === 0) {\n        state.clearSegment(segment.type);\n      } else {\n        state.setSegment(segment.type, parsed);\n      }\n      enteredKeys.current = newValue;\n    } else if (segment.type === 'dayPeriod') {\n      state.clearSegment(segment.type);\n    }\n  };\n\n  let onKeyDown = (e) => {\n    // Firefox does not fire selectstart for Ctrl/Cmd + A\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1742153\n    if (e.key === 'a' && (isMac() ? e.metaKey : e.ctrlKey)) {\n      e.preventDefault();\n    }\n\n    if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) {\n      return;\n    }\n\n    switch (e.key) {\n      case 'Backspace':\n      case 'Delete': {\n        // Safari on iOS does not fire beforeinput for the backspace key because the cursor is at the start.\n        e.preventDefault();\n        e.stopPropagation();\n        backspace();\n        break;\n      }\n    }\n  };\n\n  // Safari dayPeriod option doesn't work...\n  let {startsWith} = useFilter({sensitivity: 'base'});\n  let amPmFormatter = useDateFormatter({hour: 'numeric', hour12: true});\n  let am = useMemo(() => {\n    let date = new Date();\n    date.setHours(0);\n    return amPmFormatter.formatToParts(date).find(part => part.type === 'dayPeriod').value;\n  }, [amPmFormatter]);\n\n  let pm = useMemo(() => {\n    let date = new Date();\n    date.setHours(12);\n    return amPmFormatter.formatToParts(date).find(part => part.type === 'dayPeriod').value;\n  }, [amPmFormatter]);\n\n  // Get a list of formatted era names so users can type the first character to choose one.\n  let eraFormatter = useDateFormatter({year: 'numeric', era: 'narrow', timeZone: 'UTC'});\n  let eras = useMemo(() => {\n    if (segment.type !== 'era') {\n      return [];\n    }\n\n    let date = toCalendar(new CalendarDate(1, 1, 1), state.calendar);\n    let eras = state.calendar.getEras().map(era => {\n      let eraDate = date.set({year: 1, month: 1, day: 1, era}).toDate('UTC');\n      let parts = eraFormatter.formatToParts(eraDate);\n      let formatted = parts.find(p => p.type === 'era').value;\n      return {era, formatted};\n    });\n\n    // Remove the common prefix from formatted values. This is so that in calendars with eras like\n    // ERA0 and ERA1 (e.g. Ethiopic), users can press \"0\" and \"1\" to select an era. In other cases,\n    // the first letter is used.\n    let prefixLength = commonPrefixLength(eras.map(era => era.formatted));\n    if (prefixLength) {\n      for (let era of eras) {\n        era.formatted = era.formatted.slice(prefixLength);\n      }\n    }\n\n    return eras;\n  }, [eraFormatter, state.calendar, segment.type]);\n\n  let onInput = (key: string) => {\n    if (state.isDisabled || state.isReadOnly) {\n      return;\n    }\n\n    let newValue = enteredKeys.current + key;\n\n    switch (segment.type) {\n      case 'dayPeriod':\n        if (startsWith(am, key)) {\n          state.setSegment('dayPeriod', 0);\n        } else if (startsWith(pm, key)) {\n          state.setSegment('dayPeriod', 12);\n        } else {\n          break;\n        }\n        focusManager.focusNext();\n        break;\n      case 'era': {\n        let matched = eras.find(e => startsWith(e.formatted, key));\n        if (matched) {\n          state.setSegment('era', matched.era);\n          focusManager.focusNext();\n        }\n        break;\n      }\n      case 'day':\n      case 'hour':\n      case 'minute':\n      case 'second':\n      case 'month':\n      case 'year': {\n        if (!parser.isValidPartialNumber(newValue)) {\n          return;\n        }\n\n        let numberValue = parser.parse(newValue);\n        let segmentValue = numberValue;\n        let allowsZero = segment.minValue === 0;\n        if (segment.type === 'hour' && state.dateFormatter.resolvedOptions().hour12) {\n          switch (state.dateFormatter.resolvedOptions().hourCycle) {\n            case 'h11':\n              if (numberValue > 11) {\n                segmentValue = parser.parse(key);\n              }\n              break;\n            case 'h12':\n              allowsZero = false;\n              if (numberValue > 12) {\n                segmentValue = parser.parse(key);\n              }\n              break;\n          }\n\n          if (segment.value >= 12 && numberValue > 1) {\n            numberValue += 12;\n          }\n        } else if (numberValue > segment.maxValue) {\n          segmentValue = parser.parse(key);\n        }\n\n        if (isNaN(numberValue)) {\n          return;\n        }\n\n        let shouldSetValue = segmentValue !== 0 || allowsZero;\n        if (shouldSetValue) {\n          state.setSegment(segment.type, segmentValue);\n        }\n\n        if (Number(numberValue + '0') > segment.maxValue || newValue.length >= String(segment.maxValue).length) {\n          enteredKeys.current = '';\n          if (shouldSetValue) {\n            focusManager.focusNext();\n          }\n        } else {\n          enteredKeys.current = newValue;\n        }\n        break;\n      }\n    }\n  };\n\n  let onFocus = () => {\n    enteredKeys.current = '';\n    scrollIntoViewport(ref.current, {containingElement: getScrollParent(ref.current)});\n\n    // Collapse selection to start or Chrome won't fire input events.\n    let selection = window.getSelection();\n    selection.collapse(ref.current);\n  };\n\n  let compositionRef = useRef('');\n  // @ts-ignore - TODO: possibly old TS version? doesn't fail in my editor...\n  useEvent(ref, 'beforeinput', e => {\n    e.preventDefault();\n\n    switch (e.inputType) {\n      case 'deleteContentBackward':\n      case 'deleteContentForward':\n        if (parser.isValidPartialNumber(segment.text) && !state.isReadOnly) {\n          backspace();\n        }\n        break;\n      case 'insertCompositionText':\n        // insertCompositionText cannot be canceled.\n        // Record the current state of the element so we can restore it in the `input` event below.\n        compositionRef.current = ref.current.textContent;\n\n        // Safari gets stuck in a composition state unless we also assign to the value here.\n        // eslint-disable-next-line no-self-assign\n        ref.current.textContent = ref.current.textContent;\n        break;\n      default:\n        if (e.data != null) {\n          onInput(e.data);\n        }\n        break;\n    }\n  });\n\n  useEvent(ref, 'input', (e: InputEvent) => {\n    let {inputType, data} = e;\n    switch (inputType) {\n      case 'insertCompositionText':\n        // Reset the DOM to how it was in the beforeinput event.\n        ref.current.textContent = compositionRef.current;\n\n        // Android sometimes fires key presses of letters as composition events. Need to handle am/pm keys here too.\n        // Can also happen e.g. with Pinyin keyboard on iOS.\n        if (startsWith(am, data) || startsWith(pm, data)) {\n          onInput(data);\n        }\n        break;\n    }\n  });\n\n  useLayoutEffect(() => {\n    let element = ref.current;\n    return () => {\n      // If the focused segment is removed, focus the previous one, or the next one if there was no previous one.\n      if (document.activeElement === element) {\n        let prev = focusManager.focusPrevious();\n        if (!prev) {\n          focusManager.focusNext();\n        }\n      }\n    };\n  }, [ref, focusManager]);\n\n  // spinbuttons cannot be focused with VoiceOver on iOS.\n  let touchPropOverrides = isIOS() || segment.type === 'timeZoneName' ? {\n    role: 'textbox',\n    'aria-valuemax': null,\n    'aria-valuemin': null,\n    'aria-valuetext': null,\n    'aria-valuenow': null\n  } : {};\n\n  // Only apply aria-describedby to the first segment, unless the field is invalid. This avoids it being\n  // read every time the user navigates to a new segment.\n  let firstSegment = useMemo(() => state.segments.find(s => s.isEditable), [state.segments]);\n  if (segment !== firstSegment && !state.isInvalid) {\n    ariaDescribedBy = undefined;\n  }\n\n  let id = useId();\n  let isEditable = !state.isDisabled && !state.isReadOnly && segment.isEditable;\n\n  // Prepend the label passed from the field to each segment name.\n  // This is needed because VoiceOver on iOS does not announce groups.\n  let name = segment.type === 'literal' ? '' : displayNames.of(segment.type);\n  let labelProps = useLabels({\n    'aria-label': `${name}${ariaLabel ? `, ${ariaLabel}` : ''}${ariaLabelledBy ? ', ' : ''}`,\n    'aria-labelledby': ariaLabelledBy\n  });\n\n  // Literal segments should not be visible to screen readers. We don't really need any of the above,\n  // but the rules of hooks mean hooks cannot be conditional so we have to put this condition here.\n  if (segment.type === 'literal') {\n    return {\n      segmentProps: {\n        'aria-hidden': true\n      }\n    };\n  }\n\n  return {\n    segmentProps: mergeProps(spinButtonProps, labelProps, {\n      id,\n      ...touchPropOverrides,\n      'aria-invalid': state.isInvalid ? 'true' : undefined,\n      'aria-describedby': ariaDescribedBy,\n      'aria-readonly': state.isReadOnly || !segment.isEditable ? 'true' : undefined,\n      'data-placeholder': segment.isPlaceholder || undefined,\n      contentEditable: isEditable,\n      suppressContentEditableWarning: isEditable,\n      spellCheck: isEditable ? 'false' : undefined,\n      autoCapitalize: isEditable ? 'off' : undefined,\n      autoCorrect: isEditable ? 'off' : undefined,\n      // Capitalization was changed in React 17...\n      [parseInt(React.version, 10) >= 17 ? 'enterKeyHint' : 'enterkeyhint']: isEditable ? 'next' : undefined,\n      inputMode: state.isDisabled || segment.type === 'dayPeriod' || segment.type === 'era' || !isEditable ? undefined : 'numeric',\n      tabIndex: state.isDisabled ? undefined : 0,\n      onKeyDown,\n      onFocus,\n      style: {\n        caretColor: 'transparent'\n      },\n      // Prevent pointer events from reaching useDatePickerGroup, and allow native browser behavior to focus the segment.\n      onPointerDown(e) {\n        e.stopPropagation();\n      },\n      onMouseDown(e) {\n        e.stopPropagation();\n      }\n    })\n  };\n}\n\nfunction commonPrefixLength(strings: string[]): number {\n  // Sort the strings, and compare the characters in the first and last to find the common prefix.\n  strings.sort();\n  let first = strings[0];\n  let last = strings[strings.length - 1];\n  for (let i = 0; i < first.length; i++) {\n    if (first[i] !== last[i]) {\n      return i;\n    }\n  }\n  return 0;\n}\n"]},"metadata":{},"sourceType":"module"}