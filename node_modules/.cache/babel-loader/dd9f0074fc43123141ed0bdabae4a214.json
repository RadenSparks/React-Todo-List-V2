{"ast":null,"code":"import $3HATx$intlStringsmodulejs from \"./intlStrings.mjs\";\nimport { isSameDay as $3HATx$isSameDay, startOfMonth as $3HATx$startOfMonth, endOfMonth as $3HATx$endOfMonth } from \"@internationalized/date\";\nimport { useLocalizedStringFormatter as $3HATx$useLocalizedStringFormatter, useDateFormatter as $3HATx$useDateFormatter } from \"@react-aria/i18n\";\nimport { useMemo as $3HATx$useMemo } from \"react\";\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $a074e1e2d0f0a665$export$653eddfc964b0f8a = new WeakMap();\nfunction $a074e1e2d0f0a665$export$134cbb7fb09a9522(date) {\n  return (date === null || date === void 0 ? void 0 : date.calendar.identifier) === 'gregory' && date.era === 'BC' ? 'short' : undefined;\n}\nfunction $a074e1e2d0f0a665$export$b6df97c887c38e1a(state) {\n  let stringFormatter = (0, $3HATx$useLocalizedStringFormatter)((0, $parcel$interopDefault($3HATx$intlStringsmodulejs)), '@react-aria/calendar');\n  let start, end;\n  if ('highlightedRange' in state) ({\n    start: start,\n    end: end\n  } = state.highlightedRange || {});else start = end = state.value;\n  let dateFormatter = (0, $3HATx$useDateFormatter)({\n    weekday: 'long',\n    month: 'long',\n    year: 'numeric',\n    day: 'numeric',\n    era: $a074e1e2d0f0a665$export$134cbb7fb09a9522(start) || $a074e1e2d0f0a665$export$134cbb7fb09a9522(end),\n    timeZone: state.timeZone\n  });\n  let anchorDate = 'anchorDate' in state ? state.anchorDate : null;\n  return (0, $3HATx$useMemo)(() => {\n    // No message if currently selecting a range, or there is nothing highlighted.\n    if (!anchorDate && start && end) {\n      // Use a single date message if the start and end dates are the same day,\n      // otherwise include both dates.\n      if ((0, $3HATx$isSameDay)(start, end)) {\n        let date = dateFormatter.format(start.toDate(state.timeZone));\n        return stringFormatter.format('selectedDateDescription', {\n          date: date\n        });\n      } else {\n        let dateRange = $a074e1e2d0f0a665$var$formatRange(dateFormatter, stringFormatter, start, end, state.timeZone);\n        return stringFormatter.format('selectedRangeDescription', {\n          dateRange: dateRange\n        });\n      }\n    }\n    return '';\n  }, [start, end, anchorDate, state.timeZone, stringFormatter, dateFormatter]);\n}\nfunction $a074e1e2d0f0a665$export$31afe65d91ef6e8(startDate, endDate, timeZone, isAria) {\n  let stringFormatter = (0, $3HATx$useLocalizedStringFormatter)((0, $parcel$interopDefault($3HATx$intlStringsmodulejs)), '@react-aria/calendar');\n  let era = $a074e1e2d0f0a665$export$134cbb7fb09a9522(startDate) || $a074e1e2d0f0a665$export$134cbb7fb09a9522(endDate);\n  let monthFormatter = (0, $3HATx$useDateFormatter)({\n    month: 'long',\n    year: 'numeric',\n    era: era,\n    calendar: startDate.calendar.identifier,\n    timeZone: timeZone\n  });\n  let dateFormatter = (0, $3HATx$useDateFormatter)({\n    month: 'long',\n    year: 'numeric',\n    day: 'numeric',\n    era: era,\n    calendar: startDate.calendar.identifier,\n    timeZone: timeZone\n  });\n  return (0, $3HATx$useMemo)(() => {\n    // Special case for month granularity. Format as a single month if only a\n    // single month is visible, otherwise format as a range of months.\n    if ((0, $3HATx$isSameDay)(startDate, (0, $3HATx$startOfMonth)(startDate))) {\n      if ((0, $3HATx$isSameDay)(endDate, (0, $3HATx$endOfMonth)(startDate))) return monthFormatter.format(startDate.toDate(timeZone));else if ((0, $3HATx$isSameDay)(endDate, (0, $3HATx$endOfMonth)(endDate))) return isAria ? $a074e1e2d0f0a665$var$formatRange(monthFormatter, stringFormatter, startDate, endDate, timeZone) : monthFormatter.formatRange(startDate.toDate(timeZone), endDate.toDate(timeZone));\n    }\n    return isAria ? $a074e1e2d0f0a665$var$formatRange(dateFormatter, stringFormatter, startDate, endDate, timeZone) : dateFormatter.formatRange(startDate.toDate(timeZone), endDate.toDate(timeZone));\n  }, [startDate, endDate, monthFormatter, dateFormatter, stringFormatter, timeZone, isAria]);\n}\nfunction $a074e1e2d0f0a665$var$formatRange(dateFormatter, stringFormatter, start, end, timeZone) {\n  let parts = dateFormatter.formatRangeToParts(start.toDate(timeZone), end.toDate(timeZone));\n  // Find the separator between the start and end date. This is determined\n  // by finding the last shared literal before the end range.\n  let separatorIndex = -1;\n  for (let i = 0; i < parts.length; i++) {\n    let part = parts[i];\n    if (part.source === 'shared' && part.type === 'literal') separatorIndex = i;else if (part.source === 'endRange') break;\n  }\n  // Now we can combine the parts into start and end strings.\n  let startValue = '';\n  let endValue = '';\n  for (let i = 0; i < parts.length; i++) {\n    if (i < separatorIndex) startValue += parts[i].value;else if (i > separatorIndex) endValue += parts[i].value;\n  }\n  return stringFormatter.format('dateRange', {\n    startDate: startValue,\n    endDate: endValue\n  });\n}\nexport { $a074e1e2d0f0a665$export$653eddfc964b0f8a as hookData, $a074e1e2d0f0a665$export$134cbb7fb09a9522 as getEraFormat, $a074e1e2d0f0a665$export$b6df97c887c38e1a as useSelectedDateDescription, $a074e1e2d0f0a665$export$31afe65d91ef6e8 as useVisibleRangeDescription };","map":{"version":3,"mappings":"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","names":["$a074e1e2d0f0a665$export$653eddfc964b0f8a","WeakMap","$a074e1e2d0f0a665$export$134cbb7fb09a9522","date","calendar","identifier","era","undefined","$a074e1e2d0f0a665$export$b6df97c887c38e1a","state","stringFormatter","start","end","highlightedRange","value","dateFormatter","weekday","month","year","day","timeZone","anchorDate","format","toDate","dateRange","$a074e1e2d0f0a665$var$formatRange","$a074e1e2d0f0a665$export$31afe65d91ef6e8","startDate","endDate","isAria","monthFormatter","formatRange","parts","formatRangeToParts","separatorIndex","i","length","part","source","type","startValue","endValue"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-aria\\calendar\\dist\\packages\\@react-aria\\calendar\\src\\utils.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CalendarDate, DateFormatter, endOfMonth, isSameDay, startOfMonth} from '@internationalized/date';\nimport {CalendarState, RangeCalendarState} from '@react-stately/calendar';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport type {LocalizedStringFormatter} from '@internationalized/string';\nimport {useDateFormatter, useLocalizedStringFormatter} from '@react-aria/i18n';\nimport {useMemo} from 'react';\n\ninterface HookData {\n  ariaLabel: string,\n  ariaLabelledBy: string,\n  errorMessageId: string,\n  selectedDateDescription: string\n}\n\nexport const hookData = new WeakMap<CalendarState | RangeCalendarState, HookData>();\n\nexport function getEraFormat(date: CalendarDate): 'short' | undefined {\n  return date?.calendar.identifier === 'gregory' && date.era === 'BC' ? 'short' : undefined;\n}\n\nexport function useSelectedDateDescription(state: CalendarState | RangeCalendarState) {\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/calendar');\n\n  let start: CalendarDate, end: CalendarDate;\n  if ('highlightedRange' in state) {\n    ({start, end} = state.highlightedRange || {});\n  } else {\n    start = end = state.value;\n  }\n\n  let dateFormatter = useDateFormatter({\n    weekday: 'long',\n    month: 'long',\n    year: 'numeric',\n    day: 'numeric',\n    era: getEraFormat(start) || getEraFormat(end),\n    timeZone: state.timeZone\n  });\n\n  let anchorDate = 'anchorDate' in state ? state.anchorDate : null;\n  return useMemo(() => {\n    // No message if currently selecting a range, or there is nothing highlighted.\n    if (!anchorDate && start && end) {\n      // Use a single date message if the start and end dates are the same day,\n      // otherwise include both dates.\n      if (isSameDay(start, end)) {\n        let date = dateFormatter.format(start.toDate(state.timeZone));\n        return stringFormatter.format('selectedDateDescription', {date});\n      } else {\n        let dateRange = formatRange(dateFormatter, stringFormatter, start, end, state.timeZone);\n\n        return stringFormatter.format('selectedRangeDescription', {dateRange});\n      }\n    }\n    return '';\n  }, [start, end, anchorDate, state.timeZone, stringFormatter, dateFormatter]);\n}\n\nexport function useVisibleRangeDescription(startDate: CalendarDate, endDate: CalendarDate, timeZone: string, isAria: boolean) {\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/calendar');\n  let era: any = getEraFormat(startDate) || getEraFormat(endDate);\n  let monthFormatter = useDateFormatter({\n    month: 'long',\n    year: 'numeric',\n    era,\n    calendar: startDate.calendar.identifier,\n    timeZone\n  });\n\n  let dateFormatter = useDateFormatter({\n    month: 'long',\n    year: 'numeric',\n    day: 'numeric',\n    era,\n    calendar: startDate.calendar.identifier,\n    timeZone\n  });\n\n  return useMemo(() => {\n    // Special case for month granularity. Format as a single month if only a\n    // single month is visible, otherwise format as a range of months.\n    if (isSameDay(startDate, startOfMonth(startDate))) {\n      if (isSameDay(endDate, endOfMonth(startDate))) {\n        return monthFormatter.format(startDate.toDate(timeZone));\n      } else if (isSameDay(endDate, endOfMonth(endDate))) {\n        return isAria\n          ? formatRange(monthFormatter, stringFormatter, startDate, endDate, timeZone)\n          : monthFormatter.formatRange(startDate.toDate(timeZone), endDate.toDate(timeZone));\n      }\n    }\n\n    return isAria\n      ? formatRange(dateFormatter, stringFormatter, startDate, endDate, timeZone)\n      : dateFormatter.formatRange(startDate.toDate(timeZone), endDate.toDate(timeZone));\n  }, [startDate, endDate, monthFormatter, dateFormatter, stringFormatter, timeZone, isAria]);\n}\n\nfunction formatRange(dateFormatter: DateFormatter, stringFormatter: LocalizedStringFormatter, start: CalendarDate, end: CalendarDate, timeZone: string) {\n  let parts = dateFormatter.formatRangeToParts(start.toDate(timeZone), end.toDate(timeZone));\n\n  // Find the separator between the start and end date. This is determined\n  // by finding the last shared literal before the end range.\n  let separatorIndex = -1;\n  for (let i = 0; i < parts.length; i++) {\n    let part = parts[i];\n    if (part.source === 'shared' && part.type === 'literal') {\n      separatorIndex = i;\n    } else if (part.source === 'endRange') {\n      break;\n    }\n  }\n\n  // Now we can combine the parts into start and end strings.\n  let startValue = '';\n  let endValue = '';\n  for (let i = 0; i < parts.length; i++) {\n    if (i < separatorIndex) {\n      startValue += parts[i].value;\n    } else if (i > separatorIndex) {\n      endValue += parts[i].value;\n    }\n  }\n\n  return stringFormatter.format('dateRange', {startDate: startValue, endDate: endValue});\n}\n"]},"metadata":{},"sourceType":"module"}