{"ast":null,"code":"import { getEraFormat as $a074e1e2d0f0a665$export$134cbb7fb09a9522, hookData as $a074e1e2d0f0a665$export$653eddfc964b0f8a } from \"./utils.mjs\";\nimport $dm6hl$intlStringsmodulejs from \"./intlStrings.mjs\";\nimport { isSameDay as $dm6hl$isSameDay, isEqualDay as $dm6hl$isEqualDay, isToday as $dm6hl$isToday } from \"@internationalized/date\";\nimport { useDeepMemo as $dm6hl$useDeepMemo, useDescription as $dm6hl$useDescription, focusWithoutScrolling as $dm6hl$focusWithoutScrolling, scrollIntoViewport as $dm6hl$scrollIntoViewport, getScrollParent as $dm6hl$getScrollParent, mergeProps as $dm6hl$mergeProps } from \"@react-aria/utils\";\nimport { usePress as $dm6hl$usePress, getInteractionModality as $dm6hl$getInteractionModality } from \"@react-aria/interactions\";\nimport { useMemo as $dm6hl$useMemo, useRef as $dm6hl$useRef, useEffect as $dm6hl$useEffect } from \"react\";\nimport { useLocalizedStringFormatter as $dm6hl$useLocalizedStringFormatter, useDateFormatter as $dm6hl$useDateFormatter } from \"@react-aria/i18n\";\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $36a0ac60f04457c5$export$136073280381448e(props, state, ref) {\n  let {\n    date: date,\n    isDisabled: isDisabled\n  } = props;\n  let {\n    errorMessageId: errorMessageId,\n    selectedDateDescription: selectedDateDescription\n  } = (0, $a074e1e2d0f0a665$export$653eddfc964b0f8a).get(state);\n  let stringFormatter = (0, $dm6hl$useLocalizedStringFormatter)((0, $parcel$interopDefault($dm6hl$intlStringsmodulejs)), '@react-aria/calendar');\n  let dateFormatter = (0, $dm6hl$useDateFormatter)({\n    weekday: 'long',\n    day: 'numeric',\n    month: 'long',\n    year: 'numeric',\n    era: (0, $a074e1e2d0f0a665$export$134cbb7fb09a9522)(date),\n    timeZone: state.timeZone\n  });\n  let isSelected = state.isSelected(date);\n  let isFocused = state.isCellFocused(date);\n  isDisabled = isDisabled || state.isCellDisabled(date);\n  let isUnavailable = state.isCellUnavailable(date);\n  let isSelectable = !isDisabled && !isUnavailable;\n  let isInvalid = state.isValueInvalid && ('highlightedRange' in state ? !state.anchorDate && state.highlightedRange && date.compare(state.highlightedRange.start) >= 0 && date.compare(state.highlightedRange.end) <= 0 : state.value && (0, $dm6hl$isSameDay)(state.value, date));\n  if (isInvalid) isSelected = true;\n  // For performance, reuse the same date object as before if the new date prop is the same.\n  // This allows subsequent useMemo results to be reused.\n  date = (0, $dm6hl$useDeepMemo)(date, (0, $dm6hl$isEqualDay));\n  let nativeDate = (0, $dm6hl$useMemo)(() => date.toDate(state.timeZone), [date, state.timeZone]);\n  // aria-label should be localize Day of week, Month, Day and Year without Time.\n  let isDateToday = (0, $dm6hl$isToday)(date, state.timeZone);\n  let label = (0, $dm6hl$useMemo)(() => {\n    let label = '';\n    // If this is a range calendar, add a description of the full selected range\n    // to the first and last selected date.\n    if ('highlightedRange' in state && state.value && !state.anchorDate && ((0, $dm6hl$isSameDay)(date, state.value.start) || (0, $dm6hl$isSameDay)(date, state.value.end))) label = selectedDateDescription + ', ';\n    label += dateFormatter.format(nativeDate);\n    if (isDateToday)\n      // If date is today, set appropriate string depending on selected state:\n      label = stringFormatter.format(isSelected ? 'todayDateSelected' : 'todayDate', {\n        date: label\n      });else if (isSelected)\n      // If date is selected but not today:\n      label = stringFormatter.format('dateSelected', {\n        date: label\n      });\n    if (state.minValue && (0, $dm6hl$isSameDay)(date, state.minValue)) label += ', ' + stringFormatter.format('minimumDate');else if (state.maxValue && (0, $dm6hl$isSameDay)(date, state.maxValue)) label += ', ' + stringFormatter.format('maximumDate');\n    return label;\n  }, [dateFormatter, nativeDate, stringFormatter, isSelected, isDateToday, date, state, selectedDateDescription]);\n  // When a cell is focused and this is a range calendar, add a prompt to help\n  // screenreader users know that they are in a range selection mode.\n  let rangeSelectionPrompt = '';\n  if ('anchorDate' in state && isFocused && !state.isReadOnly && isSelectable) {\n    // If selection has started add \"click to finish selecting range\"\n    if (state.anchorDate) rangeSelectionPrompt = stringFormatter.format('finishRangeSelectionPrompt');else rangeSelectionPrompt = stringFormatter.format('startRangeSelectionPrompt');\n  }\n  let descriptionProps = (0, $dm6hl$useDescription)(rangeSelectionPrompt);\n  let isAnchorPressed = (0, $dm6hl$useRef)(false);\n  let isRangeBoundaryPressed = (0, $dm6hl$useRef)(false);\n  let touchDragTimerRef = (0, $dm6hl$useRef)(null);\n  let {\n    pressProps: pressProps,\n    isPressed: isPressed\n  } = (0, $dm6hl$usePress)({\n    // When dragging to select a range, we don't want dragging over the original anchor\n    // again to trigger onPressStart. Cancel presses immediately when the pointer exits.\n    shouldCancelOnPointerExit: 'anchorDate' in state && !!state.anchorDate,\n    preventFocusOnPress: true,\n    isDisabled: !isSelectable || state.isReadOnly,\n    onPressStart(e) {\n      if (state.isReadOnly) {\n        state.setFocusedDate(date);\n        return;\n      }\n      if ('highlightedRange' in state && !state.anchorDate && (e.pointerType === 'mouse' || e.pointerType === 'touch')) {\n        // Allow dragging the start or end date of a range to modify it\n        // rather than starting a new selection.\n        // Don't allow dragging when invalid, or weird jumping behavior may occur as date ranges\n        // are constrained to available dates. The user will need to select a new range in this case.\n        if (state.highlightedRange && !isInvalid) {\n          if ((0, $dm6hl$isSameDay)(date, state.highlightedRange.start)) {\n            state.setAnchorDate(state.highlightedRange.end);\n            state.setFocusedDate(date);\n            state.setDragging(true);\n            isRangeBoundaryPressed.current = true;\n            return;\n          } else if ((0, $dm6hl$isSameDay)(date, state.highlightedRange.end)) {\n            state.setAnchorDate(state.highlightedRange.start);\n            state.setFocusedDate(date);\n            state.setDragging(true);\n            isRangeBoundaryPressed.current = true;\n            return;\n          }\n        }\n        let startDragging = () => {\n          state.setDragging(true);\n          touchDragTimerRef.current = null;\n          state.selectDate(date);\n          state.setFocusedDate(date);\n          isAnchorPressed.current = true;\n        };\n        // Start selection on mouse/touch down so users can drag to select a range.\n        // On touch, delay dragging to determine if the user really meant to scroll.\n        if (e.pointerType === 'touch') touchDragTimerRef.current = setTimeout(startDragging, 200);else startDragging();\n      }\n    },\n    onPressEnd() {\n      isRangeBoundaryPressed.current = false;\n      isAnchorPressed.current = false;\n      clearTimeout(touchDragTimerRef.current);\n      touchDragTimerRef.current = null;\n    },\n    onPress() {\n      // For non-range selection, always select on press up.\n      if (!('anchorDate' in state) && !state.isReadOnly) {\n        state.selectDate(date);\n        state.setFocusedDate(date);\n      }\n    },\n    onPressUp(e) {\n      if (state.isReadOnly) return;\n      // If the user tapped quickly, the date won't be selected yet and the\n      // timer will still be in progress. In this case, select the date on touch up.\n      // Timer is cleared in onPressEnd.\n      if ('anchorDate' in state && touchDragTimerRef.current) {\n        state.selectDate(date);\n        state.setFocusedDate(date);\n      }\n      if ('anchorDate' in state) {\n        if (isRangeBoundaryPressed.current)\n          // When clicking on the start or end date of an already selected range,\n          // start a new selection on press up to also allow dragging the date to\n          // change the existing range.\n          state.setAnchorDate(date);else if (state.anchorDate && !isAnchorPressed.current) {\n          // When releasing a drag or pressing the end date of a range, select it.\n          state.selectDate(date);\n          state.setFocusedDate(date);\n        } else if (e.pointerType === 'keyboard' && !state.anchorDate) {\n          // For range selection, auto-advance the focused date by one if using keyboard.\n          // This gives an indication that you're selecting a range rather than a single date.\n          // For mouse, this is unnecessary because users will see the indication on hover. For screen readers,\n          // there will be an announcement to \"click to finish selecting range\" (above).\n          state.selectDate(date);\n          let nextDay = date.add({\n            days: 1\n          });\n          if (state.isInvalid(nextDay)) nextDay = date.subtract({\n            days: 1\n          });\n          if (!state.isInvalid(nextDay)) state.setFocusedDate(nextDay);\n        } else if (e.pointerType === 'virtual') {\n          // For screen readers, just select the date on click.\n          state.selectDate(date);\n          state.setFocusedDate(date);\n        }\n      }\n    }\n  });\n  let tabIndex = null;\n  if (!isDisabled) tabIndex = (0, $dm6hl$isSameDay)(date, state.focusedDate) ? 0 : -1;\n  // Focus the button in the DOM when the state updates.\n  (0, $dm6hl$useEffect)(() => {\n    if (isFocused && ref.current) {\n      (0, $dm6hl$focusWithoutScrolling)(ref.current);\n      // Scroll into view if navigating with a keyboard, otherwise\n      // try not to shift the view under the user's mouse/finger.\n      // If in a overlay, scrollIntoViewport will only cause scrolling\n      // up to the overlay scroll body to prevent overlay shifting.\n      // Also only scroll into view if the cell actually got focused.\n      // There are some cases where the cell might be disabled or inside,\n      // an inert container and we don't want to scroll then.\n      if ((0, $dm6hl$getInteractionModality)() !== 'pointer' && document.activeElement === ref.current) (0, $dm6hl$scrollIntoViewport)(ref.current, {\n        containingElement: (0, $dm6hl$getScrollParent)(ref.current)\n      });\n    }\n  }, [isFocused, ref]);\n  let cellDateFormatter = (0, $dm6hl$useDateFormatter)({\n    day: 'numeric',\n    timeZone: state.timeZone,\n    calendar: date.calendar.identifier\n  });\n  let formattedDate = (0, $dm6hl$useMemo)(() => cellDateFormatter.formatToParts(nativeDate).find(part => part.type === 'day').value, [cellDateFormatter, nativeDate]);\n  return {\n    cellProps: {\n      role: 'gridcell',\n      'aria-disabled': !isSelectable || null,\n      'aria-selected': isSelected || null,\n      'aria-invalid': isInvalid || null\n    },\n    buttonProps: (0, $dm6hl$mergeProps)(pressProps, {\n      onFocus() {\n        if (!isDisabled) state.setFocusedDate(date);\n      },\n      tabIndex: tabIndex,\n      role: 'button',\n      'aria-disabled': !isSelectable || null,\n      'aria-label': label,\n      'aria-invalid': isInvalid || null,\n      'aria-describedby': [isInvalid ? errorMessageId : null, descriptionProps['aria-describedby']].filter(Boolean).join(' ') || undefined,\n      onPointerEnter(e) {\n        // Highlight the date on hover or drag over a date when selecting a range.\n        if ('highlightDate' in state && (e.pointerType !== 'touch' || state.isDragging) && isSelectable) state.highlightDate(date);\n      },\n      onPointerDown(e) {\n        // This is necessary on touch devices to allow dragging\n        // outside the original pressed element.\n        // (JSDOM does not support this)\n        if ('releasePointerCapture' in e.target) e.target.releasePointerCapture(e.pointerId);\n      },\n      onContextMenu(e) {\n        // Prevent context menu on long press.\n        e.preventDefault();\n      }\n    }),\n    isPressed: isPressed,\n    isFocused: isFocused,\n    isSelected: isSelected,\n    isDisabled: isDisabled,\n    isUnavailable: isUnavailable,\n    isOutsideVisibleRange: date.compare(state.visibleRange.start) < 0 || date.compare(state.visibleRange.end) > 0,\n    isInvalid: isInvalid,\n    formattedDate: formattedDate\n  };\n}\nexport { $36a0ac60f04457c5$export$136073280381448e as useCalendarCell };","map":{"version":3,"mappings":"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","names":["$36a0ac60f04457c5$export$136073280381448e","props","state","ref","date","isDisabled","errorMessageId","selectedDateDescription","get","stringFormatter","dateFormatter","weekday","day","month","year","era","timeZone","isSelected","isFocused","isCellFocused","isCellDisabled","isUnavailable","isCellUnavailable","isSelectable","isInvalid","isValueInvalid","anchorDate","highlightedRange","compare","start","end","value","nativeDate","toDate","isDateToday","label","format","minValue","maxValue","rangeSelectionPrompt","isReadOnly","descriptionProps","isAnchorPressed","isRangeBoundaryPressed","touchDragTimerRef","pressProps","isPressed","shouldCancelOnPointerExit","preventFocusOnPress","onPressStart","e","setFocusedDate","pointerType","setAnchorDate","setDragging","current","startDragging","selectDate","setTimeout","onPressEnd","clearTimeout","onPress","onPressUp","nextDay","add","days","subtract","tabIndex","focusedDate","document","activeElement","containingElement","cellDateFormatter","calendar","identifier","formattedDate","formatToParts","find","part","type","cellProps","role","buttonProps","onFocus","filter","Boolean","join","undefined","onPointerEnter","isDragging","highlightDate","onPointerDown","target","releasePointerCapture","pointerId","onContextMenu","preventDefault","isOutsideVisibleRange","visibleRange"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-aria\\calendar\\dist\\packages\\@react-aria\\calendar\\src\\useCalendarCell.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CalendarDate, isEqualDay, isSameDay, isToday} from '@internationalized/date';\nimport {CalendarState, RangeCalendarState} from '@react-stately/calendar';\nimport {DOMAttributes} from '@react-types/shared';\nimport {focusWithoutScrolling, getScrollParent, mergeProps, scrollIntoViewport, useDeepMemo, useDescription} from '@react-aria/utils';\nimport {getEraFormat, hookData} from './utils';\nimport {getInteractionModality, usePress} from '@react-aria/interactions';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport {RefObject, useEffect, useMemo, useRef} from 'react';\nimport {useDateFormatter, useLocalizedStringFormatter} from '@react-aria/i18n';\n\nexport interface AriaCalendarCellProps {\n  /** The date that this cell represents. */\n  date: CalendarDate,\n  /**\n   * Whether the cell is disabled. By default, this is determined by the\n   * Calendar's `minValue`, `maxValue`, and `isDisabled` props.\n   */\n  isDisabled?: boolean\n}\n\nexport interface CalendarCellAria {\n  /** Props for the grid cell element (e.g. `<td>`). */\n  cellProps: DOMAttributes,\n  /** Props for the button element within the cell. */\n  buttonProps: DOMAttributes,\n  /** Whether the cell is currently being pressed. */\n  isPressed: boolean,\n  /** Whether the cell is selected. */\n  isSelected: boolean,\n  /** Whether the cell is focused. */\n  isFocused: boolean,\n  /**\n   * Whether the cell is disabled, according to the calendar's `minValue`, `maxValue`, and `isDisabled` props.\n   * Disabled dates are not focusable, and cannot be selected by the user. They are typically\n   * displayed with a dimmed appearance.\n   */\n  isDisabled: boolean,\n  /**\n   * Whether the cell is unavailable, according to the calendar's `isDateUnavailable` prop. Unavailable dates remain\n   * focusable, but cannot be selected by the user. They should be displayed with a visual affordance to indicate they\n   * are unavailable, such as a different color or a strikethrough.\n   *\n   * Note that because they are focusable, unavailable dates must meet a 4.5:1 color contrast ratio,\n   * [as defined by WCAG](https://www.w3.org/WAI/WCAG21/Understanding/contrast-minimum.html).\n   */\n  isUnavailable: boolean,\n  /**\n   * Whether the cell is outside the visible range of the calendar.\n   * For example, dates before the first day of a month in the same week.\n   */\n  isOutsideVisibleRange: boolean,\n  /** Whether the cell is part of an invalid selection. */\n  isInvalid: boolean,\n  /** The day number formatted according to the current locale. */\n  formattedDate: string\n}\n\n/**\n * Provides the behavior and accessibility implementation for a calendar cell component.\n * A calendar cell displays a date cell within a calendar grid which can be selected by the user.\n */\nexport function useCalendarCell(props: AriaCalendarCellProps, state: CalendarState | RangeCalendarState, ref: RefObject<HTMLElement>): CalendarCellAria {\n  let {date, isDisabled} = props;\n  let {errorMessageId, selectedDateDescription} = hookData.get(state);\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/calendar');\n  let dateFormatter = useDateFormatter({\n    weekday: 'long',\n    day: 'numeric',\n    month: 'long',\n    year: 'numeric',\n    era: getEraFormat(date),\n    timeZone: state.timeZone\n  });\n  let isSelected = state.isSelected(date);\n  let isFocused = state.isCellFocused(date);\n  isDisabled = isDisabled || state.isCellDisabled(date);\n  let isUnavailable = state.isCellUnavailable(date);\n  let isSelectable = !isDisabled && !isUnavailable;\n  let isInvalid = state.isValueInvalid && (\n    'highlightedRange' in state\n      ? !state.anchorDate && state.highlightedRange && date.compare(state.highlightedRange.start) >= 0 && date.compare(state.highlightedRange.end) <= 0\n      : state.value && isSameDay(state.value, date)\n  );\n\n  if (isInvalid) {\n    isSelected = true;\n  }\n\n  // For performance, reuse the same date object as before if the new date prop is the same.\n  // This allows subsequent useMemo results to be reused.\n  date = useDeepMemo<CalendarDate>(date, isEqualDay);\n  let nativeDate = useMemo(() => date.toDate(state.timeZone), [date, state.timeZone]);\n\n  // aria-label should be localize Day of week, Month, Day and Year without Time.\n  let isDateToday = isToday(date, state.timeZone);\n  let label = useMemo(() => {\n    let label = '';\n\n    // If this is a range calendar, add a description of the full selected range\n    // to the first and last selected date.\n    if (\n      'highlightedRange' in state &&\n      state.value &&\n      !state.anchorDate &&\n      (isSameDay(date, state.value.start) || isSameDay(date, state.value.end))\n    ) {\n      label = selectedDateDescription + ', ';\n    }\n\n    label += dateFormatter.format(nativeDate);\n    if (isDateToday) {\n      // If date is today, set appropriate string depending on selected state:\n      label = stringFormatter.format(isSelected ? 'todayDateSelected' : 'todayDate', {\n        date: label\n      });\n    } else if (isSelected) {\n      // If date is selected but not today:\n      label = stringFormatter.format('dateSelected', {\n        date: label\n      });\n    }\n\n    if (state.minValue && isSameDay(date, state.minValue)) {\n      label += ', ' + stringFormatter.format('minimumDate');\n    } else if (state.maxValue && isSameDay(date, state.maxValue)) {\n      label += ', ' + stringFormatter.format('maximumDate');\n    }\n\n    return label;\n  }, [dateFormatter, nativeDate, stringFormatter, isSelected, isDateToday, date, state, selectedDateDescription]);\n\n  // When a cell is focused and this is a range calendar, add a prompt to help\n  // screenreader users know that they are in a range selection mode.\n  let rangeSelectionPrompt = '';\n  if ('anchorDate' in state && isFocused && !state.isReadOnly && isSelectable) {\n    // If selection has started add \"click to finish selecting range\"\n    if (state.anchorDate) {\n      rangeSelectionPrompt = stringFormatter.format('finishRangeSelectionPrompt');\n    // Otherwise, add \"click to start selecting range\" prompt\n    } else {\n      rangeSelectionPrompt = stringFormatter.format('startRangeSelectionPrompt');\n    }\n  }\n\n  let descriptionProps = useDescription(rangeSelectionPrompt);\n\n  let isAnchorPressed = useRef(false);\n  let isRangeBoundaryPressed = useRef(false);\n  let touchDragTimerRef = useRef(null);\n  let {pressProps, isPressed} = usePress({\n    // When dragging to select a range, we don't want dragging over the original anchor\n    // again to trigger onPressStart. Cancel presses immediately when the pointer exits.\n    shouldCancelOnPointerExit: 'anchorDate' in state && !!state.anchorDate,\n    preventFocusOnPress: true,\n    isDisabled: !isSelectable || state.isReadOnly,\n    onPressStart(e) {\n      if (state.isReadOnly) {\n        state.setFocusedDate(date);\n        return;\n      }\n\n      if ('highlightedRange' in state && !state.anchorDate && (e.pointerType === 'mouse' || e.pointerType === 'touch')) {\n        // Allow dragging the start or end date of a range to modify it\n        // rather than starting a new selection.\n        // Don't allow dragging when invalid, or weird jumping behavior may occur as date ranges\n        // are constrained to available dates. The user will need to select a new range in this case.\n        if (state.highlightedRange && !isInvalid) {\n          if (isSameDay(date, state.highlightedRange.start)) {\n            state.setAnchorDate(state.highlightedRange.end);\n            state.setFocusedDate(date);\n            state.setDragging(true);\n            isRangeBoundaryPressed.current = true;\n            return;\n          } else if (isSameDay(date, state.highlightedRange.end)) {\n            state.setAnchorDate(state.highlightedRange.start);\n            state.setFocusedDate(date);\n            state.setDragging(true);\n            isRangeBoundaryPressed.current = true;\n            return;\n          }\n        }\n\n        let startDragging = () => {\n          state.setDragging(true);\n          touchDragTimerRef.current = null;\n\n          state.selectDate(date);\n          state.setFocusedDate(date);\n          isAnchorPressed.current = true;\n        };\n\n        // Start selection on mouse/touch down so users can drag to select a range.\n        // On touch, delay dragging to determine if the user really meant to scroll.\n        if (e.pointerType === 'touch') {\n          touchDragTimerRef.current = setTimeout(startDragging, 200);\n        } else {\n          startDragging();\n        }\n      }\n    },\n    onPressEnd() {\n      isRangeBoundaryPressed.current = false;\n      isAnchorPressed.current = false;\n      clearTimeout(touchDragTimerRef.current);\n      touchDragTimerRef.current = null;\n    },\n    onPress() {\n      // For non-range selection, always select on press up.\n      if (!('anchorDate' in state) && !state.isReadOnly) {\n        state.selectDate(date);\n        state.setFocusedDate(date);\n      }\n    },\n    onPressUp(e) {\n      if (state.isReadOnly) {\n        return;\n      }\n\n      // If the user tapped quickly, the date won't be selected yet and the\n      // timer will still be in progress. In this case, select the date on touch up.\n      // Timer is cleared in onPressEnd.\n      if ('anchorDate' in state && touchDragTimerRef.current) {\n        state.selectDate(date);\n        state.setFocusedDate(date);\n      }\n\n      if ('anchorDate' in state) {\n        if (isRangeBoundaryPressed.current) {\n          // When clicking on the start or end date of an already selected range,\n          // start a new selection on press up to also allow dragging the date to\n          // change the existing range.\n          state.setAnchorDate(date);\n        } else if (state.anchorDate && !isAnchorPressed.current) {\n          // When releasing a drag or pressing the end date of a range, select it.\n          state.selectDate(date);\n          state.setFocusedDate(date);\n        } else if (e.pointerType === 'keyboard' && !state.anchorDate) {\n          // For range selection, auto-advance the focused date by one if using keyboard.\n          // This gives an indication that you're selecting a range rather than a single date.\n          // For mouse, this is unnecessary because users will see the indication on hover. For screen readers,\n          // there will be an announcement to \"click to finish selecting range\" (above).\n          state.selectDate(date);\n          let nextDay = date.add({days: 1});\n          if (state.isInvalid(nextDay)) {\n            nextDay = date.subtract({days: 1});\n          }\n          if (!state.isInvalid(nextDay)) {\n            state.setFocusedDate(nextDay);\n          }\n        } else if (e.pointerType === 'virtual') {\n          // For screen readers, just select the date on click.\n          state.selectDate(date);\n          state.setFocusedDate(date);\n        }\n      }\n    }\n  });\n\n  let tabIndex = null;\n  if (!isDisabled) {\n    tabIndex = isSameDay(date, state.focusedDate) ? 0 : -1;\n  }\n\n  // Focus the button in the DOM when the state updates.\n  useEffect(() => {\n    if (isFocused && ref.current) {\n      focusWithoutScrolling(ref.current);\n\n      // Scroll into view if navigating with a keyboard, otherwise\n      // try not to shift the view under the user's mouse/finger.\n      // If in a overlay, scrollIntoViewport will only cause scrolling\n      // up to the overlay scroll body to prevent overlay shifting.\n      // Also only scroll into view if the cell actually got focused.\n      // There are some cases where the cell might be disabled or inside,\n      // an inert container and we don't want to scroll then.\n      if (getInteractionModality() !== 'pointer' && document.activeElement === ref.current) {\n        scrollIntoViewport(ref.current, {containingElement: getScrollParent(ref.current)});\n      }\n    }\n  }, [isFocused, ref]);\n\n  let cellDateFormatter = useDateFormatter({\n    day: 'numeric',\n    timeZone: state.timeZone,\n    calendar: date.calendar.identifier\n  });\n\n  let formattedDate = useMemo(() => cellDateFormatter.formatToParts(nativeDate).find(part => part.type === 'day').value, [cellDateFormatter, nativeDate]);\n\n  return {\n    cellProps: {\n      role: 'gridcell',\n      'aria-disabled': !isSelectable || null,\n      'aria-selected': isSelected || null,\n      'aria-invalid': isInvalid || null\n    },\n    buttonProps: mergeProps(pressProps, {\n      onFocus() {\n        if (!isDisabled) {\n          state.setFocusedDate(date);\n        }\n      },\n      tabIndex,\n      role: 'button',\n      'aria-disabled': !isSelectable || null,\n      'aria-label': label,\n      'aria-invalid': isInvalid || null,\n      'aria-describedby': [\n        isInvalid ? errorMessageId : null,\n        descriptionProps['aria-describedby']\n      ].filter(Boolean).join(' ') || undefined,\n      onPointerEnter(e) {\n        // Highlight the date on hover or drag over a date when selecting a range.\n        if ('highlightDate' in state && (e.pointerType !== 'touch' || state.isDragging) && isSelectable) {\n          state.highlightDate(date);\n        }\n      },\n      onPointerDown(e) {\n        // This is necessary on touch devices to allow dragging\n        // outside the original pressed element.\n        // (JSDOM does not support this)\n        if ('releasePointerCapture' in e.target) {\n          e.target.releasePointerCapture(e.pointerId);\n        }\n      },\n      onContextMenu(e) {\n        // Prevent context menu on long press.\n        e.preventDefault();\n      }\n    }),\n    isPressed,\n    isFocused,\n    isSelected,\n    isDisabled,\n    isUnavailable,\n    isOutsideVisibleRange: date.compare(state.visibleRange.start) < 0 || date.compare(state.visibleRange.end) > 0,\n    isInvalid,\n    formattedDate\n  };\n}\n"]},"metadata":{},"sourceType":"module"}