{"ast":null,"code":"import { getColumnHeaderId as $2140fb2337097f2d$export$37cd4213f2ad742e } from \"./utils.mjs\";\nimport $d9Rqy$intlStringsmodulejs from \"./intlStrings.mjs\";\nimport { useRef as $d9Rqy$useRef, useCallback as $d9Rqy$useCallback, useEffect as $d9Rqy$useEffect } from \"react\";\nimport { focusSafely as $d9Rqy$focusSafely } from \"@react-aria/focus\";\nimport { useId as $d9Rqy$useId, useEffectEvent as $d9Rqy$useEffectEvent, useDescription as $d9Rqy$useDescription, mergeProps as $d9Rqy$mergeProps } from \"@react-aria/utils\";\nimport { useKeyboard as $d9Rqy$useKeyboard, useMove as $d9Rqy$useMove, useInteractionModality as $d9Rqy$useInteractionModality, usePress as $d9Rqy$usePress } from \"@react-aria/interactions\";\nimport { useLocalizedStringFormatter as $d9Rqy$useLocalizedStringFormatter, useLocale as $d9Rqy$useLocale } from \"@react-aria/i18n\";\nimport { useVisuallyHidden as $d9Rqy$useVisuallyHidden } from \"@react-aria/visually-hidden\";\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $e91ef4e5004e3774$export$52994e973806c219(props, state, ref) {\n  let {\n    column: item,\n    triggerRef: triggerRef,\n    isDisabled: isDisabled,\n    onResizeStart: onResizeStart,\n    onResize: onResize,\n    onResizeEnd: onResizeEnd,\n    'aria-label': ariaLabel\n  } = props;\n  const stringFormatter = (0, $d9Rqy$useLocalizedStringFormatter)((0, $parcel$interopDefault($d9Rqy$intlStringsmodulejs)), '@react-aria/table');\n  let id = (0, $d9Rqy$useId)();\n  let isResizing = state.resizingColumn === item.key;\n  let isResizingRef = (0, $d9Rqy$useRef)(isResizing);\n  let lastSize = (0, $d9Rqy$useRef)(null);\n  let wasFocusedOnResizeStart = (0, $d9Rqy$useRef)(false);\n  let editModeEnabled = state.tableState.isKeyboardNavigationDisabled;\n  let {\n    direction: direction\n  } = (0, $d9Rqy$useLocale)();\n  let {\n    keyboardProps: keyboardProps\n  } = (0, $d9Rqy$useKeyboard)({\n    onKeyDown: e => {\n      if (editModeEnabled) {\n        if (e.key === 'Escape' || e.key === 'Enter' || e.key === ' ' || e.key === 'Tab') {\n          e.preventDefault();\n          endResize(item);\n        }\n      } else {\n        // Continue propagation on keydown events so they still bubbles to useSelectableCollection and are handled there\n        e.continuePropagation();\n        if (e.key === 'Enter') startResize(item);\n      }\n    }\n  });\n  let startResize = (0, $d9Rqy$useEffectEvent)(item => {\n    if (!isResizingRef.current) {\n      lastSize.current = state.updateResizedColumns(item.key, state.getColumnWidth(item.key));\n      state.startResize(item.key);\n      state.tableState.setKeyboardNavigationDisabled(true);\n      onResizeStart === null || onResizeStart === void 0 ? void 0 : onResizeStart(lastSize.current);\n    }\n    isResizingRef.current = true;\n  });\n  let resize = (0, $d9Rqy$useEffectEvent)((item, newWidth) => {\n    let sizes = state.updateResizedColumns(item.key, newWidth);\n    onResize === null || onResize === void 0 ? void 0 : onResize(sizes);\n    lastSize.current = sizes;\n  });\n  let endResize = (0, $d9Rqy$useEffectEvent)(item => {\n    if (isResizingRef.current) {\n      if (lastSize.current == null) lastSize.current = state.updateResizedColumns(item.key, state.getColumnWidth(item.key));\n      state.endResize();\n      state.tableState.setKeyboardNavigationDisabled(false);\n      onResizeEnd === null || onResizeEnd === void 0 ? void 0 : onResizeEnd(lastSize.current);\n      isResizingRef.current = false;\n      if ((triggerRef === null || triggerRef === void 0 ? void 0 : triggerRef.current) && !wasFocusedOnResizeStart.current)\n        // switch focus back to the column header unless the resizer was already focused when resizing started.\n        (0, $d9Rqy$focusSafely)(triggerRef.current);\n    }\n    lastSize.current = null;\n  });\n  const columnResizeWidthRef = (0, $d9Rqy$useRef)(0);\n  const {\n    moveProps: moveProps\n  } = (0, $d9Rqy$useMove)({\n    onMoveStart() {\n      columnResizeWidthRef.current = state.getColumnWidth(item.key);\n      startResize(item);\n    },\n    onMove(e) {\n      let {\n        deltaX: deltaX,\n        deltaY: deltaY,\n        pointerType: pointerType\n      } = e;\n      if (direction === 'rtl') deltaX *= -1;\n      if (pointerType === 'keyboard') {\n        if (deltaY !== 0 && deltaX === 0) deltaX = deltaY * -1;\n        deltaX *= 10;\n      }\n      // if moving up/down only, no need to resize\n      if (deltaX !== 0) {\n        columnResizeWidthRef.current += deltaX;\n        resize(item, columnResizeWidthRef.current);\n      }\n    },\n    onMoveEnd(e) {\n      let {\n        pointerType: pointerType\n      } = e;\n      columnResizeWidthRef.current = 0;\n      if (pointerType === 'mouse' || pointerType === 'touch' && wasFocusedOnResizeStart.current) endResize(item);\n    }\n  });\n  let onKeyDown = (0, $d9Rqy$useCallback)(e => {\n    if (editModeEnabled) moveProps.onKeyDown(e);\n  }, [editModeEnabled, moveProps]);\n  let min = Math.floor(state.getColumnMinWidth(item.key));\n  let max = Math.floor(state.getColumnMaxWidth(item.key));\n  if (max === Infinity) max = Number.MAX_SAFE_INTEGER;\n  let value = Math.floor(state.getColumnWidth(item.key));\n  let modality = (0, $d9Rqy$useInteractionModality)();\n  if (modality === 'virtual' && typeof window !== 'undefined' && 'ontouchstart' in window) modality = 'touch';\n  let description = (triggerRef === null || triggerRef === void 0 ? void 0 : triggerRef.current) == null && (modality === 'keyboard' || modality === 'virtual') && !isResizing ? stringFormatter.format('resizerDescription') : undefined;\n  let descriptionProps = (0, $d9Rqy$useDescription)(description);\n  let ariaProps = {\n    'aria-label': ariaLabel,\n    'aria-orientation': 'horizontal',\n    'aria-labelledby': `${id} ${(0, $2140fb2337097f2d$export$37cd4213f2ad742e)(state.tableState, item.key)}`,\n    'aria-valuetext': stringFormatter.format('columnSize', {\n      value: value\n    }),\n    'type': 'range',\n    min: min,\n    max: max,\n    value: value,\n    ...descriptionProps\n  };\n  const focusInput = (0, $d9Rqy$useCallback)(() => {\n    if (ref.current) (0, $d9Rqy$focusSafely)(ref.current);\n  }, [ref]);\n  let resizingColumn = state.resizingColumn;\n  let prevResizingColumn = (0, $d9Rqy$useRef)(null);\n  (0, $d9Rqy$useEffect)(() => {\n    if (prevResizingColumn.current !== resizingColumn && resizingColumn != null && resizingColumn === item.key) {\n      wasFocusedOnResizeStart.current = document.activeElement === ref.current;\n      startResize(item);\n      // Delay focusing input until Android Chrome's delayed click after touchend happens: https://bugs.chromium.org/p/chromium/issues/detail?id=1150073\n      let timeout = setTimeout(() => focusInput(), 0);\n      // VoiceOver on iOS has problems focusing the input from a menu.\n      let VOTimeout = setTimeout(focusInput, 400);\n      return () => {\n        clearTimeout(timeout);\n        clearTimeout(VOTimeout);\n      };\n    }\n    prevResizingColumn.current = resizingColumn;\n  }, [resizingColumn, item, focusInput, ref, startResize]);\n  let onChange = e => {\n    let currentWidth = state.getColumnWidth(item.key);\n    let nextValue = parseFloat(e.target.value);\n    if (nextValue > currentWidth) nextValue = currentWidth + 10;else nextValue = currentWidth - 10;\n    resize(item, nextValue);\n  };\n  let {\n    pressProps: pressProps\n  } = (0, $d9Rqy$usePress)({\n    onPressStart: e => {\n      if (e.ctrlKey || e.altKey || e.metaKey || e.shiftKey || e.pointerType === 'keyboard') return;\n      if (e.pointerType === 'virtual' && state.resizingColumn != null) {\n        endResize(item);\n        return;\n      }\n      // Sometimes onPress won't trigger for quick taps on mobile so we want to focus the input so blurring away\n      // can cancel resize mode for us.\n      focusInput();\n      // If resizer is always visible, mobile screenreader user can access the visually hidden resizer directly and thus we don't need\n      // to handle a virtual click to start the resizer.\n      if (e.pointerType !== 'virtual') startResize(item);\n    },\n    onPress: e => {\n      if ((e.pointerType === 'touch' && wasFocusedOnResizeStart.current || e.pointerType === 'mouse') && state.resizingColumn != null) endResize(item);\n    }\n  });\n  let {\n    visuallyHiddenProps: visuallyHiddenProps\n  } = (0, $d9Rqy$useVisuallyHidden)();\n  return {\n    resizerProps: (0, $d9Rqy$mergeProps)(keyboardProps, {\n      ...moveProps,\n      onKeyDown: onKeyDown\n    }, pressProps, {\n      style: {\n        touchAction: 'none'\n      }\n    }),\n    inputProps: (0, $d9Rqy$mergeProps)(visuallyHiddenProps, {\n      id: id,\n      onBlur: () => {\n        endResize(item);\n      },\n      onChange: onChange,\n      disabled: isDisabled\n    }, ariaProps),\n    isResizing: isResizing\n  };\n}\nexport { $e91ef4e5004e3774$export$52994e973806c219 as useTableColumnResize };","map":{"version":3,"mappings":"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","names":["$e91ef4e5004e3774$export$52994e973806c219","props","state","ref","column","item","triggerRef","isDisabled","onResizeStart","onResize","onResizeEnd","ariaLabel","stringFormatter","id","isResizing","resizingColumn","key","isResizingRef","lastSize","wasFocusedOnResizeStart","editModeEnabled","tableState","isKeyboardNavigationDisabled","direction","keyboardProps","onKeyDown","e","preventDefault","endResize","continuePropagation","startResize","current","updateResizedColumns","getColumnWidth","setKeyboardNavigationDisabled","resize","newWidth","sizes","columnResizeWidthRef","moveProps","onMoveStart","onMove","deltaX","deltaY","pointerType","onMoveEnd","min","Math","floor","getColumnMinWidth","max","getColumnMaxWidth","Infinity","Number","MAX_SAFE_INTEGER","value","modality","window","description","format","undefined","descriptionProps","ariaProps","focusInput","prevResizingColumn","document","activeElement","timeout","setTimeout","VOTimeout","clearTimeout","onChange","currentWidth","nextValue","parseFloat","target","pressProps","onPressStart","ctrlKey","altKey","metaKey","shiftKey","onPress","visuallyHiddenProps","resizerProps","style","touchAction","inputProps","onBlur","disabled"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-aria\\table\\dist\\packages\\@react-aria\\table\\src\\useTableColumnResize.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {ChangeEvent, RefObject, useCallback, useEffect, useRef} from 'react';\nimport {ColumnSize} from '@react-types/table';\nimport {DOMAttributes, FocusableElement, Key} from '@react-types/shared';\nimport {focusSafely} from '@react-aria/focus';\nimport {getColumnHeaderId} from './utils';\nimport {GridNode} from '@react-types/grid';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport {mergeProps, useDescription, useEffectEvent, useId} from '@react-aria/utils';\nimport {TableColumnResizeState} from '@react-stately/table';\nimport {useInteractionModality, useKeyboard, useMove, usePress} from '@react-aria/interactions';\nimport {useLocale, useLocalizedStringFormatter} from '@react-aria/i18n';\nimport {useVisuallyHidden} from '@react-aria/visually-hidden';\n\nexport interface TableColumnResizeAria {\n  /** Props for the visually hidden input element. */\n  inputProps: DOMAttributes,\n  /** Props for the resizer element. */\n  resizerProps: DOMAttributes,\n  /** Whether this column is currently being resized. */\n  isResizing: boolean\n}\n\nexport interface AriaTableColumnResizeProps<T> {\n  /** An object representing the [column header](https://www.w3.org/TR/wai-aria-1.1/#columnheader). Contains all the relevant information that makes up the column header. */\n  column: GridNode<T>,\n  /** Aria label for the hidden input. Gets read when resizing. */\n  'aria-label': string,\n  /**\n   * Ref to the trigger if resizing was started from a column header menu. If it's provided,\n   * focus will be returned there when resizing is done. If it isn't provided, it is assumed that the resizer is\n   * visible at all time and keyboard resizing is started via pressing Enter on the resizer and not on focus.\n   * */\n  triggerRef?: RefObject<FocusableElement>,\n  /** If resizing is disabled. */\n  isDisabled?: boolean,\n  /** Called when resizing starts. */\n  onResizeStart?: (widths: Map<Key, ColumnSize>) => void,\n  /** Called for every resize event that results in new column sizes. */\n  onResize?: (widths: Map<Key, ColumnSize>) => void,\n  /** Called when resizing ends. */\n  onResizeEnd?: (widths: Map<Key, ColumnSize>) => void\n}\n\n/**\n * Provides the behavior and accessibility implementation for a table column resizer element.\n * @param props - Props for the resizer.\n * @param state - State for the table's resizable columns, as returned by `useTableColumnResizeState`.\n * @param ref - The ref attached to the resizer's visually hidden input element.\n */\nexport function useTableColumnResize<T>(props: AriaTableColumnResizeProps<T>, state: TableColumnResizeState<T>, ref: RefObject<HTMLInputElement>): TableColumnResizeAria {\n  let {column: item, triggerRef, isDisabled, onResizeStart, onResize, onResizeEnd, 'aria-label': ariaLabel} = props;\n  const stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/table');\n  let id = useId();\n  let isResizing = state.resizingColumn === item.key;\n  let isResizingRef = useRef(isResizing);\n  let lastSize = useRef(null);\n  let wasFocusedOnResizeStart = useRef(false);\n  let editModeEnabled = state.tableState.isKeyboardNavigationDisabled;\n\n  let {direction} = useLocale();\n  let {keyboardProps} = useKeyboard({\n    onKeyDown: (e) => {\n      if (editModeEnabled) {\n        if (e.key === 'Escape' || e.key === 'Enter' || e.key === ' ' || e.key === 'Tab') {\n          e.preventDefault();\n          endResize(item);\n        }\n      } else {\n        // Continue propagation on keydown events so they still bubbles to useSelectableCollection and are handled there\n        e.continuePropagation();\n\n        if (e.key === 'Enter') {\n          startResize(item);\n        }\n      }\n    }\n  });\n\n  let startResize = useEffectEvent((item) => {\n    if (!isResizingRef.current) {\n      lastSize.current = state.updateResizedColumns(item.key, state.getColumnWidth(item.key));\n      state.startResize(item.key);\n      state.tableState.setKeyboardNavigationDisabled(true);\n      onResizeStart?.(lastSize.current);\n    }\n    isResizingRef.current = true;\n  });\n\n  let resize = useEffectEvent((item, newWidth) => {\n    let sizes = state.updateResizedColumns(item.key, newWidth);\n    onResize?.(sizes);\n    lastSize.current = sizes;\n  });\n\n  let endResize = useEffectEvent((item) => {\n    if (isResizingRef.current) {\n      if (lastSize.current == null) {\n        lastSize.current = state.updateResizedColumns(item.key, state.getColumnWidth(item.key));\n      }\n\n      state.endResize();\n      state.tableState.setKeyboardNavigationDisabled(false);\n      onResizeEnd?.(lastSize.current);\n      isResizingRef.current = false;\n\n      if (triggerRef?.current && !wasFocusedOnResizeStart.current) {\n        // switch focus back to the column header unless the resizer was already focused when resizing started.\n        focusSafely(triggerRef.current);\n      }\n    }\n    lastSize.current = null;\n  });\n\n  const columnResizeWidthRef = useRef<number>(0);\n  const {moveProps} = useMove({\n    onMoveStart() {\n      columnResizeWidthRef.current = state.getColumnWidth(item.key);\n      startResize(item);\n    },\n    onMove(e) {\n      let {deltaX, deltaY, pointerType} = e;\n      if (direction === 'rtl') {\n        deltaX *= -1;\n      }\n      if (pointerType === 'keyboard') {\n        if (deltaY !== 0 && deltaX === 0) {\n          deltaX = deltaY * -1;\n        }\n        deltaX *= 10;\n      }\n      // if moving up/down only, no need to resize\n      if (deltaX !== 0) {\n        columnResizeWidthRef.current += deltaX;\n        resize(item, columnResizeWidthRef.current);\n      }\n    },\n    onMoveEnd(e) {\n      let {pointerType} = e;\n      columnResizeWidthRef.current = 0;\n      if (pointerType === 'mouse' || (pointerType === 'touch' && wasFocusedOnResizeStart.current)) {\n        endResize(item);\n      }\n    }\n  });\n\n  let onKeyDown = useCallback((e) => {\n    if (editModeEnabled) {\n      moveProps.onKeyDown(e);\n    }\n  }, [editModeEnabled, moveProps]);\n\n\n  let min = Math.floor(state.getColumnMinWidth(item.key));\n  let max = Math.floor(state.getColumnMaxWidth(item.key));\n  if (max === Infinity) {\n    max = Number.MAX_SAFE_INTEGER;\n  }\n  let value = Math.floor(state.getColumnWidth(item.key));\n  let modality: string = useInteractionModality();\n  if (modality === 'virtual' &&  (typeof window !== 'undefined' && 'ontouchstart' in window)) {\n    modality = 'touch';\n  }\n  let description = triggerRef?.current == null && (modality === 'keyboard' || modality === 'virtual') && !isResizing ? stringFormatter.format('resizerDescription') : undefined;\n  let descriptionProps = useDescription(description);\n  let ariaProps = {\n    'aria-label': ariaLabel,\n    'aria-orientation': 'horizontal' as 'horizontal',\n    'aria-labelledby': `${id} ${getColumnHeaderId(state.tableState, item.key)}`,\n    'aria-valuetext': stringFormatter.format('columnSize', {value}),\n    'type': 'range',\n    min,\n    max,\n    value,\n    ...descriptionProps\n  };\n\n  const focusInput = useCallback(() => {\n    if (ref.current) {\n      focusSafely(ref.current);\n    }\n  }, [ref]);\n\n  let resizingColumn = state.resizingColumn;\n  let prevResizingColumn = useRef(null);\n  useEffect(() => {\n    if (prevResizingColumn.current !== resizingColumn && resizingColumn != null && resizingColumn === item.key) {\n      wasFocusedOnResizeStart.current = document.activeElement === ref.current;\n      startResize(item);\n      // Delay focusing input until Android Chrome's delayed click after touchend happens: https://bugs.chromium.org/p/chromium/issues/detail?id=1150073\n      let timeout = setTimeout(() => focusInput(), 0);\n      // VoiceOver on iOS has problems focusing the input from a menu.\n      let VOTimeout = setTimeout(focusInput, 400);\n      return () => {\n        clearTimeout(timeout);\n        clearTimeout(VOTimeout);\n      };\n    }\n    prevResizingColumn.current = resizingColumn;\n  }, [resizingColumn, item, focusInput, ref, startResize]);\n\n  let onChange = (e: ChangeEvent<HTMLInputElement>) => {\n    let currentWidth = state.getColumnWidth(item.key);\n    let nextValue = parseFloat(e.target.value);\n\n    if (nextValue > currentWidth) {\n      nextValue = currentWidth + 10;\n    } else {\n      nextValue = currentWidth - 10;\n    }\n    resize(item, nextValue);\n  };\n\n  let {pressProps} = usePress({\n    onPressStart: (e) => {\n      if (e.ctrlKey || e.altKey || e.metaKey || e.shiftKey || e.pointerType === 'keyboard') {\n        return;\n      }\n      if (e.pointerType === 'virtual' && state.resizingColumn != null) {\n        endResize(item);\n        return;\n      }\n\n      // Sometimes onPress won't trigger for quick taps on mobile so we want to focus the input so blurring away\n      // can cancel resize mode for us.\n      focusInput();\n\n      // If resizer is always visible, mobile screenreader user can access the visually hidden resizer directly and thus we don't need\n      // to handle a virtual click to start the resizer.\n      if (e.pointerType !== 'virtual') {\n        startResize(item);\n      }\n    },\n    onPress: (e) => {\n      if (((e.pointerType === 'touch' && wasFocusedOnResizeStart.current) || e.pointerType === 'mouse') && state.resizingColumn != null) {\n        endResize(item);\n      }\n    }\n  });\n  let {visuallyHiddenProps} = useVisuallyHidden();\n\n  return {\n    resizerProps: mergeProps(\n      keyboardProps,\n      {...moveProps, onKeyDown},\n      pressProps,\n      {style: {touchAction: 'none'}}\n    ),\n    inputProps: mergeProps(\n      visuallyHiddenProps,\n      {\n        id,\n        onBlur: () => {\n          endResize(item);\n        },\n        onChange,\n        disabled: isDisabled\n      },\n      ariaProps\n    ),\n    isResizing\n  };\n}\n"]},"metadata":{},"sourceType":"module"}