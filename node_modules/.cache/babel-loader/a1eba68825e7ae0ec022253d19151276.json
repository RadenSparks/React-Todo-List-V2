{"ast":null,"code":"import { getFormatOptions as $35a22f14a1f04b11$export$7e319ea407e63bc0, getPlaceholderTime as $35a22f14a1f04b11$export$c5221a78ef73c5e9, getRangeValidationResult as $35a22f14a1f04b11$export$80ff8fc0ae339c13, useDefaultProps as $35a22f14a1f04b11$export$2440da353cedad43 } from \"./utils.mjs\";\nimport { toCalendarDate as $hac8C$toCalendarDate, toCalendarDateTime as $hac8C$toCalendarDateTime, DateFormatter as $hac8C$DateFormatter } from \"@internationalized/date\";\nimport { useFormValidationState as $hac8C$useFormValidationState } from \"@react-stately/form\";\nimport { useOverlayTriggerState as $hac8C$useOverlayTriggerState } from \"@react-stately/overlays\";\nimport { useControlledState as $hac8C$useControlledState } from \"@react-stately/utils\";\nimport { useState as $hac8C$useState, useMemo as $hac8C$useMemo } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $93c38a5e28be6249$export$e50a61c1de9f574(props) {\n  var _value_start, _value_end;\n  let overlayState = (0, $hac8C$useOverlayTriggerState)(props);\n  let [controlledValue, setControlledValue] = (0, $hac8C$useControlledState)(props.value, props.defaultValue || null, props.onChange);\n  let [placeholderValue, setPlaceholderValue] = (0, $hac8C$useState)(() => controlledValue || {\n    start: null,\n    end: null\n  });\n  // Reset the placeholder if the value prop is set to null.\n  if (controlledValue == null && placeholderValue.start && placeholderValue.end) {\n    placeholderValue = {\n      start: null,\n      end: null\n    };\n    setPlaceholderValue(placeholderValue);\n  }\n  let value = controlledValue || placeholderValue;\n  let setValue = value => {\n    setPlaceholderValue(value || {\n      start: null,\n      end: null\n    });\n    if ((value === null || value === void 0 ? void 0 : value.start) && value.end) setControlledValue(value);else setControlledValue(null);\n  };\n  let v = (value === null || value === void 0 ? void 0 : value.start) || (value === null || value === void 0 ? void 0 : value.end) || props.placeholderValue;\n  let [granularity, defaultTimeZone] = (0, $35a22f14a1f04b11$export$2440da353cedad43)(v, props.granularity);\n  let hasTime = granularity === 'hour' || granularity === 'minute' || granularity === 'second';\n  var _props_shouldCloseOnSelect;\n  let shouldCloseOnSelect = (_props_shouldCloseOnSelect = props.shouldCloseOnSelect) !== null && _props_shouldCloseOnSelect !== void 0 ? _props_shouldCloseOnSelect : true;\n  let [dateRange, setSelectedDateRange] = (0, $hac8C$useState)(null);\n  let [timeRange, setSelectedTimeRange] = (0, $hac8C$useState)(null);\n  if (value && value.start && value.end) {\n    dateRange = value;\n    if ('hour' in value.start) timeRange = value;\n  }\n  let commitValue = (dateRange, timeRange) => {\n    setValue({\n      start: 'timeZone' in timeRange.start ? timeRange.start.set((0, $hac8C$toCalendarDate)(dateRange.start)) : (0, $hac8C$toCalendarDateTime)(dateRange.start, timeRange.start),\n      end: 'timeZone' in timeRange.end ? timeRange.end.set((0, $hac8C$toCalendarDate)(dateRange.end)) : (0, $hac8C$toCalendarDateTime)(dateRange.end, timeRange.end)\n    });\n    setSelectedDateRange(null);\n    setSelectedTimeRange(null);\n    validation.commitValidation();\n  };\n  // Intercept setValue to make sure the Time section is not changed by date selection in Calendar\n  let setDateRange = range => {\n    let shouldClose = typeof shouldCloseOnSelect === 'function' ? shouldCloseOnSelect() : shouldCloseOnSelect;\n    if (hasTime) {\n      if (shouldClose || range.start && range.end && (timeRange === null || timeRange === void 0 ? void 0 : timeRange.start) && (timeRange === null || timeRange === void 0 ? void 0 : timeRange.end)) commitValue(range, {\n        start: (timeRange === null || timeRange === void 0 ? void 0 : timeRange.start) || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue),\n        end: (timeRange === null || timeRange === void 0 ? void 0 : timeRange.end) || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue)\n      });else setSelectedDateRange(range);\n    } else if (range.start && range.end) {\n      setValue(range);\n      validation.commitValidation();\n    } else setSelectedDateRange(range);\n    if (shouldClose) overlayState.setOpen(false);\n  };\n  let setTimeRange = range => {\n    if ((dateRange === null || dateRange === void 0 ? void 0 : dateRange.start) && (dateRange === null || dateRange === void 0 ? void 0 : dateRange.end) && range.start && range.end) commitValue(dateRange, range);else setSelectedTimeRange(range);\n  };\n  let showEra = (value === null || value === void 0 ? void 0 : (_value_start = value.start) === null || _value_start === void 0 ? void 0 : _value_start.calendar.identifier) === 'gregory' && value.start.era === 'BC' || (value === null || value === void 0 ? void 0 : (_value_end = value.end) === null || _value_end === void 0 ? void 0 : _value_end.calendar.identifier) === 'gregory' && value.end.era === 'BC';\n  let formatOpts = (0, $hac8C$useMemo)(() => ({\n    granularity: granularity,\n    timeZone: defaultTimeZone,\n    hideTimeZone: props.hideTimeZone,\n    hourCycle: props.hourCycle,\n    shouldForceLeadingZeros: props.shouldForceLeadingZeros,\n    showEra: showEra\n  }), [granularity, props.hourCycle, props.shouldForceLeadingZeros, defaultTimeZone, props.hideTimeZone, showEra]);\n  let {\n    minValue: minValue,\n    maxValue: maxValue,\n    isDateUnavailable: isDateUnavailable\n  } = props;\n  let builtinValidation = (0, $hac8C$useMemo)(() => (0, $35a22f14a1f04b11$export$80ff8fc0ae339c13)(value, minValue, maxValue, isDateUnavailable, formatOpts), [value, minValue, maxValue, isDateUnavailable, formatOpts]);\n  let validation = (0, $hac8C$useFormValidationState)({\n    ...props,\n    value: controlledValue,\n    name: (0, $hac8C$useMemo)(() => [props.startName, props.endName], [props.startName, props.endName]),\n    builtinValidation: builtinValidation\n  });\n  let isValueInvalid = validation.displayValidation.isInvalid;\n  let validationState = props.validationState || (isValueInvalid ? 'invalid' : null);\n  return {\n    ...validation,\n    value: value,\n    setValue: setValue,\n    dateRange: dateRange,\n    timeRange: timeRange,\n    granularity: granularity,\n    hasTime: hasTime,\n    setDate(part, date) {\n      setDateRange({\n        ...dateRange,\n        [part]: date\n      });\n    },\n    setTime(part, time) {\n      setTimeRange({\n        ...timeRange,\n        [part]: time\n      });\n    },\n    setDateTime(part, dateTime) {\n      setValue({\n        ...value,\n        [part]: dateTime\n      });\n    },\n    setDateRange: setDateRange,\n    setTimeRange: setTimeRange,\n    ...overlayState,\n    setOpen(isOpen) {\n      // Commit the selected date range when the calendar is closed. Use a placeholder time if one wasn't set.\n      // If only the time range was set and not the date range, don't commit. The state will be preserved until\n      // the user opens the popover again.\n      if (!isOpen && !((value === null || value === void 0 ? void 0 : value.start) && (value === null || value === void 0 ? void 0 : value.end)) && (dateRange === null || dateRange === void 0 ? void 0 : dateRange.start) && (dateRange === null || dateRange === void 0 ? void 0 : dateRange.end) && hasTime) commitValue(dateRange, {\n        start: (timeRange === null || timeRange === void 0 ? void 0 : timeRange.start) || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue),\n        end: (timeRange === null || timeRange === void 0 ? void 0 : timeRange.end) || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue)\n      });\n      overlayState.setOpen(isOpen);\n    },\n    validationState: validationState,\n    isInvalid: isValueInvalid,\n    formatValue(locale, fieldOptions) {\n      if (!value || !value.start || !value.end) return null;\n      let startTimeZone = 'timeZone' in value.start ? value.start.timeZone : undefined;\n      let startGranularity = props.granularity || (value.start && 'minute' in value.start ? 'minute' : 'day');\n      let endTimeZone = 'timeZone' in value.end ? value.end.timeZone : undefined;\n      let endGranularity = props.granularity || (value.end && 'minute' in value.end ? 'minute' : 'day');\n      let startOptions = (0, $35a22f14a1f04b11$export$7e319ea407e63bc0)(fieldOptions, {\n        granularity: startGranularity,\n        timeZone: startTimeZone,\n        hideTimeZone: props.hideTimeZone,\n        hourCycle: props.hourCycle,\n        showEra: value.start.calendar.identifier === 'gregory' && value.start.era === 'BC' || value.end.calendar.identifier === 'gregory' && value.end.era === 'BC'\n      });\n      let startDate = value.start.toDate(startTimeZone || 'UTC');\n      let endDate = value.end.toDate(endTimeZone || 'UTC');\n      let startFormatter = new (0, $hac8C$DateFormatter)(locale, startOptions);\n      let endFormatter;\n      if (startTimeZone === endTimeZone && startGranularity === endGranularity && value.start.compare(value.end) !== 0) {\n        // Use formatRange, as it results in shorter output when some of the fields\n        // are shared between the start and end dates (e.g. the same month).\n        // Formatting will fail if the end date is before the start date. Fall back below when that happens.\n        try {\n          let parts = startFormatter.formatRangeToParts(startDate, endDate);\n          // Find the separator between the start and end date. This is determined\n          // by finding the last shared literal before the end range.\n          let separatorIndex = -1;\n          for (let i = 0; i < parts.length; i++) {\n            let part = parts[i];\n            if (part.source === 'shared' && part.type === 'literal') separatorIndex = i;else if (part.source === 'endRange') break;\n          }\n          // Now we can combine the parts into start and end strings.\n          let start = '';\n          let end = '';\n          for (let i = 0; i < parts.length; i++) {\n            if (i < separatorIndex) start += parts[i].value;else if (i > separatorIndex) end += parts[i].value;\n          }\n          return {\n            start: start,\n            end: end\n          };\n        } catch (e) {\n          // ignore\n        }\n        endFormatter = startFormatter;\n      } else {\n        let endOptions = (0, $35a22f14a1f04b11$export$7e319ea407e63bc0)(fieldOptions, {\n          granularity: endGranularity,\n          timeZone: endTimeZone,\n          hideTimeZone: props.hideTimeZone,\n          hourCycle: props.hourCycle\n        });\n        endFormatter = new (0, $hac8C$DateFormatter)(locale, endOptions);\n      }\n      return {\n        start: startFormatter.format(startDate),\n        end: endFormatter.format(endDate)\n      };\n    }\n  };\n}\nexport { $93c38a5e28be6249$export$e50a61c1de9f574 as useDateRangePickerState };","map":{"version":3,"mappings":"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","names":["$93c38a5e28be6249$export$e50a61c1de9f574","props","_value_start","_value_end","overlayState","controlledValue","setControlledValue","value","defaultValue","onChange","placeholderValue","setPlaceholderValue","start","end","setValue","v","granularity","defaultTimeZone","hasTime","_props_shouldCloseOnSelect","shouldCloseOnSelect","dateRange","setSelectedDateRange","timeRange","setSelectedTimeRange","commitValue","set","validation","commitValidation","setDateRange","range","shouldClose","setOpen","setTimeRange","showEra","calendar","identifier","era","formatOpts","timeZone","hideTimeZone","hourCycle","shouldForceLeadingZeros","minValue","maxValue","isDateUnavailable","builtinValidation","name","startName","endName","isValueInvalid","displayValidation","isInvalid","validationState","setDate","part","date","setTime","time","setDateTime","dateTime","isOpen","formatValue","locale","fieldOptions","startTimeZone","undefined","startGranularity","endTimeZone","endGranularity","startOptions","startDate","toDate","endDate","startFormatter","endFormatter","compare","parts","formatRangeToParts","separatorIndex","i","length","source","type","e","endOptions","format"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-stately\\datepicker\\dist\\packages\\@react-stately\\datepicker\\src\\useDateRangePickerState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DateFormatter, toCalendarDate, toCalendarDateTime} from '@internationalized/date';\nimport {DateRange, DateRangePickerProps, DateValue, Granularity, TimeValue} from '@react-types/datepicker';\nimport {FieldOptions, getFormatOptions, getPlaceholderTime, getRangeValidationResult, useDefaultProps} from './utils';\nimport {FormValidationState, useFormValidationState} from '@react-stately/form';\nimport {OverlayTriggerState, useOverlayTriggerState} from '@react-stately/overlays';\nimport {RangeValue, ValidationState} from '@react-types/shared';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo, useState} from 'react';\n\nexport interface DateRangePickerStateOptions<T extends DateValue = DateValue> extends DateRangePickerProps<T> {\n  /**\n   * Determines whether the date picker popover should close automatically when a date is selected.\n   * @default true\n   */\n  shouldCloseOnSelect?: boolean | (() => boolean)\n}\n\ntype TimeRange = RangeValue<TimeValue>;\nexport interface DateRangePickerState extends OverlayTriggerState, FormValidationState {\n  /** The currently selected date range. */\n  value: DateRange | null,\n  /** Sets the selected date range. */\n  setValue(value: DateRange | null): void,\n  /**\n   * The date portion of the selected range. This may be set prior to `value` if the user has\n   * selected a date range but has not yet selected a time range.\n   */\n  dateRange: DateRange | null,\n  /** Sets the date portion of the selected range. */\n  setDateRange(value: DateRange): void,\n  /**\n   * The time portion of the selected range. This may be set prior to `value` if the user has\n   * selected a time range but has not yet selected a date range.\n   */\n  timeRange: TimeRange | null,\n  /** Sets the time portion of the selected range. */\n  setTimeRange(value: TimeRange): void,\n  /** Sets the date portion of either the start or end of the selected range. */\n  setDate(part: 'start' | 'end', value: DateValue): void,\n  /** Sets the time portion of either the start or end of the selected range. */\n  setTime(part: 'start' | 'end', value: TimeValue): void,\n  /** Sets the date and time of either the start or end of the selected range. */\n  setDateTime(part: 'start' | 'end', value: DateValue): void,\n  /** The granularity for the field, based on the `granularity` prop and current value. */\n  granularity: Granularity,\n  /** Whether the date range picker supports selecting times, according to the `granularity` prop and current value. */\n  hasTime: boolean,\n  /** Whether the calendar popover is currently open. */\n  isOpen: boolean,\n  /** Sets whether the calendar popover is open. */\n  setOpen(isOpen: boolean): void,\n  /**\n   * The current validation state of the date range picker, based on the `validationState`, `minValue`, and `maxValue` props.\n   * @deprecated Use `isInvalid` instead.\n   */\n  validationState: ValidationState,\n  /** Whether the date range picker is invalid, based on the `isInvalid`, `minValue`, and `maxValue` props. */\n  isInvalid: boolean,\n  /** Formats the selected range using the given options. */\n  formatValue(locale: string, fieldOptions: FieldOptions): {start: string, end: string}\n}\n\n/**\n * Provides state management for a date range picker component.\n * A date range picker combines two DateFields and a RangeCalendar popover to allow\n * users to enter or select a date and time range.\n */\nexport function useDateRangePickerState<T extends DateValue = DateValue>(props: DateRangePickerStateOptions<T>): DateRangePickerState {\n  let overlayState = useOverlayTriggerState(props);\n  let [controlledValue, setControlledValue] = useControlledState<DateRange>(props.value, props.defaultValue || null, props.onChange);\n  let [placeholderValue, setPlaceholderValue] = useState(() => controlledValue || {start: null, end: null});\n\n  // Reset the placeholder if the value prop is set to null.\n  if (controlledValue == null && placeholderValue.start && placeholderValue.end) {\n    placeholderValue = {start: null, end: null};\n    setPlaceholderValue(placeholderValue);\n  }\n\n  let value = controlledValue || placeholderValue;\n\n  let setValue = (value: DateRange) => {\n    setPlaceholderValue(value || {start: null, end: null});\n    if (value?.start && value.end) {\n      setControlledValue(value);\n    } else {\n      setControlledValue(null);\n    }\n  };\n\n  let v = (value?.start || value?.end || props.placeholderValue);\n  let [granularity, defaultTimeZone] = useDefaultProps(v, props.granularity);\n  let hasTime = granularity === 'hour' || granularity === 'minute' || granularity === 'second';\n  let shouldCloseOnSelect = props.shouldCloseOnSelect ?? true;\n\n  let [dateRange, setSelectedDateRange] = useState<DateRange>(null);\n  let [timeRange, setSelectedTimeRange] = useState<TimeRange>(null);\n\n  if (value && value.start && value.end) {\n    dateRange = value;\n    if ('hour' in value.start) {\n      timeRange = value as TimeRange;\n    }\n  }\n\n  let commitValue = (dateRange: DateRange, timeRange: TimeRange) => {\n    setValue({\n      start: 'timeZone' in timeRange.start ? timeRange.start.set(toCalendarDate(dateRange.start)) : toCalendarDateTime(dateRange.start, timeRange.start),\n      end: 'timeZone' in timeRange.end ? timeRange.end.set(toCalendarDate(dateRange.end)) : toCalendarDateTime(dateRange.end, timeRange.end)\n    });\n    setSelectedDateRange(null);\n    setSelectedTimeRange(null);\n    validation.commitValidation();\n  };\n\n  // Intercept setValue to make sure the Time section is not changed by date selection in Calendar\n  let setDateRange = (range: DateRange) => {\n    let shouldClose = typeof shouldCloseOnSelect === 'function' ? shouldCloseOnSelect() : shouldCloseOnSelect;\n    if (hasTime) {\n      if (shouldClose || (range.start && range.end && timeRange?.start && timeRange?.end)) {\n        commitValue(range, {\n          start: timeRange?.start || getPlaceholderTime(props.placeholderValue),\n          end: timeRange?.end || getPlaceholderTime(props.placeholderValue)\n        });\n      } else {\n        setSelectedDateRange(range);\n      }\n    } else if (range.start && range.end) {\n      setValue(range);\n      validation.commitValidation();\n    } else {\n      setSelectedDateRange(range);\n    }\n\n    if (shouldClose) {\n      overlayState.setOpen(false);\n    }\n  };\n\n  let setTimeRange = (range: TimeRange) => {\n    if (dateRange?.start && dateRange?.end && range.start && range.end) {\n      commitValue(dateRange, range);\n    } else {\n      setSelectedTimeRange(range);\n    }\n  };\n\n  let showEra = (value?.start?.calendar.identifier === 'gregory' && value.start.era === 'BC') || (value?.end?.calendar.identifier === 'gregory' && value.end.era === 'BC');\n  let formatOpts = useMemo(() => ({\n    granularity,\n    timeZone: defaultTimeZone,\n    hideTimeZone: props.hideTimeZone,\n    hourCycle: props.hourCycle,\n    shouldForceLeadingZeros: props.shouldForceLeadingZeros,\n    showEra\n  }), [granularity, props.hourCycle, props.shouldForceLeadingZeros, defaultTimeZone, props.hideTimeZone, showEra]);\n\n  let {minValue, maxValue, isDateUnavailable} = props;\n  let builtinValidation = useMemo(() => getRangeValidationResult(\n    value,\n    minValue,\n    maxValue,\n    isDateUnavailable,\n    formatOpts\n  ), [value, minValue, maxValue, isDateUnavailable, formatOpts]);\n\n  let validation = useFormValidationState({\n    ...props,\n    value: controlledValue,\n    name: useMemo(() => [props.startName, props.endName], [props.startName, props.endName]),\n    builtinValidation\n  });\n\n  let isValueInvalid = validation.displayValidation.isInvalid;\n  let validationState: ValidationState = props.validationState || (isValueInvalid ? 'invalid' : null);\n\n  return {\n    ...validation,\n    value,\n    setValue,\n    dateRange,\n    timeRange,\n    granularity,\n    hasTime,\n    setDate(part, date) {\n      setDateRange({...dateRange, [part]: date});\n    },\n    setTime(part, time) {\n      setTimeRange({...timeRange, [part]: time});\n    },\n    setDateTime(part, dateTime) {\n      setValue({...value, [part]: dateTime});\n    },\n    setDateRange,\n    setTimeRange,\n    ...overlayState,\n    setOpen(isOpen) {\n      // Commit the selected date range when the calendar is closed. Use a placeholder time if one wasn't set.\n      // If only the time range was set and not the date range, don't commit. The state will be preserved until\n      // the user opens the popover again.\n      if (!isOpen && !(value?.start && value?.end) && dateRange?.start && dateRange?.end && hasTime) {\n        commitValue(dateRange, {\n          start: timeRange?.start || getPlaceholderTime(props.placeholderValue),\n          end: timeRange?.end || getPlaceholderTime(props.placeholderValue)\n        });\n      }\n\n      overlayState.setOpen(isOpen);\n    },\n    validationState,\n    isInvalid: isValueInvalid,\n    formatValue(locale, fieldOptions) {\n      if (!value || !value.start || !value.end) {\n        return null;\n      }\n\n      let startTimeZone = 'timeZone' in value.start ? value.start.timeZone : undefined;\n      let startGranularity = props.granularity || (value.start && 'minute' in value.start ? 'minute' : 'day');\n      let endTimeZone = 'timeZone' in value.end ? value.end.timeZone : undefined;\n      let endGranularity = props.granularity || (value.end && 'minute' in value.end ? 'minute' : 'day');\n\n      let startOptions = getFormatOptions(fieldOptions, {\n        granularity: startGranularity,\n        timeZone: startTimeZone,\n        hideTimeZone: props.hideTimeZone,\n        hourCycle: props.hourCycle,\n        showEra: (value.start.calendar.identifier === 'gregory' && value.start.era === 'BC') ||\n          (value.end.calendar.identifier === 'gregory' && value.end.era === 'BC')\n      });\n\n      let startDate = value.start.toDate(startTimeZone || 'UTC');\n      let endDate = value.end.toDate(endTimeZone || 'UTC');\n\n      let startFormatter = new DateFormatter(locale, startOptions);\n      let endFormatter: Intl.DateTimeFormat;\n      if (startTimeZone === endTimeZone && startGranularity === endGranularity && value.start.compare(value.end) !== 0) {\n        // Use formatRange, as it results in shorter output when some of the fields\n        // are shared between the start and end dates (e.g. the same month).\n        // Formatting will fail if the end date is before the start date. Fall back below when that happens.\n        try {\n          let parts = startFormatter.formatRangeToParts(startDate, endDate);\n\n          // Find the separator between the start and end date. This is determined\n          // by finding the last shared literal before the end range.\n          let separatorIndex = -1;\n          for (let i = 0; i < parts.length; i++) {\n            let part = parts[i];\n            if (part.source === 'shared' && part.type === 'literal') {\n              separatorIndex = i;\n            } else if (part.source === 'endRange') {\n              break;\n            }\n          }\n\n          // Now we can combine the parts into start and end strings.\n          let start = '';\n          let end = '';\n          for (let i = 0; i < parts.length; i++) {\n            if (i < separatorIndex) {\n              start += parts[i].value;\n            } else if (i > separatorIndex) {\n              end += parts[i].value;\n            }\n          }\n\n          return {start, end};\n        } catch (e) {\n          // ignore\n        }\n\n        endFormatter = startFormatter;\n      } else {\n        let endOptions = getFormatOptions(fieldOptions, {\n          granularity: endGranularity,\n          timeZone: endTimeZone,\n          hideTimeZone: props.hideTimeZone,\n          hourCycle: props.hourCycle\n        });\n\n        endFormatter = new DateFormatter(locale, endOptions);\n      }\n\n      return {\n        start: startFormatter.format(startDate),\n        end: endFormatter.format(endDate)\n      };\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}