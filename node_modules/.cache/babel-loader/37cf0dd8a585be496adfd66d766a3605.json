{"ast":null,"code":"import { getSliderThumbId as $aa519ee6cf463259$export$68e648cbec363a18, sliderData as $aa519ee6cf463259$export$d6c8d9636a3dc49c } from \"./utils.mjs\";\nimport { useGlobalListeners as $468t2$useGlobalListeners, clamp as $468t2$clamp, mergeProps as $468t2$mergeProps } from \"@react-aria/utils\";\nimport { useRef as $468t2$useRef } from \"react\";\nimport { useMove as $468t2$useMove, setInteractionModality as $468t2$setInteractionModality } from \"@react-aria/interactions\";\nimport { useLabel as $468t2$useLabel } from \"@react-aria/label\";\nimport { useLocale as $468t2$useLocale } from \"@react-aria/i18n\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $bcca50147b47f54d$export$56b2c08e277f365(props, state, trackRef) {\n  let {\n    labelProps: labelProps,\n    fieldProps: fieldProps\n  } = (0, $468t2$useLabel)(props);\n  let isVertical = props.orientation === 'vertical';\n  var _labelProps_id;\n  // Attach id of the label to the state so it can be accessed by useSliderThumb.\n  (0, $aa519ee6cf463259$export$d6c8d9636a3dc49c).set(state, {\n    id: (_labelProps_id = labelProps.id) !== null && _labelProps_id !== void 0 ? _labelProps_id : fieldProps.id,\n    'aria-describedby': props['aria-describedby'],\n    'aria-details': props['aria-details']\n  });\n  let {\n    direction: direction\n  } = (0, $468t2$useLocale)();\n  let {\n    addGlobalListener: addGlobalListener,\n    removeGlobalListener: removeGlobalListener\n  } = (0, $468t2$useGlobalListeners)();\n  // When the user clicks or drags the track, we want the motion to set and drag the\n  // closest thumb.  Hence we also need to install useMove() on the track element.\n  // Here, we keep track of which index is the \"closest\" to the drag start point.\n  // It is set onMouseDown/onTouchDown; see trackProps below.\n  const realTimeTrackDraggingIndex = (0, $468t2$useRef)(null);\n  const reverseX = direction === 'rtl';\n  const currentPosition = (0, $468t2$useRef)(null);\n  const {\n    moveProps: moveProps\n  } = (0, $468t2$useMove)({\n    onMoveStart() {\n      currentPosition.current = null;\n    },\n    onMove(_ref) {\n      let {\n        deltaX: deltaX,\n        deltaY: deltaY\n      } = _ref;\n      let {\n        height: height,\n        width: width\n      } = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n      if (currentPosition.current == null) currentPosition.current = state.getThumbPercent(realTimeTrackDraggingIndex.current) * size;\n      let delta = isVertical ? deltaY : deltaX;\n      if (isVertical || reverseX) delta = -delta;\n      currentPosition.current += delta;\n      if (realTimeTrackDraggingIndex.current != null && trackRef.current) {\n        const percent = (0, $468t2$clamp)(currentPosition.current / size, 0, 1);\n        state.setThumbPercent(realTimeTrackDraggingIndex.current, percent);\n      }\n    },\n    onMoveEnd() {\n      if (realTimeTrackDraggingIndex.current != null) {\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n  });\n  let currentPointer = (0, $468t2$useRef)(undefined);\n  let onDownTrack = (e, id, clientX, clientY) => {\n    // We only trigger track-dragging if the user clicks on the track itself and nothing is currently being dragged.\n    if (trackRef.current && !props.isDisabled && state.values.every((_, i) => !state.isThumbDragging(i))) {\n      let {\n        height: height,\n        width: width,\n        top: top,\n        left: left\n      } = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n      // Find the closest thumb\n      const trackPosition = isVertical ? top : left;\n      const clickPosition = isVertical ? clientY : clientX;\n      const offset = clickPosition - trackPosition;\n      let percent = offset / size;\n      if (direction === 'rtl' || isVertical) percent = 1 - percent;\n      let value = state.getPercentValue(percent);\n      // to find the closet thumb we split the array based on the first thumb position to the \"right/end\" of the click.\n      let closestThumb;\n      let split = state.values.findIndex(v => value - v < 0);\n      if (split === 0) closestThumb = split;else if (split === -1) closestThumb = state.values.length - 1;else {\n        let lastLeft = state.values[split - 1];\n        let firstRight = state.values[split];\n        // Pick the last left/start thumb, unless they are stacked on top of each other, then pick the right/end one\n        if (Math.abs(lastLeft - value) < Math.abs(firstRight - value)) closestThumb = split - 1;else closestThumb = split;\n      }\n      // Confirm that the found closest thumb is editable, not disabled, and move it\n      if (closestThumb >= 0 && state.isThumbEditable(closestThumb)) {\n        // Don't unfocus anything\n        e.preventDefault();\n        realTimeTrackDraggingIndex.current = closestThumb;\n        state.setFocusedThumb(closestThumb);\n        currentPointer.current = id;\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, true);\n        state.setThumbValue(closestThumb, value);\n        addGlobalListener(window, 'mouseup', onUpTrack, false);\n        addGlobalListener(window, 'touchend', onUpTrack, false);\n        addGlobalListener(window, 'pointerup', onUpTrack, false);\n      } else realTimeTrackDraggingIndex.current = null;\n    }\n  };\n  let onUpTrack = e => {\n    var _e_changedTouches;\n    var _e_pointerId;\n    let id = (_e_pointerId = e.pointerId) !== null && _e_pointerId !== void 0 ? _e_pointerId : (_e_changedTouches = e.changedTouches) === null || _e_changedTouches === void 0 ? void 0 : _e_changedTouches[0].identifier;\n    if (id === currentPointer.current) {\n      if (realTimeTrackDraggingIndex.current != null) {\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n      removeGlobalListener(window, 'mouseup', onUpTrack, false);\n      removeGlobalListener(window, 'touchend', onUpTrack, false);\n      removeGlobalListener(window, 'pointerup', onUpTrack, false);\n    }\n  };\n  if ('htmlFor' in labelProps && labelProps.htmlFor) {\n    // Ideally the `for` attribute should point to the first thumb, but VoiceOver on iOS\n    // causes this to override the `aria-labelledby` on the thumb. This causes the first\n    // thumb to only be announced as the slider label rather than its individual name as well.\n    // See https://bugs.webkit.org/show_bug.cgi?id=172464.\n    delete labelProps.htmlFor;\n    labelProps.onClick = () => {\n      var\n      // Safari does not focus <input type=\"range\"> elements when clicking on an associated <label>,\n      // so do it manually. In addition, make sure we show the focus ring.\n      _document_getElementById;\n      (_document_getElementById = document.getElementById((0, $aa519ee6cf463259$export$68e648cbec363a18)(state, 0))) === null || _document_getElementById === void 0 ? void 0 : _document_getElementById.focus();\n      (0, $468t2$setInteractionModality)('keyboard');\n    };\n  }\n  return {\n    labelProps: labelProps,\n    // The root element of the Slider will have role=\"group\" to group together\n    // all the thumb inputs in the Slider.  The label of the Slider will\n    // be used to label the group.\n    groupProps: {\n      role: 'group',\n      ...fieldProps\n    },\n    trackProps: (0, $468t2$mergeProps)({\n      onMouseDown(e) {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;\n        onDownTrack(e, undefined, e.clientX, e.clientY);\n      },\n      onPointerDown(e) {\n        if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) return;\n        onDownTrack(e, e.pointerId, e.clientX, e.clientY);\n      },\n      onTouchStart(e) {\n        onDownTrack(e, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY);\n      },\n      style: {\n        position: 'relative',\n        touchAction: 'none'\n      }\n    }, moveProps),\n    outputProps: {\n      htmlFor: state.values.map((_, index) => (0, $aa519ee6cf463259$export$68e648cbec363a18)(state, index)).join(' '),\n      'aria-live': 'off'\n    }\n  };\n}\nexport { $bcca50147b47f54d$export$56b2c08e277f365 as useSlider };","map":{"version":3,"mappings":"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","names":["$bcca50147b47f54d$export$56b2c08e277f365","props","state","trackRef","labelProps","fieldProps","isVertical","orientation","_labelProps_id","set","id","direction","addGlobalListener","removeGlobalListener","realTimeTrackDraggingIndex","reverseX","currentPosition","moveProps","onMoveStart","current","onMove","deltaX","deltaY","height","width","getBoundingClientRect","size","getThumbPercent","delta","percent","setThumbPercent","onMoveEnd","setThumbDragging","currentPointer","undefined","onDownTrack","e","clientX","clientY","isDisabled","values","every","_","i","isThumbDragging","top","left","trackPosition","clickPosition","offset","value","getPercentValue","closestThumb","split","findIndex","v","length","lastLeft","firstRight","Math","abs","isThumbEditable","preventDefault","setFocusedThumb","setThumbValue","window","onUpTrack","_e_changedTouches","_e_pointerId","pointerId","changedTouches","identifier","htmlFor","onClick","_document_getElementById","getElementById","focus","groupProps","role","trackProps","onMouseDown","button","altKey","ctrlKey","metaKey","onPointerDown","pointerType","onTouchStart","style","position","touchAction","outputProps","map","index","join"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-aria\\slider\\dist\\packages\\@react-aria\\slider\\src\\useSlider.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaSliderProps} from '@react-types/slider';\nimport {clamp, mergeProps, useGlobalListeners} from '@react-aria/utils';\nimport {DOMAttributes} from '@react-types/shared';\nimport {getSliderThumbId, sliderData} from './utils';\nimport React, {LabelHTMLAttributes, OutputHTMLAttributes, RefObject, useRef} from 'react';\nimport {setInteractionModality, useMove} from '@react-aria/interactions';\nimport {SliderState} from '@react-stately/slider';\nimport {useLabel} from '@react-aria/label';\nimport {useLocale} from '@react-aria/i18n';\n\nexport interface SliderAria {\n  /** Props for the label element. */\n  labelProps: LabelHTMLAttributes<HTMLLabelElement>,\n\n  /** Props for the root element of the slider component; groups slider inputs. */\n  groupProps: DOMAttributes,\n\n  /** Props for the track element. */\n  trackProps: DOMAttributes,\n\n  /** Props for the output element, displaying the value of the slider thumbs. */\n  outputProps: OutputHTMLAttributes<HTMLOutputElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a slider component representing one or more values.\n *\n * @param props Props for the slider.\n * @param state State for the slider, as returned by `useSliderState`.\n * @param trackRef Ref for the \"track\" element.  The width of this element provides the \"length\"\n * of the track -- the span of one dimensional space that the slider thumb can be.  It also\n * accepts click and drag motions, so that the closest thumb will follow clicks and drags on\n * the track.\n */\nexport function useSlider<T extends number | number[]>(\n  props: AriaSliderProps<T>,\n  state: SliderState,\n  trackRef: RefObject<Element>\n): SliderAria {\n  let {labelProps, fieldProps} = useLabel(props);\n\n  let isVertical = props.orientation === 'vertical';\n\n  // Attach id of the label to the state so it can be accessed by useSliderThumb.\n  sliderData.set(state, {\n    id: labelProps.id ?? fieldProps.id,\n    'aria-describedby': props['aria-describedby'],\n    'aria-details': props['aria-details']\n  });\n\n  let {direction} = useLocale();\n\n  let {addGlobalListener, removeGlobalListener} = useGlobalListeners();\n\n  // When the user clicks or drags the track, we want the motion to set and drag the\n  // closest thumb.  Hence we also need to install useMove() on the track element.\n  // Here, we keep track of which index is the \"closest\" to the drag start point.\n  // It is set onMouseDown/onTouchDown; see trackProps below.\n  const realTimeTrackDraggingIndex = useRef<number | null>(null);\n\n  const reverseX = direction === 'rtl';\n  const currentPosition = useRef<number>(null);\n  const {moveProps} = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n    },\n    onMove({deltaX, deltaY}) {\n      let {height, width} = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n\n      if (currentPosition.current == null) {\n        currentPosition.current = state.getThumbPercent(realTimeTrackDraggingIndex.current) * size;\n      }\n\n      let delta = isVertical ? deltaY : deltaX;\n      if (isVertical || reverseX) {\n        delta = -delta;\n      }\n\n      currentPosition.current += delta;\n\n      if (realTimeTrackDraggingIndex.current != null && trackRef.current) {\n        const percent = clamp(currentPosition.current / size, 0, 1);\n        state.setThumbPercent(realTimeTrackDraggingIndex.current, percent);\n      }\n    },\n    onMoveEnd() {\n      if (realTimeTrackDraggingIndex.current != null) {\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n  });\n\n  let currentPointer = useRef<number | null | undefined>(undefined);\n  let onDownTrack = (e: React.UIEvent, id: number, clientX: number, clientY: number) => {\n    // We only trigger track-dragging if the user clicks on the track itself and nothing is currently being dragged.\n    if (trackRef.current && !props.isDisabled && state.values.every((_, i) => !state.isThumbDragging(i))) {\n      let {height, width, top, left} = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n      // Find the closest thumb\n      const trackPosition = isVertical ? top : left;\n      const clickPosition = isVertical ? clientY : clientX;\n      const offset = clickPosition - trackPosition;\n      let percent = offset / size;\n      if (direction === 'rtl' || isVertical) {\n        percent = 1 - percent;\n      }\n      let value = state.getPercentValue(percent);\n\n      // to find the closet thumb we split the array based on the first thumb position to the \"right/end\" of the click.\n      let closestThumb;\n      let split = state.values.findIndex(v => value - v < 0);\n      if (split === 0) { // If the index is zero then the closetThumb is the first one\n        closestThumb = split;\n      } else if (split === -1) { // If no index is found they've clicked past all the thumbs\n        closestThumb = state.values.length - 1;\n      } else {\n        let lastLeft = state.values[split - 1];\n        let firstRight = state.values[split];\n        // Pick the last left/start thumb, unless they are stacked on top of each other, then pick the right/end one\n        if (Math.abs(lastLeft - value) < Math.abs(firstRight - value)) {\n          closestThumb = split - 1;\n        } else {\n          closestThumb = split;\n        }\n      }\n\n      // Confirm that the found closest thumb is editable, not disabled, and move it\n      if (closestThumb >= 0 && state.isThumbEditable(closestThumb)) {\n        // Don't unfocus anything\n        e.preventDefault();\n\n        realTimeTrackDraggingIndex.current = closestThumb;\n        state.setFocusedThumb(closestThumb);\n        currentPointer.current = id;\n\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, true);\n        state.setThumbValue(closestThumb, value);\n\n        addGlobalListener(window, 'mouseup', onUpTrack, false);\n        addGlobalListener(window, 'touchend', onUpTrack, false);\n        addGlobalListener(window, 'pointerup', onUpTrack, false);\n      } else {\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n  };\n\n  let onUpTrack = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (id === currentPointer.current) {\n      if (realTimeTrackDraggingIndex.current != null) {\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n\n      removeGlobalListener(window, 'mouseup', onUpTrack, false);\n      removeGlobalListener(window, 'touchend', onUpTrack, false);\n      removeGlobalListener(window, 'pointerup', onUpTrack, false);\n    }\n  };\n\n  if ('htmlFor' in labelProps && labelProps.htmlFor) {\n    // Ideally the `for` attribute should point to the first thumb, but VoiceOver on iOS\n    // causes this to override the `aria-labelledby` on the thumb. This causes the first\n    // thumb to only be announced as the slider label rather than its individual name as well.\n    // See https://bugs.webkit.org/show_bug.cgi?id=172464.\n    delete labelProps.htmlFor;\n    labelProps.onClick = () => {\n      // Safari does not focus <input type=\"range\"> elements when clicking on an associated <label>,\n      // so do it manually. In addition, make sure we show the focus ring.\n      document.getElementById(getSliderThumbId(state, 0))?.focus();\n      setInteractionModality('keyboard');\n    };\n  }\n\n  return {\n    labelProps,\n    // The root element of the Slider will have role=\"group\" to group together\n    // all the thumb inputs in the Slider.  The label of the Slider will\n    // be used to label the group.\n    groupProps: {\n      role: 'group',\n      ...fieldProps\n    },\n    trackProps: mergeProps({\n      onMouseDown(e: React.MouseEvent) {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n        onDownTrack(e, undefined, e.clientX, e.clientY);\n      },\n      onPointerDown(e: React.PointerEvent) {\n        if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) {\n          return;\n        }\n        onDownTrack(e, e.pointerId, e.clientX, e.clientY);\n      },\n      onTouchStart(e: React.TouchEvent) { onDownTrack(e, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY); },\n      style: {\n        position: 'relative',\n        touchAction: 'none'\n      }\n    }, moveProps),\n    outputProps: {\n      htmlFor: state.values.map((_, index) => getSliderThumbId(state, index)).join(' '),\n      'aria-live': 'off'\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}