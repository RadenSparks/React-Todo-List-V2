{"ast":null,"code":"import { epochFromDate as $11d87f3f76e88657$export$bd4fb2bc8bb06fb, fromAbsolute as $11d87f3f76e88657$export$1b96692a1ba042ac, toAbsolute as $11d87f3f76e88657$export$5107c82f94518f5c, toCalendar as $11d87f3f76e88657$export$b4a036af3fc0b032, toCalendarDateTime as $11d87f3f76e88657$export$b21e0b124e224484 } from \"./conversion.mjs\";\nimport { GregorianCalendar as $3b62074eb05584b2$export$80ee6245ec4f29ec } from \"./GregorianCalendar.mjs\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $735220c2d4774dd3$var$ONE_HOUR = 3600000;\nfunction $735220c2d4774dd3$export$e16d8520af44a096(date, duration) {\n  let mutableDate = date.copy();\n  let days = 'hour' in mutableDate ? $735220c2d4774dd3$var$addTimeFields(mutableDate, duration) : 0;\n  $735220c2d4774dd3$var$addYears(mutableDate, duration.years || 0);\n  if (mutableDate.calendar.balanceYearMonth) mutableDate.calendar.balanceYearMonth(mutableDate, date);\n  mutableDate.month += duration.months || 0;\n  $735220c2d4774dd3$var$balanceYearMonth(mutableDate);\n  $735220c2d4774dd3$var$constrainMonthDay(mutableDate);\n  mutableDate.day += (duration.weeks || 0) * 7;\n  mutableDate.day += duration.days || 0;\n  mutableDate.day += days;\n  $735220c2d4774dd3$var$balanceDay(mutableDate);\n  if (mutableDate.calendar.balanceDate) mutableDate.calendar.balanceDate(mutableDate);\n  // Constrain in case adding ended up with a date outside the valid range for the calendar system.\n  // The behavior here is slightly different than when constraining in the `set` function in that\n  // we adjust smaller fields to their minimum/maximum values rather than constraining each field\n  // individually. This matches the general behavior of `add` vs `set` regarding how fields are balanced.\n  if (mutableDate.year < 1) {\n    mutableDate.year = 1;\n    mutableDate.month = 1;\n    mutableDate.day = 1;\n  }\n  let maxYear = mutableDate.calendar.getYearsInEra(mutableDate);\n  if (mutableDate.year > maxYear) {\n    var _mutableDate_calendar_isInverseEra, _mutableDate_calendar;\n    let isInverseEra = (_mutableDate_calendar_isInverseEra = (_mutableDate_calendar = mutableDate.calendar).isInverseEra) === null || _mutableDate_calendar_isInverseEra === void 0 ? void 0 : _mutableDate_calendar_isInverseEra.call(_mutableDate_calendar, mutableDate);\n    mutableDate.year = maxYear;\n    mutableDate.month = isInverseEra ? 1 : mutableDate.calendar.getMonthsInYear(mutableDate);\n    mutableDate.day = isInverseEra ? 1 : mutableDate.calendar.getDaysInMonth(mutableDate);\n  }\n  if (mutableDate.month < 1) {\n    mutableDate.month = 1;\n    mutableDate.day = 1;\n  }\n  let maxMonth = mutableDate.calendar.getMonthsInYear(mutableDate);\n  if (mutableDate.month > maxMonth) {\n    mutableDate.month = maxMonth;\n    mutableDate.day = mutableDate.calendar.getDaysInMonth(mutableDate);\n  }\n  mutableDate.day = Math.max(1, Math.min(mutableDate.calendar.getDaysInMonth(mutableDate), mutableDate.day));\n  return mutableDate;\n}\nfunction $735220c2d4774dd3$var$addYears(date, years) {\n  var _date_calendar_isInverseEra, _date_calendar;\n  if ((_date_calendar_isInverseEra = (_date_calendar = date.calendar).isInverseEra) === null || _date_calendar_isInverseEra === void 0 ? void 0 : _date_calendar_isInverseEra.call(_date_calendar, date)) years = -years;\n  date.year += years;\n}\nfunction $735220c2d4774dd3$var$balanceYearMonth(date) {\n  while (date.month < 1) {\n    $735220c2d4774dd3$var$addYears(date, -1);\n    date.month += date.calendar.getMonthsInYear(date);\n  }\n  let monthsInYear = 0;\n  while (date.month > (monthsInYear = date.calendar.getMonthsInYear(date))) {\n    date.month -= monthsInYear;\n    $735220c2d4774dd3$var$addYears(date, 1);\n  }\n}\nfunction $735220c2d4774dd3$var$balanceDay(date) {\n  while (date.day < 1) {\n    date.month--;\n    $735220c2d4774dd3$var$balanceYearMonth(date);\n    date.day += date.calendar.getDaysInMonth(date);\n  }\n  while (date.day > date.calendar.getDaysInMonth(date)) {\n    date.day -= date.calendar.getDaysInMonth(date);\n    date.month++;\n    $735220c2d4774dd3$var$balanceYearMonth(date);\n  }\n}\nfunction $735220c2d4774dd3$var$constrainMonthDay(date) {\n  date.month = Math.max(1, Math.min(date.calendar.getMonthsInYear(date), date.month));\n  date.day = Math.max(1, Math.min(date.calendar.getDaysInMonth(date), date.day));\n}\nfunction $735220c2d4774dd3$export$c4e2ecac49351ef2(date) {\n  if (date.calendar.constrainDate) date.calendar.constrainDate(date);\n  date.year = Math.max(1, Math.min(date.calendar.getYearsInEra(date), date.year));\n  $735220c2d4774dd3$var$constrainMonthDay(date);\n}\nfunction $735220c2d4774dd3$export$3e2544e88a25bff8(duration) {\n  let inverseDuration = {};\n  for (let key in duration) if (typeof duration[key] === 'number') inverseDuration[key] = -duration[key];\n  return inverseDuration;\n}\nfunction $735220c2d4774dd3$export$4e2d2ead65e5f7e3(date, duration) {\n  return $735220c2d4774dd3$export$e16d8520af44a096(date, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));\n}\nfunction $735220c2d4774dd3$export$adaa4cf7ef1b65be(date, fields) {\n  let mutableDate = date.copy();\n  if (fields.era != null) mutableDate.era = fields.era;\n  if (fields.year != null) mutableDate.year = fields.year;\n  if (fields.month != null) mutableDate.month = fields.month;\n  if (fields.day != null) mutableDate.day = fields.day;\n  $735220c2d4774dd3$export$c4e2ecac49351ef2(mutableDate);\n  return mutableDate;\n}\nfunction $735220c2d4774dd3$export$e5d5e1c1822b6e56(value, fields) {\n  let mutableValue = value.copy();\n  if (fields.hour != null) mutableValue.hour = fields.hour;\n  if (fields.minute != null) mutableValue.minute = fields.minute;\n  if (fields.second != null) mutableValue.second = fields.second;\n  if (fields.millisecond != null) mutableValue.millisecond = fields.millisecond;\n  $735220c2d4774dd3$export$7555de1e070510cb(mutableValue);\n  return mutableValue;\n}\nfunction $735220c2d4774dd3$var$balanceTime(time) {\n  time.second += Math.floor(time.millisecond / 1000);\n  time.millisecond = $735220c2d4774dd3$var$nonNegativeMod(time.millisecond, 1000);\n  time.minute += Math.floor(time.second / 60);\n  time.second = $735220c2d4774dd3$var$nonNegativeMod(time.second, 60);\n  time.hour += Math.floor(time.minute / 60);\n  time.minute = $735220c2d4774dd3$var$nonNegativeMod(time.minute, 60);\n  let days = Math.floor(time.hour / 24);\n  time.hour = $735220c2d4774dd3$var$nonNegativeMod(time.hour, 24);\n  return days;\n}\nfunction $735220c2d4774dd3$export$7555de1e070510cb(time) {\n  time.millisecond = Math.max(0, Math.min(time.millisecond, 1000));\n  time.second = Math.max(0, Math.min(time.second, 59));\n  time.minute = Math.max(0, Math.min(time.minute, 59));\n  time.hour = Math.max(0, Math.min(time.hour, 23));\n}\nfunction $735220c2d4774dd3$var$nonNegativeMod(a, b) {\n  let result = a % b;\n  if (result < 0) result += b;\n  return result;\n}\nfunction $735220c2d4774dd3$var$addTimeFields(time, duration) {\n  time.hour += duration.hours || 0;\n  time.minute += duration.minutes || 0;\n  time.second += duration.seconds || 0;\n  time.millisecond += duration.milliseconds || 0;\n  return $735220c2d4774dd3$var$balanceTime(time);\n}\nfunction $735220c2d4774dd3$export$7ed87b6bc2506470(time, duration) {\n  let res = time.copy();\n  $735220c2d4774dd3$var$addTimeFields(res, duration);\n  return res;\n}\nfunction $735220c2d4774dd3$export$fe34d3a381cd7501(time, duration) {\n  return $735220c2d4774dd3$export$7ed87b6bc2506470(time, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));\n}\nfunction $735220c2d4774dd3$export$d52ced6badfb9a4c(value, field, amount, options) {\n  let mutable = value.copy();\n  switch (field) {\n    case 'era':\n      {\n        let eras = value.calendar.getEras();\n        let eraIndex = eras.indexOf(value.era);\n        if (eraIndex < 0) throw new Error('Invalid era: ' + value.era);\n        eraIndex = $735220c2d4774dd3$var$cycleValue(eraIndex, amount, 0, eras.length - 1, options === null || options === void 0 ? void 0 : options.round);\n        mutable.era = eras[eraIndex];\n        // Constrain the year and other fields within the era, so the era doesn't change when we balance below.\n        $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);\n        break;\n      }\n    case 'year':\n      var _mutable_calendar_isInverseEra, _mutable_calendar;\n      if ((_mutable_calendar_isInverseEra = (_mutable_calendar = mutable.calendar).isInverseEra) === null || _mutable_calendar_isInverseEra === void 0 ? void 0 : _mutable_calendar_isInverseEra.call(_mutable_calendar, mutable)) amount = -amount;\n      // The year field should not cycle within the era as that can cause weird behavior affecting other fields.\n      // We need to also allow values < 1 so that decrementing goes to the previous era. If we get -Infinity back\n      // we know we wrapped around after reaching 9999 (the maximum), so set the year back to 1.\n      mutable.year = $735220c2d4774dd3$var$cycleValue(value.year, amount, -Infinity, 9999, options === null || options === void 0 ? void 0 : options.round);\n      if (mutable.year === -Infinity) mutable.year = 1;\n      if (mutable.calendar.balanceYearMonth) mutable.calendar.balanceYearMonth(mutable, value);\n      break;\n    case 'month':\n      mutable.month = $735220c2d4774dd3$var$cycleValue(value.month, amount, 1, value.calendar.getMonthsInYear(value), options === null || options === void 0 ? void 0 : options.round);\n      break;\n    case 'day':\n      mutable.day = $735220c2d4774dd3$var$cycleValue(value.day, amount, 1, value.calendar.getDaysInMonth(value), options === null || options === void 0 ? void 0 : options.round);\n      break;\n    default:\n      throw new Error('Unsupported field ' + field);\n  }\n  if (value.calendar.balanceDate) value.calendar.balanceDate(mutable);\n  $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);\n  return mutable;\n}\nfunction $735220c2d4774dd3$export$dd02b3e0007dfe28(value, field, amount, options) {\n  let mutable = value.copy();\n  switch (field) {\n    case 'hour':\n      {\n        let hours = value.hour;\n        let min = 0;\n        let max = 23;\n        if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {\n          let isPM = hours >= 12;\n          min = isPM ? 12 : 0;\n          max = isPM ? 23 : 11;\n        }\n        mutable.hour = $735220c2d4774dd3$var$cycleValue(hours, amount, min, max, options === null || options === void 0 ? void 0 : options.round);\n        break;\n      }\n    case 'minute':\n      mutable.minute = $735220c2d4774dd3$var$cycleValue(value.minute, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);\n      break;\n    case 'second':\n      mutable.second = $735220c2d4774dd3$var$cycleValue(value.second, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);\n      break;\n    case 'millisecond':\n      mutable.millisecond = $735220c2d4774dd3$var$cycleValue(value.millisecond, amount, 0, 999, options === null || options === void 0 ? void 0 : options.round);\n      break;\n    default:\n      throw new Error('Unsupported field ' + field);\n  }\n  return mutable;\n}\nfunction $735220c2d4774dd3$var$cycleValue(value, amount, min, max) {\n  let round = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  if (round) {\n    value += Math.sign(amount);\n    if (value < min) value = max;\n    let div = Math.abs(amount);\n    if (amount > 0) value = Math.ceil(value / div) * div;else value = Math.floor(value / div) * div;\n    if (value > max) value = min;\n  } else {\n    value += amount;\n    if (value < min) value = max - (min - value - 1);else if (value > max) value = min + (value - max - 1);\n  }\n  return value;\n}\nfunction $735220c2d4774dd3$export$96b1d28349274637(dateTime, duration) {\n  let ms;\n  if (duration.years != null && duration.years !== 0 || duration.months != null && duration.months !== 0 || duration.weeks != null && duration.weeks !== 0 || duration.days != null && duration.days !== 0) {\n    let res = $735220c2d4774dd3$export$e16d8520af44a096((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), {\n      years: duration.years,\n      months: duration.months,\n      weeks: duration.weeks,\n      days: duration.days\n    });\n    // Changing the date may change the timezone offset, so we need to recompute\n    // using the 'compatible' disambiguation.\n    ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone);\n  } else\n    // Otherwise, preserve the offset of the original date.\n    ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;\n  // Perform time manipulation in milliseconds rather than on the original time fields to account for DST.\n  // For example, adding one hour during a DST transition may result in the hour field staying the same or\n  // skipping an hour. This results in the offset field changing value instead of the specified field.\n  ms += duration.milliseconds || 0;\n  ms += (duration.seconds || 0) * 1000;\n  ms += (duration.minutes || 0) * 60000;\n  ms += (duration.hours || 0) * 3600000;\n  let res = (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone);\n  return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(res, dateTime.calendar);\n}\nfunction $735220c2d4774dd3$export$6814caac34ca03c7(dateTime, duration) {\n  return $735220c2d4774dd3$export$96b1d28349274637(dateTime, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));\n}\nfunction $735220c2d4774dd3$export$9a297d111fc86b79(dateTime, field, amount, options) {\n  // For date fields, we want the time to remain consistent and the UTC offset to potentially change to account for DST changes.\n  // For time fields, we want the time to change by the amount given. This may result in the hour field staying the same, but the UTC\n  // offset changing in the case of a backward DST transition, or skipping an hour in the case of a forward DST transition.\n  switch (field) {\n    case 'hour':\n      {\n        let min = 0;\n        let max = 23;\n        if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {\n          let isPM = dateTime.hour >= 12;\n          min = isPM ? 12 : 0;\n          max = isPM ? 23 : 11;\n        }\n        // The minimum and maximum hour may be affected by daylight saving time.\n        // For example, it might jump forward at midnight, and skip 1am.\n        // Or it might end at midnight and repeat the 11pm hour. To handle this, we get\n        // the possible absolute times for the min and max, and find the maximum range\n        // that is within the current day.\n        let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);\n        let minDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {\n          hour: min\n        }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());\n        let minAbsolute = [(0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, 'earlier'), (0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, 'later')].filter(ms => (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone).day === minDate.day)[0];\n        let maxDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {\n          hour: max\n        }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());\n        let maxAbsolute = [(0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, 'earlier'), (0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, 'later')].filter(ms => (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone).day === maxDate.day).pop();\n        // Since hours may repeat, we need to operate on the absolute time in milliseconds.\n        // This is done in hours from the Unix epoch so that cycleValue works correctly,\n        // and then converted back to milliseconds.\n        let ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;\n        let hours = Math.floor(ms / $735220c2d4774dd3$var$ONE_HOUR);\n        let remainder = ms % $735220c2d4774dd3$var$ONE_HOUR;\n        ms = $735220c2d4774dd3$var$cycleValue(hours, amount, Math.floor(minAbsolute / $735220c2d4774dd3$var$ONE_HOUR), Math.floor(maxAbsolute / $735220c2d4774dd3$var$ONE_HOUR), options === null || options === void 0 ? void 0 : options.round) * $735220c2d4774dd3$var$ONE_HOUR + remainder;\n        // Now compute the new timezone offset, and convert the absolute time back to local time.\n        return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);\n      }\n    case 'minute':\n    case 'second':\n    case 'millisecond':\n      // @ts-ignore\n      return $735220c2d4774dd3$export$dd02b3e0007dfe28(dateTime, field, amount, options);\n    case 'era':\n    case 'year':\n    case 'month':\n    case 'day':\n      {\n        let res = $735220c2d4774dd3$export$d52ced6badfb9a4c((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), field, amount, options);\n        let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone);\n        return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);\n      }\n    default:\n      throw new Error('Unsupported field ' + field);\n  }\n}\nfunction $735220c2d4774dd3$export$31b5430eb18be4f8(dateTime, fields, disambiguation) {\n  // Set the date/time fields, and recompute the UTC offset to account for DST changes.\n  // We also need to validate by converting back to a local time in case hours are skipped during forward DST transitions.\n  let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);\n  let res = $735220c2d4774dd3$export$e5d5e1c1822b6e56($735220c2d4774dd3$export$adaa4cf7ef1b65be(plainDateTime, fields), fields);\n  // If the resulting plain date time values are equal, return the original time.\n  // We don't want to change the offset when setting the time to the same value.\n  if (res.compare(plainDateTime) === 0) return dateTime;\n  let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone, disambiguation);\n  return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);\n}\nexport { $735220c2d4774dd3$export$e16d8520af44a096 as add, $735220c2d4774dd3$export$c4e2ecac49351ef2 as constrain, $735220c2d4774dd3$export$3e2544e88a25bff8 as invertDuration, $735220c2d4774dd3$export$4e2d2ead65e5f7e3 as subtract, $735220c2d4774dd3$export$adaa4cf7ef1b65be as set, $735220c2d4774dd3$export$e5d5e1c1822b6e56 as setTime, $735220c2d4774dd3$export$7555de1e070510cb as constrainTime, $735220c2d4774dd3$export$7ed87b6bc2506470 as addTime, $735220c2d4774dd3$export$fe34d3a381cd7501 as subtractTime, $735220c2d4774dd3$export$d52ced6badfb9a4c as cycleDate, $735220c2d4774dd3$export$dd02b3e0007dfe28 as cycleTime, $735220c2d4774dd3$export$96b1d28349274637 as addZoned, $735220c2d4774dd3$export$6814caac34ca03c7 as subtractZoned, $735220c2d4774dd3$export$9a297d111fc86b79 as cycleZoned, $735220c2d4774dd3$export$31b5430eb18be4f8 as setZoned };","map":{"version":3,"mappings":"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","names":["$735220c2d4774dd3$var$ONE_HOUR","$735220c2d4774dd3$export$e16d8520af44a096","date","duration","mutableDate","copy","days","$735220c2d4774dd3$var$addTimeFields","$735220c2d4774dd3$var$addYears","years","calendar","balanceYearMonth","month","months","$735220c2d4774dd3$var$balanceYearMonth","$735220c2d4774dd3$var$constrainMonthDay","day","weeks","$735220c2d4774dd3$var$balanceDay","balanceDate","year","maxYear","getYearsInEra","_mutableDate_calendar_isInverseEra","isInverseEra","getMonthsInYear","getDaysInMonth","maxMonth","Math","max","min","_date_calendar_isInverseEra","monthsInYear","$735220c2d4774dd3$export$c4e2ecac49351ef2","constrainDate","$735220c2d4774dd3$export$3e2544e88a25bff8","inverseDuration","key","$735220c2d4774dd3$export$4e2d2ead65e5f7e3","$735220c2d4774dd3$export$adaa4cf7ef1b65be","fields","era","$735220c2d4774dd3$export$e5d5e1c1822b6e56","value","mutableValue","hour","minute","second","millisecond","$735220c2d4774dd3$export$7555de1e070510cb","$735220c2d4774dd3$var$balanceTime","time","floor","$735220c2d4774dd3$var$nonNegativeMod","a","b","result","hours","minutes","seconds","milliseconds","$735220c2d4774dd3$export$7ed87b6bc2506470","res","$735220c2d4774dd3$export$fe34d3a381cd7501","$735220c2d4774dd3$export$d52ced6badfb9a4c","field","amount","options","mutable","eras","getEras","eraIndex","indexOf","Error","$735220c2d4774dd3$var$cycleValue","length","round","_mutable_calendar_isInverseEra","Infinity","$735220c2d4774dd3$export$dd02b3e0007dfe28","hourCycle","isPM","sign","div","abs","ceil","$735220c2d4774dd3$export$96b1d28349274637","dateTime","ms","timeZone","offset","$735220c2d4774dd3$export$6814caac34ca03c7","$735220c2d4774dd3$export$9a297d111fc86b79","plainDateTime","minDate","minAbsolute","filter","maxDate","maxAbsolute","pop","remainder","$735220c2d4774dd3$export$31b5430eb18be4f8","disambiguation","compare"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@internationalized\\date\\dist\\packages\\@internationalized\\date\\src\\manipulation.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AnyCalendarDate, AnyDateTime, AnyTime, CycleOptions, CycleTimeOptions, DateDuration, DateField, DateFields, DateTimeDuration, Disambiguation, TimeDuration, TimeField, TimeFields} from './types';\nimport {CalendarDate, CalendarDateTime, Time, ZonedDateTime} from './CalendarDate';\nimport {epochFromDate, fromAbsolute, toAbsolute, toCalendar, toCalendarDateTime} from './conversion';\nimport {GregorianCalendar} from './calendars/GregorianCalendar';\nimport {Mutable} from './utils';\n\nconst ONE_HOUR = 3600000;\n\nexport function add(date: CalendarDateTime, duration: DateTimeDuration): CalendarDateTime;\nexport function add(date: CalendarDate, duration: DateDuration): CalendarDate;\nexport function add(date: CalendarDate | CalendarDateTime, duration: DateTimeDuration): CalendarDate | CalendarDateTime;\nexport function add(date: CalendarDate | CalendarDateTime, duration: DateTimeDuration) {\n  let mutableDate: Mutable<AnyCalendarDate | AnyDateTime> = date.copy();\n  let days = 'hour' in mutableDate ? addTimeFields(mutableDate, duration) : 0;\n\n  addYears(mutableDate, duration.years || 0);\n  if (mutableDate.calendar.balanceYearMonth) {\n    mutableDate.calendar.balanceYearMonth(mutableDate, date);\n  }\n\n  mutableDate.month += duration.months || 0;\n\n  balanceYearMonth(mutableDate);\n  constrainMonthDay(mutableDate);\n\n  mutableDate.day += (duration.weeks || 0) * 7;\n  mutableDate.day += duration.days || 0;\n  mutableDate.day += days;\n\n  balanceDay(mutableDate);\n\n  if (mutableDate.calendar.balanceDate) {\n    mutableDate.calendar.balanceDate(mutableDate);\n  }\n\n  // Constrain in case adding ended up with a date outside the valid range for the calendar system.\n  // The behavior here is slightly different than when constraining in the `set` function in that\n  // we adjust smaller fields to their minimum/maximum values rather than constraining each field\n  // individually. This matches the general behavior of `add` vs `set` regarding how fields are balanced.\n  if (mutableDate.year < 1) {\n    mutableDate.year = 1;\n    mutableDate.month = 1;\n    mutableDate.day = 1;\n  }\n\n  let maxYear = mutableDate.calendar.getYearsInEra(mutableDate);\n  if (mutableDate.year > maxYear) {\n    let isInverseEra = mutableDate.calendar.isInverseEra?.(mutableDate);\n    mutableDate.year = maxYear;\n    mutableDate.month = isInverseEra ? 1 : mutableDate.calendar.getMonthsInYear(mutableDate);\n    mutableDate.day = isInverseEra ? 1 : mutableDate.calendar.getDaysInMonth(mutableDate);\n  }\n\n  if (mutableDate.month < 1) {\n    mutableDate.month = 1;\n    mutableDate.day = 1;\n  }\n\n  let maxMonth = mutableDate.calendar.getMonthsInYear(mutableDate);\n  if (mutableDate.month > maxMonth) {\n    mutableDate.month = maxMonth;\n    mutableDate.day = mutableDate.calendar.getDaysInMonth(mutableDate);\n  }\n\n  mutableDate.day = Math.max(1, Math.min(mutableDate.calendar.getDaysInMonth(mutableDate), mutableDate.day));\n  return mutableDate;\n}\n\nfunction addYears(date: Mutable<AnyCalendarDate>, years: number) {\n  if (date.calendar.isInverseEra?.(date)) {\n    years = -years;\n  }\n\n  date.year += years;\n}\n\nfunction balanceYearMonth(date: Mutable<AnyCalendarDate>) {\n  while (date.month < 1) {\n    addYears(date, -1);\n    date.month += date.calendar.getMonthsInYear(date);\n  }\n\n  let monthsInYear = 0;\n  while (date.month > (monthsInYear = date.calendar.getMonthsInYear(date))) {\n    date.month -= monthsInYear;\n    addYears(date, 1);\n  }\n}\n\nfunction balanceDay(date: Mutable<AnyCalendarDate>) {\n  while (date.day < 1) {\n    date.month--;\n    balanceYearMonth(date);\n    date.day += date.calendar.getDaysInMonth(date);\n  }\n\n  while (date.day > date.calendar.getDaysInMonth(date)) {\n    date.day -= date.calendar.getDaysInMonth(date);\n    date.month++;\n    balanceYearMonth(date);\n  }\n}\n\nfunction constrainMonthDay(date: Mutable<AnyCalendarDate>) {\n  date.month = Math.max(1, Math.min(date.calendar.getMonthsInYear(date), date.month));\n  date.day = Math.max(1, Math.min(date.calendar.getDaysInMonth(date), date.day));\n}\n\nexport function constrain(date: Mutable<AnyCalendarDate>) {\n  if (date.calendar.constrainDate) {\n    date.calendar.constrainDate(date);\n  }\n\n  date.year = Math.max(1, Math.min(date.calendar.getYearsInEra(date), date.year));\n  constrainMonthDay(date);\n}\n\nexport function invertDuration(duration: DateTimeDuration): DateTimeDuration {\n  let inverseDuration = {};\n  for (let key in duration) {\n    if (typeof duration[key] === 'number') {\n      inverseDuration[key] = -duration[key];\n    }\n  }\n\n  return inverseDuration;\n}\n\nexport function subtract(date: CalendarDateTime, duration: DateTimeDuration): CalendarDateTime;\nexport function subtract(date: CalendarDate, duration: DateDuration): CalendarDate;\nexport function subtract(date: CalendarDate | CalendarDateTime, duration: DateTimeDuration): CalendarDate | CalendarDateTime {\n  return add(date, invertDuration(duration));\n}\n\nexport function set(date: CalendarDateTime, fields: DateFields): CalendarDateTime;\nexport function set(date: CalendarDate, fields: DateFields): CalendarDate;\nexport function set(date: CalendarDate | CalendarDateTime, fields: DateFields) {\n  let mutableDate: Mutable<AnyCalendarDate> = date.copy();\n\n  if (fields.era != null) {\n    mutableDate.era = fields.era;\n  }\n\n  if (fields.year != null) {\n    mutableDate.year = fields.year;\n  }\n\n  if (fields.month != null) {\n    mutableDate.month = fields.month;\n  }\n\n  if (fields.day != null) {\n    mutableDate.day = fields.day;\n  }\n\n  constrain(mutableDate);\n  return mutableDate;\n}\n\nexport function setTime(value: CalendarDateTime, fields: TimeFields): CalendarDateTime;\nexport function setTime(value: Time, fields: TimeFields): Time;\nexport function setTime(value: Time | CalendarDateTime, fields: TimeFields) {\n  let mutableValue: Mutable<Time | CalendarDateTime> = value.copy();\n\n  if (fields.hour != null) {\n    mutableValue.hour = fields.hour;\n  }\n\n  if (fields.minute != null) {\n    mutableValue.minute = fields.minute;\n  }\n\n  if (fields.second != null) {\n    mutableValue.second = fields.second;\n  }\n\n  if (fields.millisecond != null) {\n    mutableValue.millisecond = fields.millisecond;\n  }\n\n  constrainTime(mutableValue);\n  return mutableValue;\n}\n\nfunction balanceTime(time: Mutable<AnyTime>): number {\n  time.second += Math.floor(time.millisecond / 1000);\n  time.millisecond = nonNegativeMod(time.millisecond, 1000);\n\n  time.minute += Math.floor(time.second / 60);\n  time.second = nonNegativeMod(time.second, 60);\n\n  time.hour += Math.floor(time.minute / 60);\n  time.minute = nonNegativeMod(time.minute, 60);\n\n  let days = Math.floor(time.hour / 24);\n  time.hour = nonNegativeMod(time.hour, 24);\n\n  return days;\n}\n\nexport function constrainTime(time: Mutable<AnyTime>) {\n  time.millisecond = Math.max(0, Math.min(time.millisecond, 1000));\n  time.second = Math.max(0, Math.min(time.second, 59));\n  time.minute = Math.max(0, Math.min(time.minute, 59));\n  time.hour = Math.max(0, Math.min(time.hour, 23));\n}\n\nfunction nonNegativeMod(a: number, b: number) {\n  let result = a % b;\n  if (result < 0) {\n    result += b;\n  }\n  return result;\n}\n\nfunction addTimeFields(time: Mutable<AnyTime>, duration: TimeDuration): number {\n  time.hour += duration.hours || 0;\n  time.minute += duration.minutes || 0;\n  time.second += duration.seconds || 0;\n  time.millisecond += duration.milliseconds || 0;\n  return balanceTime(time);\n}\n\nexport function addTime(time: Time, duration: TimeDuration): Time {\n  let res = time.copy();\n  addTimeFields(res, duration);\n  return res;\n}\n\nexport function subtractTime(time: Time, duration: TimeDuration): Time {\n  return addTime(time, invertDuration(duration));\n}\n\nexport function cycleDate(value: CalendarDateTime, field: DateField, amount: number, options?: CycleOptions): CalendarDateTime;\nexport function cycleDate(value: CalendarDate, field: DateField, amount: number, options?: CycleOptions): CalendarDate;\nexport function cycleDate(value: CalendarDate | CalendarDateTime, field: DateField, amount: number, options?: CycleOptions) {\n  let mutable: Mutable<CalendarDate | CalendarDateTime> = value.copy();\n\n  switch (field) {\n    case 'era': {\n      let eras = value.calendar.getEras();\n      let eraIndex = eras.indexOf(value.era);\n      if (eraIndex < 0) {\n        throw new Error('Invalid era: ' + value.era);\n      }\n      eraIndex = cycleValue(eraIndex, amount, 0, eras.length - 1, options?.round);\n      mutable.era = eras[eraIndex];\n\n      // Constrain the year and other fields within the era, so the era doesn't change when we balance below.\n      constrain(mutable);\n      break;\n    }\n    case 'year': {\n      if (mutable.calendar.isInverseEra?.(mutable)) {\n        amount = -amount;\n      }\n\n      // The year field should not cycle within the era as that can cause weird behavior affecting other fields.\n      // We need to also allow values < 1 so that decrementing goes to the previous era. If we get -Infinity back\n      // we know we wrapped around after reaching 9999 (the maximum), so set the year back to 1.\n      mutable.year = cycleValue(value.year, amount, -Infinity, 9999, options?.round);\n      if (mutable.year === -Infinity) {\n        mutable.year = 1;\n      }\n\n      if (mutable.calendar.balanceYearMonth) {\n        mutable.calendar.balanceYearMonth(mutable, value);\n      }\n      break;\n    }\n    case 'month':\n      mutable.month = cycleValue(value.month, amount, 1, value.calendar.getMonthsInYear(value), options?.round);\n      break;\n    case 'day':\n      mutable.day = cycleValue(value.day, amount, 1, value.calendar.getDaysInMonth(value), options?.round);\n      break;\n    default:\n      throw new Error('Unsupported field ' + field);\n  }\n\n  if (value.calendar.balanceDate) {\n    value.calendar.balanceDate(mutable);\n  }\n\n  constrain(mutable);\n  return mutable;\n}\n\nexport function cycleTime(value: CalendarDateTime, field: TimeField, amount: number, options?: CycleTimeOptions): CalendarDateTime;\nexport function cycleTime(value: Time, field: TimeField, amount: number, options?: CycleTimeOptions): Time;\nexport function cycleTime(value: Time | CalendarDateTime, field: TimeField, amount: number, options?: CycleTimeOptions) {\n  let mutable: Mutable<Time | CalendarDateTime> = value.copy();\n\n  switch (field) {\n    case 'hour': {\n      let hours = value.hour;\n      let min = 0;\n      let max = 23;\n      if (options?.hourCycle === 12) {\n        let isPM = hours >= 12;\n        min = isPM ? 12 : 0;\n        max = isPM ? 23 : 11;\n      }\n      mutable.hour = cycleValue(hours, amount, min, max, options?.round);\n      break;\n    }\n    case 'minute':\n      mutable.minute = cycleValue(value.minute, amount, 0, 59, options?.round);\n      break;\n    case 'second':\n      mutable.second = cycleValue(value.second, amount, 0, 59, options?.round);\n      break;\n    case 'millisecond':\n      mutable.millisecond = cycleValue(value.millisecond, amount, 0, 999, options?.round);\n      break;\n    default:\n      throw new Error('Unsupported field ' + field);\n  }\n\n  return mutable;\n}\n\nfunction cycleValue(value: number, amount: number, min: number, max: number, round = false) {\n  if (round) {\n    value += Math.sign(amount);\n\n    if (value < min) {\n      value = max;\n    }\n\n    let div = Math.abs(amount);\n    if (amount > 0) {\n      value = Math.ceil(value / div) * div;\n    } else {\n      value = Math.floor(value / div) * div;\n    }\n\n    if (value > max) {\n      value = min;\n    }\n  } else {\n    value += amount;\n    if (value < min) {\n      value = max - (min - value - 1);\n    } else if (value > max) {\n      value = min + (value - max - 1);\n    }\n  }\n\n  return value;\n}\n\nexport function addZoned(dateTime: ZonedDateTime, duration: DateTimeDuration): ZonedDateTime {\n  let ms: number;\n  if ((duration.years != null && duration.years !== 0) || (duration.months != null && duration.months !== 0) || (duration.weeks != null && duration.weeks !== 0) || (duration.days != null && duration.days !== 0)) {\n    let res = add(toCalendarDateTime(dateTime), {\n      years: duration.years,\n      months: duration.months,\n      weeks: duration.weeks,\n      days: duration.days\n    });\n\n    // Changing the date may change the timezone offset, so we need to recompute\n    // using the 'compatible' disambiguation.\n    ms = toAbsolute(res, dateTime.timeZone);\n  } else {\n    // Otherwise, preserve the offset of the original date.\n    ms = epochFromDate(dateTime) - dateTime.offset;\n  }\n\n  // Perform time manipulation in milliseconds rather than on the original time fields to account for DST.\n  // For example, adding one hour during a DST transition may result in the hour field staying the same or\n  // skipping an hour. This results in the offset field changing value instead of the specified field.\n  ms += duration.milliseconds || 0;\n  ms += (duration.seconds || 0) * 1000;\n  ms += (duration.minutes || 0) * 60 * 1000;\n  ms += (duration.hours || 0) * 60 * 60 * 1000;\n\n  let res = fromAbsolute(ms, dateTime.timeZone);\n  return toCalendar(res, dateTime.calendar);\n}\n\nexport function subtractZoned(dateTime: ZonedDateTime, duration: DateTimeDuration): ZonedDateTime {\n  return addZoned(dateTime, invertDuration(duration));\n}\n\nexport function cycleZoned(dateTime: ZonedDateTime, field: DateField | TimeField, amount: number, options?: CycleTimeOptions): ZonedDateTime {\n  // For date fields, we want the time to remain consistent and the UTC offset to potentially change to account for DST changes.\n  // For time fields, we want the time to change by the amount given. This may result in the hour field staying the same, but the UTC\n  // offset changing in the case of a backward DST transition, or skipping an hour in the case of a forward DST transition.\n  switch (field) {\n    case 'hour': {\n      let min = 0;\n      let max = 23;\n      if (options?.hourCycle === 12) {\n        let isPM = dateTime.hour >= 12;\n        min = isPM ? 12 : 0;\n        max = isPM ? 23 : 11;\n      }\n\n      // The minimum and maximum hour may be affected by daylight saving time.\n      // For example, it might jump forward at midnight, and skip 1am.\n      // Or it might end at midnight and repeat the 11pm hour. To handle this, we get\n      // the possible absolute times for the min and max, and find the maximum range\n      // that is within the current day.\n      let plainDateTime = toCalendarDateTime(dateTime);\n      let minDate = toCalendar(setTime(plainDateTime, {hour: min}), new GregorianCalendar());\n      let minAbsolute = [toAbsolute(minDate, dateTime.timeZone, 'earlier'), toAbsolute(minDate, dateTime.timeZone, 'later')]\n        .filter(ms => fromAbsolute(ms, dateTime.timeZone).day === minDate.day)[0];\n\n      let maxDate = toCalendar(setTime(plainDateTime, {hour: max}), new GregorianCalendar());\n      let maxAbsolute = [toAbsolute(maxDate, dateTime.timeZone, 'earlier'), toAbsolute(maxDate, dateTime.timeZone, 'later')]\n        .filter(ms => fromAbsolute(ms, dateTime.timeZone).day === maxDate.day).pop()!;\n\n      // Since hours may repeat, we need to operate on the absolute time in milliseconds.\n      // This is done in hours from the Unix epoch so that cycleValue works correctly,\n      // and then converted back to milliseconds.\n      let ms = epochFromDate(dateTime) - dateTime.offset;\n      let hours = Math.floor(ms / ONE_HOUR);\n      let remainder = ms % ONE_HOUR;\n      ms = cycleValue(\n        hours,\n        amount,\n        Math.floor(minAbsolute / ONE_HOUR),\n        Math.floor(maxAbsolute / ONE_HOUR),\n        options?.round\n      ) * ONE_HOUR + remainder;\n\n      // Now compute the new timezone offset, and convert the absolute time back to local time.\n      return toCalendar(fromAbsolute(ms, dateTime.timeZone), dateTime.calendar);\n    }\n    case 'minute':\n    case 'second':\n    case 'millisecond':\n      // @ts-ignore\n      return cycleTime(dateTime, field, amount, options);\n    case 'era':\n    case 'year':\n    case 'month':\n    case 'day': {\n      let res = cycleDate(toCalendarDateTime(dateTime), field, amount, options);\n      let ms = toAbsolute(res, dateTime.timeZone);\n      return toCalendar(fromAbsolute(ms, dateTime.timeZone), dateTime.calendar);\n    }\n    default:\n      throw new Error('Unsupported field ' + field);\n  }\n}\n\nexport function setZoned(dateTime: ZonedDateTime, fields: DateFields & TimeFields, disambiguation?: Disambiguation): ZonedDateTime {\n  // Set the date/time fields, and recompute the UTC offset to account for DST changes.\n  // We also need to validate by converting back to a local time in case hours are skipped during forward DST transitions.\n  let plainDateTime = toCalendarDateTime(dateTime);\n  let res = setTime(set(plainDateTime, fields), fields);\n\n  // If the resulting plain date time values are equal, return the original time.\n  // We don't want to change the offset when setting the time to the same value.\n  if (res.compare(plainDateTime) === 0) {\n    return dateTime;\n  }\n\n  let ms = toAbsolute(res, dateTime.timeZone, disambiguation);\n  return toCalendar(fromAbsolute(ms, dateTime.timeZone), dateTime.calendar);\n}\n"]},"metadata":{},"sourceType":"module"}