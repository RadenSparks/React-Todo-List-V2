{"ast":null,"code":"import { getFirstItem as $eIXPM$getFirstItem, getChildNodes as $eIXPM$getChildNodes, getNthItem as $eIXPM$getNthItem } from \"@react-stately/collections\";\nimport { GridKeyboardDelegate as $eIXPM$GridKeyboardDelegate } from \"@react-aria/grid\";\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nclass $0ba3c81c7f1caedd$export$da43f8f5cb04028d extends (0, $eIXPM$GridKeyboardDelegate) {\n  isCell(node) {\n    return node.type === 'cell' || node.type === 'rowheader' || node.type === 'column';\n  }\n  getKeyBelow(key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) return;\n    // If focus was on a column, then focus the first child column if any,\n    // or find the corresponding cell in the first row.\n    if (startItem.type === 'column') {\n      let child = (0, $eIXPM$getFirstItem)((0, $eIXPM$getChildNodes)(startItem, this.collection));\n      if (child) return child.key;\n      let firstKey = this.getFirstKey();\n      if (firstKey == null) return;\n      let firstItem = this.collection.getItem(firstKey);\n      return (0, $eIXPM$getNthItem)((0, $eIXPM$getChildNodes)(firstItem, this.collection), startItem.index).key;\n    }\n    return super.getKeyBelow(key);\n  }\n  getKeyAbove(key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) return;\n    // If focus was on a column, focus the parent column if any\n    if (startItem.type === 'column') {\n      let parent = this.collection.getItem(startItem.parentKey);\n      if (parent && parent.type === 'column') return parent.key;\n      return;\n    }\n    // only return above row key if not header row\n    let superKey = super.getKeyAbove(key);\n    if (superKey != null && this.collection.getItem(superKey).type !== 'headerrow') return superKey;\n    // If no item was found, and focus was on a cell, then focus the\n    // corresponding column header.\n    if (this.isCell(startItem)) return this.collection.columns[startItem.index].key;\n    // If focus was on a row, then focus the first column header.\n    return this.collection.columns[0].key;\n  }\n  findNextColumnKey(column) {\n    // Search following columns\n    let key = this.findNextKey(column.key, item => item.type === 'column');\n    if (key != null) return key;\n    // Wrap around to the first column\n    let row = this.collection.headerRows[column.level];\n    for (let item of (0, $eIXPM$getChildNodes)(row, this.collection)) {\n      if (item.type === 'column') return item.key;\n    }\n  }\n  findPreviousColumnKey(column) {\n    // Search previous columns\n    let key = this.findPreviousKey(column.key, item => item.type === 'column');\n    if (key != null) return key;\n    // Wrap around to the last column\n    let row = this.collection.headerRows[column.level];\n    let childNodes = [...(0, $eIXPM$getChildNodes)(row, this.collection)];\n    for (let i = childNodes.length - 1; i >= 0; i--) {\n      let item = childNodes[i];\n      if (item.type === 'column') return item.key;\n    }\n  }\n  getKeyRightOf(key) {\n    let item = this.collection.getItem(key);\n    if (!item) return;\n    // If focus was on a column, then focus the next column\n    if (item.type === 'column') return this.direction === 'rtl' ? this.findPreviousColumnKey(item) : this.findNextColumnKey(item);\n    return super.getKeyRightOf(key);\n  }\n  getKeyLeftOf(key) {\n    let item = this.collection.getItem(key);\n    if (!item) return;\n    // If focus was on a column, then focus the previous column\n    if (item.type === 'column') return this.direction === 'rtl' ? this.findNextColumnKey(item) : this.findPreviousColumnKey(item);\n    return super.getKeyLeftOf(key);\n  }\n  getKeyForSearch(search, fromKey) {\n    if (!this.collator) return null;\n    let collection = this.collection;\n    let key = fromKey !== null && fromKey !== void 0 ? fromKey : this.getFirstKey();\n    if (key == null) return null;\n    // If the starting key is a cell, search from its parent row.\n    let startItem = collection.getItem(key);\n    if (startItem.type === 'cell') key = startItem.parentKey;\n    let hasWrapped = false;\n    while (key != null) {\n      let item = collection.getItem(key);\n      // Check each of the row header cells in this row for a match\n      for (let cell of (0, $eIXPM$getChildNodes)(item, this.collection)) {\n        let column = collection.columns[cell.index];\n        if (collection.rowHeaderColumnKeys.has(column.key) && cell.textValue) {\n          let substring = cell.textValue.slice(0, search.length);\n          if (this.collator.compare(substring, search) === 0) {\n            // If we started on a cell, end on the matching cell. Otherwise, end on the row.\n            let fromItem = fromKey != null ? collection.getItem(fromKey) : startItem;\n            return fromItem.type === 'cell' ? cell.key : item.key;\n          }\n        }\n      }\n      key = this.getKeyBelow(key);\n      // Wrap around when reaching the end of the collection\n      if (key == null && !hasWrapped) {\n        key = this.getFirstKey();\n        hasWrapped = true;\n      }\n    }\n    return null;\n  }\n}\nexport { $0ba3c81c7f1caedd$export$da43f8f5cb04028d as TableKeyboardDelegate };","map":{"version":3,"mappings":"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","names":["$0ba3c81c7f1caedd$export$da43f8f5cb04028d","isCell","node","type","getKeyBelow","key","startItem","collection","getItem","child","firstKey","getFirstKey","firstItem","index","getKeyAbove","parent","parentKey","superKey","columns","findNextColumnKey","column","findNextKey","item","row","headerRows","level","findPreviousColumnKey","findPreviousKey","childNodes","i","length","getKeyRightOf","direction","getKeyLeftOf","getKeyForSearch","search","fromKey","collator","hasWrapped","cell","rowHeaderColumnKeys","has","textValue","substring","slice","compare","fromItem"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-aria\\table\\dist\\packages\\@react-aria\\table\\src\\TableKeyboardDelegate.ts"],"sourcesContent":["/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {getChildNodes, getFirstItem, getNthItem} from '@react-stately/collections';\nimport {GridKeyboardDelegate} from '@react-aria/grid';\nimport {Key, Node} from '@react-types/shared';\nimport {TableCollection} from '@react-types/table';\n\nexport class TableKeyboardDelegate<T> extends GridKeyboardDelegate<T, TableCollection<T>> {\n\n  protected isCell(node: Node<T>) {\n    return node.type === 'cell' || node.type === 'rowheader' || node.type === 'column';\n  }\n\n  getKeyBelow(key: Key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) {\n      return;\n    }\n\n    // If focus was on a column, then focus the first child column if any,\n    // or find the corresponding cell in the first row.\n    if (startItem.type === 'column') {\n      let child = getFirstItem(getChildNodes(startItem, this.collection));\n      if (child) {\n        return child.key;\n      }\n\n      let firstKey = this.getFirstKey();\n      if (firstKey == null) {\n        return;\n      }\n\n      let firstItem = this.collection.getItem(firstKey);\n      return getNthItem(getChildNodes(firstItem, this.collection), startItem.index).key;\n    }\n\n    return super.getKeyBelow(key);\n  }\n\n  getKeyAbove(key: Key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) {\n      return;\n    }\n\n    // If focus was on a column, focus the parent column if any\n    if (startItem.type === 'column') {\n      let parent = this.collection.getItem(startItem.parentKey);\n      if (parent && parent.type === 'column') {\n        return parent.key;\n      }\n\n      return;\n    }\n\n    // only return above row key if not header row\n    let superKey = super.getKeyAbove(key);\n    if (superKey != null && this.collection.getItem(superKey).type !== 'headerrow') {\n      return superKey;\n    }\n\n    // If no item was found, and focus was on a cell, then focus the\n    // corresponding column header.\n    if (this.isCell(startItem)) {\n      return this.collection.columns[startItem.index].key;\n    }\n\n    // If focus was on a row, then focus the first column header.\n    return this.collection.columns[0].key;\n  }\n\n  private findNextColumnKey(column: Node<T>) {\n    // Search following columns\n    let key = this.findNextKey(column.key, item => item.type === 'column');\n    if (key != null) {\n      return key;\n    }\n\n    // Wrap around to the first column\n    let row = this.collection.headerRows[column.level];\n    for (let item of getChildNodes(row, this.collection)) {\n      if (item.type === 'column') {\n        return item.key;\n      }\n    }\n  }\n\n  private findPreviousColumnKey(column: Node<T>) {\n    // Search previous columns\n    let key = this.findPreviousKey(column.key, item => item.type === 'column');\n    if (key != null) {\n      return key;\n    }\n\n    // Wrap around to the last column\n    let row = this.collection.headerRows[column.level];\n    let childNodes = [...getChildNodes(row, this.collection)];\n    for (let i = childNodes.length - 1; i >= 0; i--) {\n      let item = childNodes[i];\n      if (item.type === 'column') {\n        return item.key;\n      }\n    }\n  }\n\n  getKeyRightOf(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      return;\n    }\n\n    // If focus was on a column, then focus the next column\n    if (item.type === 'column') {\n      return this.direction === 'rtl'\n        ? this.findPreviousColumnKey(item)\n        : this.findNextColumnKey(item);\n    }\n\n    return super.getKeyRightOf(key);\n  }\n\n  getKeyLeftOf(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      return;\n    }\n\n    // If focus was on a column, then focus the previous column\n    if (item.type === 'column') {\n      return this.direction === 'rtl'\n        ? this.findNextColumnKey(item)\n        : this.findPreviousColumnKey(item);\n    }\n\n    return super.getKeyLeftOf(key);\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey ?? this.getFirstKey();\n    if (key == null) {\n      return null;\n    }\n\n    // If the starting key is a cell, search from its parent row.\n    let startItem = collection.getItem(key);\n    if (startItem.type === 'cell') {\n      key = startItem.parentKey;\n    }\n\n    let hasWrapped = false;\n    while (key != null) {\n      let item = collection.getItem(key);\n\n      // Check each of the row header cells in this row for a match\n      for (let cell of getChildNodes(item, this.collection)) {\n        let column = collection.columns[cell.index];\n        if (collection.rowHeaderColumnKeys.has(column.key) && cell.textValue) {\n          let substring = cell.textValue.slice(0, search.length);\n          if (this.collator.compare(substring, search) === 0) {\n            // If we started on a cell, end on the matching cell. Otherwise, end on the row.\n            let fromItem = fromKey != null ? collection.getItem(fromKey) : startItem;\n            return fromItem.type === 'cell'\n              ? cell.key\n              : item.key;\n          }\n        }\n      }\n\n      key = this.getKeyBelow(key);\n\n      // Wrap around when reaching the end of the collection\n      if (key == null && !hasWrapped) {\n        key = this.getFirstKey();\n        hasWrapped = true;\n      }\n    }\n\n    return null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}