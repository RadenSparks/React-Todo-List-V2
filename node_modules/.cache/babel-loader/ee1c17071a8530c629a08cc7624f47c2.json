{"ast":null,"code":"import { createFocusManager as $7CEvq$createFocusManager, getFocusableTreeWalker as $7CEvq$getFocusableTreeWalker } from \"@react-aria/focus\";\nimport { mergeProps as $7CEvq$mergeProps } from \"@react-aria/utils\";\nimport { useMemo as $7CEvq$useMemo } from \"react\";\nimport { useLocale as $7CEvq$useLocale } from \"@react-aria/i18n\";\nimport { usePress as $7CEvq$usePress } from \"@react-aria/interactions\";\nfunction $3dfb0f96be0d6a08$export$4a931266a3838b86(state, ref, disableArrowNavigation) {\n  let {\n    direction: direction\n  } = (0, $7CEvq$useLocale)();\n  let focusManager = (0, $7CEvq$useMemo)(() => (0, $7CEvq$createFocusManager)(ref), [ref]);\n  // Open the popover on alt + arrow down\n  let onKeyDown = e => {\n    if (!e.currentTarget.contains(e.target)) return;\n    if (e.altKey && (e.key === 'ArrowDown' || e.key === 'ArrowUp') && 'setOpen' in state) {\n      e.preventDefault();\n      e.stopPropagation();\n      state.setOpen(true);\n    }\n    if (disableArrowNavigation) return;\n    switch (e.key) {\n      case 'ArrowLeft':\n        e.preventDefault();\n        e.stopPropagation();\n        if (direction === 'rtl') focusManager.focusNext();else focusManager.focusPrevious();\n        break;\n      case 'ArrowRight':\n        e.preventDefault();\n        e.stopPropagation();\n        if (direction === 'rtl') focusManager.focusPrevious();else focusManager.focusNext();\n        break;\n    }\n  };\n  // Focus the first placeholder segment from the end on mouse down/touch up in the field.\n  let focusLast = () => {\n    var _window_event;\n    // Try to find the segment prior to the element that was clicked on.\n    let target = (_window_event = window.event) === null || _window_event === void 0 ? void 0 : _window_event.target;\n    let walker = (0, $7CEvq$getFocusableTreeWalker)(ref.current, {\n      tabbable: true\n    });\n    if (target) {\n      walker.currentNode = target;\n      target = walker.previousNode();\n    }\n    // If no target found, find the last element from the end.\n    if (!target) {\n      let last;\n      do {\n        last = walker.lastChild();\n        if (last) target = last;\n      } while (last);\n    }\n    // Now go backwards until we find an element that is not a placeholder.\n    while (target === null || target === void 0 ? void 0 : target.hasAttribute('data-placeholder')) {\n      let prev = walker.previousNode();\n      if (prev && prev.hasAttribute('data-placeholder')) target = prev;else break;\n    }\n    if (target) target.focus();\n  };\n  let {\n    pressProps: pressProps\n  } = (0, $7CEvq$usePress)({\n    preventFocusOnPress: true,\n    allowTextSelectionOnPress: true,\n    onPressStart(e) {\n      if (e.pointerType === 'mouse') focusLast();\n    },\n    onPress(e) {\n      if (e.pointerType !== 'mouse') focusLast();\n    }\n  });\n  return (0, $7CEvq$mergeProps)(pressProps, {\n    onKeyDown: onKeyDown\n  });\n}\nexport { $3dfb0f96be0d6a08$export$4a931266a3838b86 as useDatePickerGroup };","map":{"version":3,"mappings":";;;;;AAQO,SAASA,0CAAmBC,KAA8D,EAAEC,GAAuB,EAAEC,sBAAgC;EAC1J,IAAI;IAAAC,WAACA;EAAS,CAAC,GAAG,oBAAQ;EAC1B,IAAIC,eAAe,kBAAM,EAAE,MAAM,6BAAiB,EAAEH,MAAM,CAACA,IAAI;EAE/D;EACA,IAAII,YAAaC;IACf,IAAI,CAACA,EAAEC,aAAa,CAACC,QAAQ,CAACF,EAAEG,MAAM,GACpC;IAGF,IAAIH,EAAEI,MAAM,KAAKJ,EAAEK,GAAG,KAAK,eAAeL,EAAEK,GAAG,KAAK,SAAQ,KAAM,aAAaX,OAAO;MACpFM,EAAEM,cAAc;MAChBN,EAAEO,eAAe;MACjBb,MAAMc,OAAO,CAAC;IAChB;IAEA,IAAIZ,wBACF;IAGF,QAAQI,EAAEK,GAAG;MACX,KAAK;QACHL,EAAEM,cAAc;QAChBN,EAAEO,eAAe;QACjB,IAAIV,cAAc,OAChBC,aAAaW,SAAS,QAEtBX,aAAaY,aAAa;QAE5B;MACF,KAAK;QACHV,EAAEM,cAAc;QAChBN,EAAEO,eAAe;QACjB,IAAIV,cAAc,OAChBC,aAAaY,aAAa,QAE1BZ,aAAaW,SAAS;QAExB;IACJ;EACF;EAEA;EACA,IAAIE,YAAYA;QAEDC;IADb;IACA,IAAIT,UAASS,uBAAOC,KAAK,cAAZD,kDAAcT,MAAM;IACjC,IAAIW,SAAS,iCAAqB,EAAEnB,IAAIoB,OAAO,EAAE;MAACC,UAAU;IAAI;IAChE,IAAIb,QAAQ;MACVW,OAAOG,WAAW,GAAGd;MACrBA,SAASW,OAAOI,YAAY;IAC9B;IAEA;IACA,IAAI,CAACf,QAAQ;MACX,IAAIgB;MACJ,GAAG;QACDA,OAAOL,OAAOM,SAAS;QACvB,IAAID,MACFhB,SAASgB;MAEb,SAASA;IACX;IAEA;IACA,OAAOhB,uDAAQkB,YAAY,CAAC,qBAAqB;MAC/C,IAAIC,OAAOR,OAAOI,YAAY;MAC9B,IAAII,QAAQA,KAAKD,YAAY,CAAC,qBAC5BlB,SAASmB,UAET;IAEJ;IAEA,IAAInB,QACFA,OAAOoB,KAAK;EAEhB;EAEA,IAAI;IAAAC,YAACA;EAAU,CAAC,GAAG,mBAAO,EAAE;IAC1BC,qBAAqB;IACrBC,2BAA2B;IAC3BC,aAAa3B,CAAC;MACZ,IAAIA,EAAE4B,WAAW,KAAK,SACpBjB;IAEJ;IACAkB,QAAQ7B,CAAC;MACP,IAAIA,EAAE4B,WAAW,KAAK,SACpBjB;IAEJ;EACF;EAEA,OAAO,qBAAS,EAAEa,YAAY;eAACzB;EAAS;AAC1C","names":["$3dfb0f96be0d6a08$export$4a931266a3838b86","state","ref","disableArrowNavigation","direction","focusManager","onKeyDown","e","currentTarget","contains","target","altKey","key","preventDefault","stopPropagation","setOpen","focusNext","focusPrevious","focusLast","_window_event","event","walker","current","tabbable","currentNode","previousNode","last","lastChild","hasAttribute","prev","focus","pressProps","preventFocusOnPress","allowTextSelectionOnPress","onPressStart","pointerType","onPress"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-aria\\datepicker\\dist\\packages\\@react-aria\\datepicker\\src\\useDatePickerGroup.ts"],"sourcesContent":["import {createFocusManager, getFocusableTreeWalker} from '@react-aria/focus';\nimport {DateFieldState, DatePickerState, DateRangePickerState} from '@react-stately/datepicker';\nimport {FocusableElement, KeyboardEvent} from '@react-types/shared';\nimport {mergeProps} from '@react-aria/utils';\nimport {RefObject, useMemo} from 'react';\nimport {useLocale} from '@react-aria/i18n';\nimport {usePress} from '@react-aria/interactions';\n\nexport function useDatePickerGroup(state: DatePickerState | DateRangePickerState | DateFieldState, ref: RefObject<Element>, disableArrowNavigation?: boolean) {\n  let {direction} = useLocale();\n  let focusManager = useMemo(() => createFocusManager(ref), [ref]);\n\n  // Open the popover on alt + arrow down\n  let onKeyDown = (e: KeyboardEvent) => {\n    if (!e.currentTarget.contains(e.target)) {\n      return;\n    }\n    \n    if (e.altKey && (e.key === 'ArrowDown' || e.key === 'ArrowUp') && 'setOpen' in state) {\n      e.preventDefault();\n      e.stopPropagation();\n      state.setOpen(true);\n    }\n\n    if (disableArrowNavigation) {\n      return;\n    }\n\n    switch (e.key) {\n      case 'ArrowLeft':\n        e.preventDefault();\n        e.stopPropagation();\n        if (direction === 'rtl') {\n          focusManager.focusNext();\n        } else {\n          focusManager.focusPrevious();\n        }\n        break;\n      case 'ArrowRight':\n        e.preventDefault();\n        e.stopPropagation();\n        if (direction === 'rtl') {\n          focusManager.focusPrevious();\n        } else {\n          focusManager.focusNext();\n        }\n        break;\n    }\n  };\n\n  // Focus the first placeholder segment from the end on mouse down/touch up in the field.\n  let focusLast = () => {\n    // Try to find the segment prior to the element that was clicked on.\n    let target = window.event?.target as FocusableElement;\n    let walker = getFocusableTreeWalker(ref.current, {tabbable: true});\n    if (target) {\n      walker.currentNode = target;\n      target = walker.previousNode() as FocusableElement;\n    }\n\n    // If no target found, find the last element from the end.\n    if (!target) {\n      let last: FocusableElement;\n      do {\n        last = walker.lastChild() as FocusableElement;\n        if (last) {\n          target = last;\n        }\n      } while (last);\n    }\n\n    // Now go backwards until we find an element that is not a placeholder.\n    while (target?.hasAttribute('data-placeholder')) {\n      let prev = walker.previousNode() as FocusableElement;\n      if (prev && prev.hasAttribute('data-placeholder')) {\n        target = prev;\n      } else {\n        break;\n      }\n    }\n\n    if (target) {\n      target.focus();\n    }\n  };\n\n  let {pressProps} = usePress({\n    preventFocusOnPress: true,\n    allowTextSelectionOnPress: true,\n    onPressStart(e) {\n      if (e.pointerType === 'mouse') {\n        focusLast();\n      }\n    },\n    onPress(e) {\n      if (e.pointerType !== 'mouse') {\n        focusLast();\n      }\n    }\n  });\n\n  return mergeProps(pressProps, {onKeyDown});\n}\n"]},"metadata":{},"sourceType":"module"}