{"ast":null,"code":"import { getFirstItem as $iLnZt$getFirstItem, getLastItem as $iLnZt$getLastItem } from \"@react-stately/collections\";\nimport { GridCollection as $iLnZt$GridCollection } from \"@react-stately/grid\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY = 'row-header-column-' + Math.random().toString(36).slice(2);\nlet $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = 'row-header-column-' + Math.random().toString(36).slice(2);\nwhile ($788781baa30117fa$var$ROW_HEADER_COLUMN_KEY === $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG) $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = 'row-header-column-' + Math.random().toString(36).slice(2);\nfunction $788781baa30117fa$export$7c127db850d4e81e(keyMap, columnNodes) {\n  if (columnNodes.length === 0) return [];\n  let columns = [];\n  let seen = new Map();\n  for (let column of columnNodes) {\n    let parentKey = column.parentKey;\n    let col = [column];\n    while (parentKey) {\n      let parent = keyMap.get(parentKey);\n      if (!parent) break;\n      // If we've already seen this parent, than it is shared\n      // with a previous column. If the current column is taller\n      // than the previous column, than we need to shift the parent\n      // in the previous column so it's level with the current column.\n      if (seen.has(parent)) {\n        parent.colspan++;\n        let {\n          column: column,\n          index: index\n        } = seen.get(parent);\n        if (index > col.length) break;\n        for (let i = index; i < col.length; i++) column.splice(i, 0, null);\n        // Adjust shifted indices\n        for (let i = col.length; i < column.length; i++)\n        // eslint-disable-next-line max-depth\n        if (column[i] && seen.has(column[i])) seen.get(column[i]).index = i;\n      } else {\n        parent.colspan = 1;\n        col.push(parent);\n        seen.set(parent, {\n          column: col,\n          index: col.length - 1\n        });\n      }\n      parentKey = parent.parentKey;\n    }\n    columns.push(col);\n    column.index = columns.length - 1;\n  }\n  let maxLength = Math.max(...columns.map(c => c.length));\n  let headerRows = Array(maxLength).fill(0).map(() => []);\n  // Convert columns into rows.\n  let colIndex = 0;\n  for (let column of columns) {\n    let i = maxLength - 1;\n    for (let item of column) {\n      if (item) {\n        // Fill the space up until the current column with a placeholder\n        let row = headerRows[i];\n        let rowLength = row.reduce((p, c) => p + c.colspan, 0);\n        if (rowLength < colIndex) {\n          let placeholder = {\n            type: 'placeholder',\n            key: 'placeholder-' + item.key,\n            colspan: colIndex - rowLength,\n            index: rowLength,\n            value: null,\n            rendered: null,\n            level: i,\n            hasChildNodes: false,\n            childNodes: [],\n            textValue: null\n          };\n          // eslint-disable-next-line max-depth\n          if (row.length > 0) {\n            row[row.length - 1].nextKey = placeholder.key;\n            placeholder.prevKey = row[row.length - 1].key;\n          }\n          row.push(placeholder);\n        }\n        if (row.length > 0) {\n          row[row.length - 1].nextKey = item.key;\n          item.prevKey = row[row.length - 1].key;\n        }\n        item.level = i;\n        item.colIndex = colIndex;\n        row.push(item);\n      }\n      i--;\n    }\n    colIndex++;\n  }\n  // Add placeholders at the end of each row that is shorter than the maximum\n  let i = 0;\n  for (let row of headerRows) {\n    let rowLength = row.reduce((p, c) => p + c.colspan, 0);\n    if (rowLength < columnNodes.length) {\n      let placeholder = {\n        type: 'placeholder',\n        key: 'placeholder-' + row[row.length - 1].key,\n        colspan: columnNodes.length - rowLength,\n        index: rowLength,\n        value: null,\n        rendered: null,\n        level: i,\n        hasChildNodes: false,\n        childNodes: [],\n        textValue: null,\n        prevKey: row[row.length - 1].key\n      };\n      row.push(placeholder);\n    }\n    i++;\n  }\n  return headerRows.map((childNodes, index) => {\n    let row = {\n      type: 'headerrow',\n      key: 'headerrow-' + index,\n      index: index,\n      value: null,\n      rendered: null,\n      level: 0,\n      hasChildNodes: true,\n      childNodes: childNodes,\n      textValue: null\n    };\n    return row;\n  });\n}\nclass $788781baa30117fa$export$596e1b2e2cf93690 extends (0, $iLnZt$GridCollection) {\n  *[Symbol.iterator]() {\n    yield* this.body.childNodes;\n  }\n  get size() {\n    return this._size;\n  }\n  getKeys() {\n    return this.keyMap.keys();\n  }\n  getKeyBefore(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n  getKeyAfter(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n  getFirstKey() {\n    var _getFirstItem;\n    return (_getFirstItem = (0, $iLnZt$getFirstItem)(this.body.childNodes)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;\n  }\n  getLastKey() {\n    var _getLastItem;\n    return (_getLastItem = (0, $iLnZt$getLastItem)(this.body.childNodes)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;\n  }\n  getItem(key) {\n    return this.keyMap.get(key);\n  }\n  at(idx) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n  getTextValue(key) {\n    let row = this.getItem(key);\n    if (!row) return '';\n    // If the row has a textValue, use that.\n    if (row.textValue) return row.textValue;\n    // Otherwise combine the text of each of the row header columns.\n    let rowHeaderColumnKeys = this.rowHeaderColumnKeys;\n    if (rowHeaderColumnKeys) {\n      let text = [];\n      for (let cell of row.childNodes) {\n        let column = this.columns[cell.index];\n        if (rowHeaderColumnKeys.has(column.key) && cell.textValue) text.push(cell.textValue);\n        if (text.length === rowHeaderColumnKeys.size) break;\n      }\n      return text.join(' ');\n    }\n    return '';\n  }\n  constructor(nodes, prev, opts) {\n    let rowHeaderColumnKeys = new Set();\n    let body;\n    let columns = [];\n    // Add cell for selection checkboxes if needed.\n    if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n      let rowHeaderColumn = {\n        type: 'column',\n        key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY,\n        value: null,\n        textValue: '',\n        level: 0,\n        index: (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) ? 1 : 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isSelectionCell: true\n        }\n      };\n      columns.unshift(rowHeaderColumn);\n    }\n    // Add cell for drag buttons if needed.\n    if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) {\n      let rowHeaderColumn = {\n        type: 'column',\n        key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG,\n        value: null,\n        textValue: '',\n        level: 0,\n        index: 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isDragButtonCell: true\n        }\n      };\n      columns.unshift(rowHeaderColumn);\n    }\n    let rows = [];\n    let columnKeyMap = new Map();\n    let visit = node => {\n      switch (node.type) {\n        case 'body':\n          body = node;\n          break;\n        case 'column':\n          columnKeyMap.set(node.key, node);\n          if (!node.hasChildNodes) {\n            columns.push(node);\n            if (node.props.isRowHeader) rowHeaderColumnKeys.add(node.key);\n          }\n          break;\n        case 'item':\n          rows.push(node);\n          return;\n        // do not go into childNodes\n      }\n      for (let child of node.childNodes) visit(child);\n    };\n    for (let node of nodes) visit(node);\n    let headerRows = $788781baa30117fa$export$7c127db850d4e81e(columnKeyMap, columns);\n    headerRows.forEach((row, i) => rows.splice(i, 0, row));\n    super({\n      columnCount: columns.length,\n      items: rows,\n      visitNode: node => {\n        node.column = columns[node.index];\n        return node;\n      }\n    });\n    this._size = 0;\n    this.columns = columns;\n    this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n    this.body = body;\n    this.headerRows = headerRows;\n    this._size = [...body.childNodes].length;\n    // Default row header column to the first one.\n    if (this.rowHeaderColumnKeys.size === 0) this.rowHeaderColumnKeys.add(this.columns.find(column => {\n      var _column_props, _column_props1;\n      return !((_column_props = column.props) === null || _column_props === void 0 ? void 0 : _column_props.isDragButtonCell) && !((_column_props1 = column.props) === null || _column_props1 === void 0 ? void 0 : _column_props1.isSelectionCell);\n    }).key);\n  }\n}\nexport { $788781baa30117fa$export$7c127db850d4e81e as buildHeaderRows, $788781baa30117fa$export$596e1b2e2cf93690 as TableCollection };","map":{"version":3,"mappings":"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","names":["$788781baa30117fa$var$ROW_HEADER_COLUMN_KEY","Math","random","toString","slice","$788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG","$788781baa30117fa$export$7c127db850d4e81e","keyMap","columnNodes","length","columns","seen","Map","column","parentKey","col","parent","get","has","colspan","index","i","splice","push","set","maxLength","max","map","c","headerRows","Array","fill","colIndex","item","row","rowLength","reduce","p","placeholder","type","key","value","rendered","level","hasChildNodes","childNodes","textValue","nextKey","prevKey","$788781baa30117fa$export$596e1b2e2cf93690","Symbol","iterator","body","size","_size","getKeys","keys","getKeyBefore","node","getKeyAfter","getFirstKey","_getFirstItem","getLastKey","_getLastItem","getItem","at","idx","getTextValue","rowHeaderColumnKeys","text","cell","join","constructor","nodes","prev","opts","Set","showSelectionCheckboxes","rowHeaderColumn","showDragButtons","props","isSelectionCell","unshift","isDragButtonCell","rows","columnKeyMap","visit","isRowHeader","add","child","forEach","columnCount","items","visitNode","find","_column_props","_column_props1"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-stately\\table\\dist\\packages\\@react-stately\\table\\src\\TableCollection.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {getFirstItem, getLastItem} from '@react-stately/collections';\nimport {GridCollection} from '@react-stately/grid';\nimport {GridNode} from '@react-types/grid';\nimport {TableCollection as ITableCollection} from '@react-types/table';\nimport {Key} from '@react-types/shared';\n\ninterface GridCollectionOptions {\n  showSelectionCheckboxes?: boolean,\n  showDragButtons?: boolean\n}\n\nconst ROW_HEADER_COLUMN_KEY = 'row-header-column-' + Math.random().toString(36).slice(2);\nlet ROW_HEADER_COLUMN_KEY_DRAG = 'row-header-column-' + Math.random().toString(36).slice(2);\nwhile (ROW_HEADER_COLUMN_KEY === ROW_HEADER_COLUMN_KEY_DRAG) {\n  ROW_HEADER_COLUMN_KEY_DRAG = 'row-header-column-' + Math.random().toString(36).slice(2);\n}\n\n/** @private */\nexport function buildHeaderRows<T>(keyMap: Map<Key, GridNode<T>>, columnNodes: GridNode<T>[]): GridNode<T>[] {\n  if (columnNodes.length === 0) {\n    return [];\n  }\n\n  let columns: GridNode<T>[][] = [];\n  let seen = new Map();\n  for (let column of columnNodes) {\n    let parentKey = column.parentKey;\n    let col = [column];\n\n    while (parentKey) {\n      let parent: GridNode<T> = keyMap.get(parentKey);\n      if (!parent) {\n        break;\n      }\n\n      // If we've already seen this parent, than it is shared\n      // with a previous column. If the current column is taller\n      // than the previous column, than we need to shift the parent\n      // in the previous column so it's level with the current column.\n      if (seen.has(parent)) {\n        parent.colspan++;\n\n        let {column, index} = seen.get(parent);\n        if (index > col.length) {\n          break;\n        }\n\n        for (let i = index; i < col.length; i++) {\n          column.splice(i, 0, null);\n        }\n\n        // Adjust shifted indices\n        for (let i = col.length; i < column.length; i++) {\n          // eslint-disable-next-line max-depth\n          if (column[i] && seen.has(column[i])) {\n            seen.get(column[i]).index = i;\n          }\n        }\n      } else {\n        parent.colspan = 1;\n        col.push(parent);\n        seen.set(parent, {column: col, index: col.length - 1});\n      }\n\n      parentKey = parent.parentKey;\n    }\n\n    columns.push(col);\n    column.index = columns.length - 1;\n  }\n\n  let maxLength = Math.max(...columns.map(c => c.length));\n  let headerRows = Array(maxLength).fill(0).map(() => []);\n\n  // Convert columns into rows.\n  let colIndex = 0;\n  for (let column of columns) {\n    let i = maxLength - 1;\n    for (let item of column) {\n      if (item) {\n        // Fill the space up until the current column with a placeholder\n        let row = headerRows[i];\n        let rowLength = row.reduce((p, c) => p + c.colspan, 0);\n        if (rowLength < colIndex) {\n          let placeholder: GridNode<T> = {\n            type: 'placeholder',\n            key: 'placeholder-' + item.key,\n            colspan: colIndex - rowLength,\n            index: rowLength,\n            value: null,\n            rendered: null,\n            level: i,\n            hasChildNodes: false,\n            childNodes: [],\n            textValue: null\n          };\n\n          // eslint-disable-next-line max-depth\n          if (row.length > 0) {\n            row[row.length - 1].nextKey = placeholder.key;\n            placeholder.prevKey = row[row.length - 1].key;\n          }\n\n          row.push(placeholder);\n        }\n\n        if (row.length > 0) {\n          row[row.length - 1].nextKey = item.key;\n          item.prevKey = row[row.length - 1].key;\n        }\n\n        item.level = i;\n        item.colIndex = colIndex;\n        row.push(item);\n      }\n\n      i--;\n    }\n\n    colIndex++;\n  }\n\n  // Add placeholders at the end of each row that is shorter than the maximum\n  let i = 0;\n  for (let row of headerRows) {\n    let rowLength = row.reduce((p, c) => p + c.colspan, 0);\n    if (rowLength < columnNodes.length) {\n      let placeholder: GridNode<T> = {\n        type: 'placeholder',\n        key: 'placeholder-' + row[row.length - 1].key,\n        colspan: columnNodes.length - rowLength,\n        index: rowLength,\n        value: null,\n        rendered: null,\n        level: i,\n        hasChildNodes: false,\n        childNodes: [],\n        textValue: null,\n        prevKey: row[row.length - 1].key\n      };\n\n      row.push(placeholder);\n    }\n\n    i++;\n  }\n\n  return headerRows.map((childNodes, index) => {\n    let row: GridNode<T> = {\n      type: 'headerrow',\n      key: 'headerrow-' + index,\n      index,\n      value: null,\n      rendered: null,\n      level: 0,\n      hasChildNodes: true,\n      childNodes,\n      textValue: null\n    };\n\n    return row;\n  });\n}\n\nexport class TableCollection<T> extends GridCollection<T> implements ITableCollection<T> {\n  headerRows: GridNode<T>[];\n  columns: GridNode<T>[];\n  rowHeaderColumnKeys: Set<Key>;\n  body: GridNode<T>;\n  _size: number = 0;\n\n  constructor(nodes: Iterable<GridNode<T>>, prev?: ITableCollection<T>, opts?: GridCollectionOptions) {\n    let rowHeaderColumnKeys: Set<Key> = new Set();\n    let body: GridNode<T>;\n    let columns: GridNode<T>[] = [];\n    // Add cell for selection checkboxes if needed.\n    if (opts?.showSelectionCheckboxes) {\n      let rowHeaderColumn: GridNode<T> = {\n        type: 'column',\n        key: ROW_HEADER_COLUMN_KEY,\n        value: null,\n        textValue: '',\n        level: 0,\n        index: opts?.showDragButtons ? 1 : 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isSelectionCell: true\n        }\n      };\n\n      columns.unshift(rowHeaderColumn);\n    }\n\n    // Add cell for drag buttons if needed.\n    if (opts?.showDragButtons) {\n      let rowHeaderColumn: GridNode<T> = {\n        type: 'column',\n        key: ROW_HEADER_COLUMN_KEY_DRAG,\n        value: null,\n        textValue: '',\n        level: 0,\n        index: 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isDragButtonCell: true\n        }\n      };\n\n      columns.unshift(rowHeaderColumn);\n    }\n\n    let rows = [];\n    let columnKeyMap = new Map();\n    let visit = (node: GridNode<T>) => {\n      switch (node.type) {\n        case 'body':\n          body = node;\n          break;\n        case 'column':\n          columnKeyMap.set(node.key, node);\n          if (!node.hasChildNodes) {\n            columns.push(node);\n\n            if (node.props.isRowHeader) {\n              rowHeaderColumnKeys.add(node.key);\n            }\n          }\n          break;\n        case 'item':\n          rows.push(node);\n          return; // do not go into childNodes\n      }\n      for (let child of node.childNodes) {\n        visit(child);\n      }\n    };\n\n    for (let node of nodes) {\n      visit(node);\n    }\n\n    let headerRows = buildHeaderRows(columnKeyMap, columns) as GridNode<T>[];\n    headerRows.forEach((row, i) => rows.splice(i, 0, row));\n\n    super({\n      columnCount: columns.length,\n      items: rows,\n      visitNode: node => {\n        node.column = columns[node.index];\n        return node;\n      }\n    });\n    this.columns = columns;\n    this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n    this.body = body;\n    this.headerRows = headerRows;\n    this._size = [...body.childNodes].length;\n\n    // Default row header column to the first one.\n    if (this.rowHeaderColumnKeys.size === 0) {\n      this.rowHeaderColumnKeys.add(this.columns.find(column => !column.props?.isDragButtonCell && !column.props?.isSelectionCell).key);\n    }\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.body.childNodes;\n  }\n\n  get size() {\n    return this._size;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return getFirstItem(this.body.childNodes)?.key;\n  }\n\n  getLastKey() {\n    return getLastItem(this.body.childNodes)?.key;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n\n  getTextValue(key: Key): string {\n    let row = this.getItem(key);\n    if (!row) {\n      return '';\n    }\n\n    // If the row has a textValue, use that.\n    if (row.textValue) {\n      return row.textValue;\n    }\n\n    // Otherwise combine the text of each of the row header columns.\n    let rowHeaderColumnKeys = this.rowHeaderColumnKeys;\n    if (rowHeaderColumnKeys) {\n      let text = [];\n      for (let cell of row.childNodes) {\n        let column = this.columns[cell.index];\n        if (rowHeaderColumnKeys.has(column.key) && cell.textValue) {\n          text.push(cell.textValue);\n        }\n\n        if (text.length === rowHeaderColumnKeys.size) {\n          break;\n        }\n      }\n\n      return text.join(' ');\n    }\n\n    return '';\n  }\n}\n"]},"metadata":{},"sourceType":"module"}