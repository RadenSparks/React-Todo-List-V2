{"ast":null,"code":"import { gridMap as $1af922eb41e03c8f$export$e6235c0d09b995d0 } from \"./utils.mjs\";\nimport { getFocusableTreeWalker as $j4Qbl$getFocusableTreeWalker, focusSafely as $j4Qbl$focusSafely } from \"@react-aria/focus\";\nimport { scrollIntoViewport as $j4Qbl$scrollIntoViewport, getScrollParent as $j4Qbl$getScrollParent, mergeProps as $j4Qbl$mergeProps } from \"@react-aria/utils\";\nimport { isFocusVisible as $j4Qbl$isFocusVisible } from \"@react-aria/interactions\";\nimport { useRef as $j4Qbl$useRef } from \"react\";\nimport { useLocale as $j4Qbl$useLocale } from \"@react-aria/i18n\";\nimport { useSelectableItem as $j4Qbl$useSelectableItem } from \"@react-aria/selection\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c(props, state, ref) {\n  let {\n    node: node,\n    isVirtualized: isVirtualized,\n    focusMode = 'child',\n    shouldSelectOnPressUp: shouldSelectOnPressUp,\n    onAction: onAction\n  } = props;\n  let {\n    direction: direction\n  } = (0, $j4Qbl$useLocale)();\n  let {\n    keyboardDelegate: keyboardDelegate,\n    actions: {\n      onCellAction: onCellAction\n    }\n  } = (0, $1af922eb41e03c8f$export$e6235c0d09b995d0).get(state);\n  // We need to track the key of the item at the time it was last focused so that we force\n  // focus to go to the item when the DOM node is reused for a different item in a virtualizer.\n  let keyWhenFocused = (0, $j4Qbl$useRef)(null);\n  // Handles focusing the cell. If there is a focusable child,\n  // it is focused, otherwise the cell itself is focused.\n  let focus = () => {\n    let treeWalker = (0, $j4Qbl$getFocusableTreeWalker)(ref.current);\n    if (focusMode === 'child') {\n      // If focus is already on a focusable child within the cell, early return so we don't shift focus\n      if (ref.current.contains(document.activeElement) && ref.current !== document.activeElement) return;\n      let focusable = state.selectionManager.childFocusStrategy === 'last' ? $ab90dcbc1b5466d0$var$last(treeWalker) : treeWalker.firstChild();\n      if (focusable) {\n        (0, $j4Qbl$focusSafely)(focusable);\n        return;\n      }\n    }\n    if (keyWhenFocused.current != null && node.key !== keyWhenFocused.current || !ref.current.contains(document.activeElement)) (0, $j4Qbl$focusSafely)(ref.current);\n  };\n  let {\n    itemProps: itemProps,\n    isPressed: isPressed\n  } = (0, $j4Qbl$useSelectableItem)({\n    selectionManager: state.selectionManager,\n    key: node.key,\n    ref: ref,\n    isVirtualized: isVirtualized,\n    focus: focus,\n    shouldSelectOnPressUp: shouldSelectOnPressUp,\n    onAction: onCellAction ? () => onCellAction(node.key) : onAction,\n    isDisabled: state.collection.size === 0\n  });\n  let onKeyDownCapture = e => {\n    if (!e.currentTarget.contains(e.target) || state.isKeyboardNavigationDisabled) return;\n    let walker = (0, $j4Qbl$getFocusableTreeWalker)(ref.current);\n    walker.currentNode = document.activeElement;\n    switch (e.key) {\n      case 'ArrowLeft':\n        {\n          // Find the next focusable element within the cell.\n          let focusable = direction === 'rtl' ? walker.nextNode() : walker.previousNode();\n          // Don't focus the cell itself if focusMode is \"child\"\n          if (focusMode === 'child' && focusable === ref.current) focusable = null;\n          e.preventDefault();\n          e.stopPropagation();\n          if (focusable) {\n            (0, $j4Qbl$focusSafely)(focusable);\n            (0, $j4Qbl$scrollIntoViewport)(focusable, {\n              containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n            });\n          } else {\n            // If there is no next focusable child, then move to the next cell to the left of this one.\n            // This will be handled by useSelectableCollection. However, if there is no cell to the left\n            // of this one, only one column, and the grid doesn't focus rows, then the next key will be the\n            // same as this one. In that case we need to handle focusing either the cell or the first/last\n            // child, depending on the focus mode.\n            let prev = keyboardDelegate.getKeyLeftOf(node.key);\n            if (prev !== node.key) {\n              // We prevent the capturing event from reaching children of the cell, e.g. pickers.\n              // We want arrow keys to navigate to the next cell instead. We need to re-dispatch\n              // the event from a higher parent so it still bubbles and gets handled by useSelectableCollection.\n              ref.current.parentElement.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));\n              break;\n            }\n            if (focusMode === 'cell' && direction === 'rtl') {\n              (0, $j4Qbl$focusSafely)(ref.current);\n              (0, $j4Qbl$scrollIntoViewport)(ref.current, {\n                containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n              });\n            } else {\n              walker.currentNode = ref.current;\n              focusable = direction === 'rtl' ? walker.firstChild() : $ab90dcbc1b5466d0$var$last(walker);\n              if (focusable) {\n                (0, $j4Qbl$focusSafely)(focusable);\n                (0, $j4Qbl$scrollIntoViewport)(focusable, {\n                  containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n                });\n              }\n            }\n          }\n          break;\n        }\n      case 'ArrowRight':\n        {\n          let focusable = direction === 'rtl' ? walker.previousNode() : walker.nextNode();\n          if (focusMode === 'child' && focusable === ref.current) focusable = null;\n          e.preventDefault();\n          e.stopPropagation();\n          if (focusable) {\n            (0, $j4Qbl$focusSafely)(focusable);\n            (0, $j4Qbl$scrollIntoViewport)(focusable, {\n              containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n            });\n          } else {\n            let next = keyboardDelegate.getKeyRightOf(node.key);\n            if (next !== node.key) {\n              // We prevent the capturing event from reaching children of the cell, e.g. pickers.\n              // We want arrow keys to navigate to the next cell instead. We need to re-dispatch\n              // the event from a higher parent so it still bubbles and gets handled by useSelectableCollection.\n              ref.current.parentElement.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));\n              break;\n            }\n            if (focusMode === 'cell' && direction === 'ltr') {\n              (0, $j4Qbl$focusSafely)(ref.current);\n              (0, $j4Qbl$scrollIntoViewport)(ref.current, {\n                containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n              });\n            } else {\n              walker.currentNode = ref.current;\n              focusable = direction === 'rtl' ? $ab90dcbc1b5466d0$var$last(walker) : walker.firstChild();\n              if (focusable) {\n                (0, $j4Qbl$focusSafely)(focusable);\n                (0, $j4Qbl$scrollIntoViewport)(focusable, {\n                  containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n                });\n              }\n            }\n          }\n          break;\n        }\n      case 'ArrowUp':\n      case 'ArrowDown':\n        // Prevent this event from reaching cell children, e.g. menu buttons. We want arrow keys to navigate\n        // to the cell above/below instead. We need to re-dispatch the event from a higher parent so it still\n        // bubbles and gets handled by useSelectableCollection.\n        if (!e.altKey && ref.current.contains(e.target)) {\n          e.stopPropagation();\n          e.preventDefault();\n          ref.current.parentElement.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));\n        }\n        break;\n    }\n  };\n  // Grid cells can have focusable elements inside them. In this case, focus should\n  // be marshalled to that element rather than focusing the cell itself.\n  let onFocus = e => {\n    keyWhenFocused.current = node.key;\n    if (e.target !== ref.current) {\n      // useSelectableItem only handles setting the focused key when\n      // the focused element is the gridcell itself. We also want to\n      // set the focused key when a child element receives focus.\n      // If focus is currently visible (e.g. the user is navigating with the keyboard),\n      // then skip this. We want to restore focus to the previously focused row/cell\n      // in that case since the table should act like a single tab stop.\n      if (!(0, $j4Qbl$isFocusVisible)()) state.selectionManager.setFocusedKey(node.key);\n      return;\n    }\n    // If the cell itself is focused, wait a frame so that focus finishes propagatating\n    // up to the tree, and move focus to a focusable child if possible.\n    requestAnimationFrame(() => {\n      if (focusMode === 'child' && document.activeElement === ref.current) focus();\n    });\n  };\n  let gridCellProps = (0, $j4Qbl$mergeProps)(itemProps, {\n    role: 'gridcell',\n    onKeyDownCapture: onKeyDownCapture,\n    onFocus: onFocus\n  });\n  var _node_colIndex;\n  if (isVirtualized) gridCellProps['aria-colindex'] = ((_node_colIndex = node.colIndex) !== null && _node_colIndex !== void 0 ? _node_colIndex : node.index) + 1; // aria-colindex is 1-based\n  // When pressing with a pointer and cell selection is not enabled, usePress will be applied to the\n  // row rather than the cell. However, when the row is draggable, usePress cannot preventDefault\n  // on pointer down, so the browser will try to focus the cell which has a tabIndex applied.\n  // To avoid this, remove the tabIndex from the cell briefly on pointer down.\n  if (shouldSelectOnPressUp && gridCellProps.tabIndex != null && gridCellProps.onPointerDown == null) gridCellProps.onPointerDown = e => {\n    let el = e.currentTarget;\n    let tabindex = el.getAttribute('tabindex');\n    el.removeAttribute('tabindex');\n    requestAnimationFrame(() => {\n      el.setAttribute('tabindex', tabindex);\n    });\n  };\n  return {\n    gridCellProps: gridCellProps,\n    isPressed: isPressed\n  };\n}\nfunction $ab90dcbc1b5466d0$var$last(walker) {\n  let next;\n  let last;\n  do {\n    last = walker.lastChild();\n    if (last) next = last;\n  } while (last);\n  return next;\n}\nexport { $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c as useGridCell };","map":{"version":3,"mappings":"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","names":["$ab90dcbc1b5466d0$export$c7e10bfc0c59f67c","props","state","ref","node","isVirtualized","focusMode","shouldSelectOnPressUp","onAction","direction","keyboardDelegate","actions","onCellAction","get","keyWhenFocused","focus","treeWalker","current","contains","document","activeElement","focusable","selectionManager","childFocusStrategy","$ab90dcbc1b5466d0$var$last","firstChild","key","itemProps","isPressed","isDisabled","collection","size","onKeyDownCapture","e","currentTarget","target","isKeyboardNavigationDisabled","walker","currentNode","nextNode","previousNode","preventDefault","stopPropagation","containingElement","prev","getKeyLeftOf","parentElement","dispatchEvent","KeyboardEvent","nativeEvent","type","next","getKeyRightOf","altKey","onFocus","setFocusedKey","requestAnimationFrame","gridCellProps","role","_node_colIndex","colIndex","index","tabIndex","onPointerDown","el","tabindex","getAttribute","removeAttribute","setAttribute","last","lastChild"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-aria\\grid\\dist\\packages\\@react-aria\\grid\\src\\useGridCell.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, FocusableElement, RefObject} from '@react-types/shared';\nimport {focusSafely, getFocusableTreeWalker} from '@react-aria/focus';\nimport {getScrollParent, mergeProps, scrollIntoViewport} from '@react-aria/utils';\nimport {GridCollection, GridNode} from '@react-types/grid';\nimport {gridMap} from './utils';\nimport {GridState} from '@react-stately/grid';\nimport {isFocusVisible} from '@react-aria/interactions';\nimport {KeyboardEvent as ReactKeyboardEvent, useRef} from 'react';\nimport {useLocale} from '@react-aria/i18n';\nimport {useSelectableItem} from '@react-aria/selection';\n\nexport interface GridCellProps {\n  /** An object representing the grid cell. Contains all the relevant information that makes up the grid cell. */\n  node: GridNode<unknown>,\n  /** Whether the grid cell is contained in a virtual scroller. */\n  isVirtualized?: boolean,\n  /** Whether the cell or its first focusable child element should be focused when the grid cell is focused. */\n  focusMode?: 'child' | 'cell',\n  /** Whether selection should occur on press up instead of press down. */\n  shouldSelectOnPressUp?: boolean,\n  /**\n   * Handler that is called when a user performs an action on the cell.\n   * Please use onCellAction at the collection level instead.\n   * @deprecated\n   **/\n  onAction?: () => void\n}\n\nexport interface GridCellAria {\n  /** Props for the grid cell element. */\n  gridCellProps: DOMAttributes,\n  /** Whether the cell is currently in a pressed state. */\n  isPressed: boolean\n}\n\n/**\n * Provides the behavior and accessibility implementation for a cell in a grid.\n * @param props - Props for the cell.\n * @param state - State of the parent grid, as returned by `useGridState`.\n */\nexport function useGridCell<T, C extends GridCollection<T>>(props: GridCellProps, state: GridState<T, C>, ref: RefObject<FocusableElement | null>): GridCellAria {\n  let {\n    node,\n    isVirtualized,\n    focusMode = 'child',\n    shouldSelectOnPressUp,\n    onAction\n  } = props;\n\n  let {direction} = useLocale();\n  let {keyboardDelegate, actions: {onCellAction}} = gridMap.get(state);\n\n  // We need to track the key of the item at the time it was last focused so that we force\n  // focus to go to the item when the DOM node is reused for a different item in a virtualizer.\n  let keyWhenFocused = useRef(null);\n\n  // Handles focusing the cell. If there is a focusable child,\n  // it is focused, otherwise the cell itself is focused.\n  let focus = () => {\n    let treeWalker = getFocusableTreeWalker(ref.current);\n    if (focusMode === 'child') {\n      // If focus is already on a focusable child within the cell, early return so we don't shift focus\n      if (ref.current.contains(document.activeElement) && ref.current !== document.activeElement) {\n        return;\n      }\n\n      let focusable = state.selectionManager.childFocusStrategy === 'last'\n        ? last(treeWalker)\n        : treeWalker.firstChild() as FocusableElement;\n      if (focusable) {\n        focusSafely(focusable);\n        return;\n      }\n    }\n\n    if (\n      (keyWhenFocused.current != null && node.key !== keyWhenFocused.current) ||\n      !ref.current.contains(document.activeElement)\n    ) {\n      focusSafely(ref.current);\n    }\n  };\n\n  let {itemProps, isPressed} = useSelectableItem({\n    selectionManager: state.selectionManager,\n    key: node.key,\n    ref,\n    isVirtualized,\n    focus,\n    shouldSelectOnPressUp,\n    onAction: onCellAction ? () => onCellAction(node.key) : onAction,\n    isDisabled: state.collection.size === 0\n  });\n\n  let onKeyDownCapture = (e: ReactKeyboardEvent) => {\n    if (!e.currentTarget.contains(e.target as Element) || state.isKeyboardNavigationDisabled) {\n      return;\n    }\n\n    let walker = getFocusableTreeWalker(ref.current);\n    walker.currentNode = document.activeElement;\n\n    switch (e.key) {\n      case 'ArrowLeft': {\n        // Find the next focusable element within the cell.\n        let focusable = direction === 'rtl'\n          ? walker.nextNode() as FocusableElement\n          : walker.previousNode() as FocusableElement;\n\n        // Don't focus the cell itself if focusMode is \"child\"\n        if (focusMode === 'child' && focusable === ref.current) {\n          focusable = null;\n        }\n\n        e.preventDefault();\n        e.stopPropagation();\n        if (focusable) {\n          focusSafely(focusable);\n          scrollIntoViewport(focusable, {containingElement: getScrollParent(ref.current)});\n        } else {\n          // If there is no next focusable child, then move to the next cell to the left of this one.\n          // This will be handled by useSelectableCollection. However, if there is no cell to the left\n          // of this one, only one column, and the grid doesn't focus rows, then the next key will be the\n          // same as this one. In that case we need to handle focusing either the cell or the first/last\n          // child, depending on the focus mode.\n          let prev = keyboardDelegate.getKeyLeftOf(node.key);\n          if (prev !== node.key) {\n            // We prevent the capturing event from reaching children of the cell, e.g. pickers.\n            // We want arrow keys to navigate to the next cell instead. We need to re-dispatch\n            // the event from a higher parent so it still bubbles and gets handled by useSelectableCollection.\n            ref.current.parentElement.dispatchEvent(\n              new KeyboardEvent(e.nativeEvent.type, e.nativeEvent)\n            );\n            break;\n          }\n\n          if (focusMode === 'cell' && direction === 'rtl') {\n            focusSafely(ref.current);\n            scrollIntoViewport(ref.current, {containingElement: getScrollParent(ref.current)});\n          } else {\n            walker.currentNode = ref.current;\n            focusable = direction === 'rtl'\n              ? walker.firstChild() as FocusableElement\n              : last(walker);\n            if (focusable) {\n              focusSafely(focusable);\n              scrollIntoViewport(focusable, {containingElement: getScrollParent(ref.current)});\n            }\n          }\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        let focusable = direction === 'rtl'\n          ? walker.previousNode() as FocusableElement\n          : walker.nextNode() as FocusableElement;\n\n        if (focusMode === 'child' && focusable === ref.current) {\n          focusable = null;\n        }\n\n        e.preventDefault();\n        e.stopPropagation();\n        if (focusable) {\n          focusSafely(focusable);\n          scrollIntoViewport(focusable, {containingElement: getScrollParent(ref.current)});\n        } else {\n          let next = keyboardDelegate.getKeyRightOf(node.key);\n          if (next !== node.key) {\n            // We prevent the capturing event from reaching children of the cell, e.g. pickers.\n            // We want arrow keys to navigate to the next cell instead. We need to re-dispatch\n            // the event from a higher parent so it still bubbles and gets handled by useSelectableCollection.\n            ref.current.parentElement.dispatchEvent(\n              new KeyboardEvent(e.nativeEvent.type, e.nativeEvent)\n            );\n            break;\n          }\n\n          if (focusMode === 'cell' && direction === 'ltr') {\n            focusSafely(ref.current);\n            scrollIntoViewport(ref.current, {containingElement: getScrollParent(ref.current)});\n          } else {\n            walker.currentNode = ref.current;\n            focusable = direction === 'rtl'\n              ? last(walker)\n              : walker.firstChild() as FocusableElement;\n            if (focusable) {\n              focusSafely(focusable);\n              scrollIntoViewport(focusable, {containingElement: getScrollParent(ref.current)});\n            }\n          }\n        }\n        break;\n      }\n      case 'ArrowUp':\n      case 'ArrowDown':\n        // Prevent this event from reaching cell children, e.g. menu buttons. We want arrow keys to navigate\n        // to the cell above/below instead. We need to re-dispatch the event from a higher parent so it still\n        // bubbles and gets handled by useSelectableCollection.\n        if (!e.altKey && ref.current.contains(e.target as Element)) {\n          e.stopPropagation();\n          e.preventDefault();\n          ref.current.parentElement.dispatchEvent(\n            new KeyboardEvent(e.nativeEvent.type, e.nativeEvent)\n          );\n        }\n        break;\n    }\n  };\n\n  // Grid cells can have focusable elements inside them. In this case, focus should\n  // be marshalled to that element rather than focusing the cell itself.\n  let onFocus = (e) => {\n    keyWhenFocused.current = node.key;\n    if (e.target !== ref.current) {\n      // useSelectableItem only handles setting the focused key when\n      // the focused element is the gridcell itself. We also want to\n      // set the focused key when a child element receives focus.\n      // If focus is currently visible (e.g. the user is navigating with the keyboard),\n      // then skip this. We want to restore focus to the previously focused row/cell\n      // in that case since the table should act like a single tab stop.\n      if (!isFocusVisible()) {\n        state.selectionManager.setFocusedKey(node.key);\n      }\n      return;\n    }\n\n    // If the cell itself is focused, wait a frame so that focus finishes propagatating\n    // up to the tree, and move focus to a focusable child if possible.\n    requestAnimationFrame(() => {\n      if (focusMode === 'child' && document.activeElement === ref.current) {\n        focus();\n      }\n    });\n  };\n\n  let gridCellProps: DOMAttributes = mergeProps(itemProps, {\n    role: 'gridcell',\n    onKeyDownCapture,\n    onFocus\n  });\n\n  if (isVirtualized) {\n    gridCellProps['aria-colindex'] = (node.colIndex ?? node.index) + 1; // aria-colindex is 1-based\n  }\n\n  // When pressing with a pointer and cell selection is not enabled, usePress will be applied to the\n  // row rather than the cell. However, when the row is draggable, usePress cannot preventDefault\n  // on pointer down, so the browser will try to focus the cell which has a tabIndex applied.\n  // To avoid this, remove the tabIndex from the cell briefly on pointer down.\n  if (shouldSelectOnPressUp && gridCellProps.tabIndex != null && gridCellProps.onPointerDown == null) {\n    gridCellProps.onPointerDown = (e) => {\n      let el = e.currentTarget;\n      let tabindex = el.getAttribute('tabindex');\n      el.removeAttribute('tabindex');\n      requestAnimationFrame(() => {\n        el.setAttribute('tabindex', tabindex);\n      });\n    };\n  }\n\n  return {\n    gridCellProps,\n    isPressed\n  };\n}\n\nfunction last(walker: TreeWalker) {\n  let next: FocusableElement;\n  let last: FocusableElement;\n  do {\n    last = walker.lastChild() as FocusableElement;\n    if (last) {\n      next = last;\n    }\n  } while (last);\n  return next;\n}\n"]},"metadata":{},"sourceType":"module"}