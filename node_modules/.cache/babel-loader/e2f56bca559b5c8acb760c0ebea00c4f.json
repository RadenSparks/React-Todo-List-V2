{"ast":null,"code":"import $dShfP$intlStringsmodulejs from \"./intlStrings.mjs\";\nimport { announce as $dShfP$announce } from \"@react-aria/live-announcer\";\nimport { ariaHideOutside as $dShfP$ariaHideOutside } from \"@react-aria/overlays\";\nimport { listData as $dShfP$listData, getItemId as $dShfP$getItemId } from \"@react-aria/listbox\";\nimport { useRouter as $dShfP$useRouter, chain as $dShfP$chain, useLabels as $dShfP$useLabels, isAppleDevice as $dShfP$isAppleDevice, mergeProps as $dShfP$mergeProps } from \"@react-aria/utils\";\nimport { useMemo as $dShfP$useMemo, useRef as $dShfP$useRef, useEffect as $dShfP$useEffect } from \"react\";\nimport { getChildNodes as $dShfP$getChildNodes, getItemCount as $dShfP$getItemCount } from \"@react-stately/collections\";\nimport { ListKeyboardDelegate as $dShfP$ListKeyboardDelegate, useSelectableCollection as $dShfP$useSelectableCollection } from \"@react-aria/selection\";\nimport { privateValidationStateProp as $dShfP$privateValidationStateProp } from \"@react-stately/form\";\nimport { useLocalizedStringFormatter as $dShfP$useLocalizedStringFormatter } from \"@react-aria/i18n\";\nimport { useMenuTrigger as $dShfP$useMenuTrigger } from \"@react-aria/menu\";\nimport { useTextField as $dShfP$useTextField } from \"@react-aria/textfield\";\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $c350ade66beef0af$export$8c18d1b4f7232bbf(props, state) {\n  let {\n    buttonRef: buttonRef,\n    popoverRef: popoverRef,\n    inputRef: inputRef,\n    listBoxRef: listBoxRef,\n    keyboardDelegate: keyboardDelegate,\n    shouldFocusWrap:\n    // completionMode = 'suggest',\n    shouldFocusWrap,\n    isReadOnly: isReadOnly,\n    isDisabled: isDisabled\n  } = props;\n  let stringFormatter = (0, $dShfP$useLocalizedStringFormatter)((0, $parcel$interopDefault($dShfP$intlStringsmodulejs)), '@react-aria/combobox');\n  let {\n    menuTriggerProps: menuTriggerProps,\n    menuProps: menuProps\n  } = (0, $dShfP$useMenuTrigger)({\n    type: 'listbox',\n    isDisabled: isDisabled || isReadOnly\n  }, state, buttonRef);\n  // Set listbox id so it can be used when calling getItemId later\n  (0, $dShfP$listData).set(state, {\n    id: menuProps.id\n  });\n  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n  let delegate = (0, $dShfP$useMemo)(() => keyboardDelegate || new (0, $dShfP$ListKeyboardDelegate)(state.collection, state.disabledKeys, listBoxRef), [keyboardDelegate, state.collection, state.disabledKeys, listBoxRef]);\n  // Use useSelectableCollection to get the keyboard handlers to apply to the textfield\n  let {\n    collectionProps: collectionProps\n  } = (0, $dShfP$useSelectableCollection)({\n    selectionManager: state.selectionManager,\n    keyboardDelegate: delegate,\n    disallowTypeAhead: true,\n    disallowEmptySelection: true,\n    shouldFocusWrap: shouldFocusWrap,\n    ref: inputRef,\n    // Prevent item scroll behavior from being applied here, should be handled in the user's Popover + ListBox component\n    isVirtualized: true\n  });\n  let router = (0, $dShfP$useRouter)();\n  // For textfield specific keydown operations\n  let onKeyDown = e => {\n    switch (e.key) {\n      case 'Enter':\n      case 'Tab':\n        // Prevent form submission if menu is open since we may be selecting a option\n        if (state.isOpen && e.key === 'Enter') e.preventDefault();\n        // If the focused item is a link, trigger opening it. Items that are links are not selectable.\n        if (state.isOpen && state.selectionManager.focusedKey != null && state.selectionManager.isLink(state.selectionManager.focusedKey)) {\n          if (e.key === 'Enter') {\n            let item = listBoxRef.current.querySelector(`[data-key=\"${CSS.escape(state.selectionManager.focusedKey.toString())}\"]`);\n            if (item instanceof HTMLAnchorElement) {\n              let collectionItem = state.collection.getItem(state.selectionManager.focusedKey);\n              router.open(item, e, collectionItem.props.href, collectionItem.props.routerOptions);\n            }\n          }\n          state.close();\n        } else state.commit();\n        break;\n      case 'Escape':\n        if (state.selectedKey !== null || state.inputValue === '' || props.allowsCustomValue) e.continuePropagation();\n        state.revert();\n        break;\n      case 'ArrowDown':\n        state.open('first', 'manual');\n        break;\n      case 'ArrowUp':\n        state.open('last', 'manual');\n        break;\n      case 'ArrowLeft':\n      case 'ArrowRight':\n        state.selectionManager.setFocusedKey(null);\n        break;\n    }\n  };\n  let onBlur = e => {\n    var _popoverRef_current;\n    let blurFromButton = (buttonRef === null || buttonRef === void 0 ? void 0 : buttonRef.current) && buttonRef.current === e.relatedTarget;\n    let blurIntoPopover = (_popoverRef_current = popoverRef.current) === null || _popoverRef_current === void 0 ? void 0 : _popoverRef_current.contains(e.relatedTarget);\n    // Ignore blur if focused moved to the button(if exists) or into the popover.\n    if (blurFromButton || blurIntoPopover) return;\n    if (props.onBlur) props.onBlur(e);\n    state.setFocused(false);\n  };\n  let onFocus = e => {\n    if (state.isFocused) return;\n    if (props.onFocus) props.onFocus(e);\n    state.setFocused(true);\n  };\n  let {\n    isInvalid: isInvalid,\n    validationErrors: validationErrors,\n    validationDetails: validationDetails\n  } = state.displayValidation;\n  let {\n    labelProps: labelProps,\n    inputProps: inputProps,\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps\n  } = (0, $dShfP$useTextField)({\n    ...props,\n    onChange: state.setInputValue,\n    onKeyDown: !isReadOnly ? (0, $dShfP$chain)(state.isOpen && collectionProps.onKeyDown, onKeyDown, props.onKeyDown) : props.onKeyDown,\n    onBlur: onBlur,\n    value: state.inputValue,\n    onFocus: onFocus,\n    autoComplete: 'off',\n    validate: undefined,\n    [(0, $dShfP$privateValidationStateProp)]: state\n  }, inputRef);\n  // Press handlers for the ComboBox button\n  let onPress = e => {\n    if (e.pointerType === 'touch') {\n      // Focus the input field in case it isn't focused yet\n      inputRef.current.focus();\n      state.toggle(null, 'manual');\n    }\n  };\n  let onPressStart = e => {\n    if (e.pointerType !== 'touch') {\n      inputRef.current.focus();\n      state.toggle(e.pointerType === 'keyboard' || e.pointerType === 'virtual' ? 'first' : null, 'manual');\n    }\n  };\n  let triggerLabelProps = (0, $dShfP$useLabels)({\n    id: menuTriggerProps.id,\n    'aria-label': stringFormatter.format('buttonLabel'),\n    'aria-labelledby': props['aria-labelledby'] || labelProps.id\n  });\n  let listBoxProps = (0, $dShfP$useLabels)({\n    id: menuProps.id,\n    'aria-label': stringFormatter.format('listboxLabel'),\n    'aria-labelledby': props['aria-labelledby'] || labelProps.id\n  });\n  // If a touch happens on direct center of ComboBox input, might be virtual click from iPad so open ComboBox menu\n  let lastEventTime = (0, $dShfP$useRef)(0);\n  let onTouchEnd = e => {\n    if (isDisabled || isReadOnly) return;\n    // Sometimes VoiceOver on iOS fires two touchend events in quick succession. Ignore the second one.\n    if (e.timeStamp - lastEventTime.current < 500) {\n      e.preventDefault();\n      inputRef.current.focus();\n      return;\n    }\n    let rect = e.target.getBoundingClientRect();\n    let touch = e.changedTouches[0];\n    let centerX = Math.ceil(rect.left + .5 * rect.width);\n    let centerY = Math.ceil(rect.top + .5 * rect.height);\n    if (touch.clientX === centerX && touch.clientY === centerY) {\n      e.preventDefault();\n      inputRef.current.focus();\n      state.toggle(null, 'manual');\n      lastEventTime.current = e.timeStamp;\n    }\n  };\n  // VoiceOver has issues with announcing aria-activedescendant properly on change\n  // (especially on iOS). We use a live region announcer to announce focus changes\n  // manually. In addition, section titles are announced when navigating into a new section.\n  let focusedItem = state.selectionManager.focusedKey != null && state.isOpen ? state.collection.getItem(state.selectionManager.focusedKey) : undefined;\n  var _focusedItem_parentKey;\n  let sectionKey = (_focusedItem_parentKey = focusedItem === null || focusedItem === void 0 ? void 0 : focusedItem.parentKey) !== null && _focusedItem_parentKey !== void 0 ? _focusedItem_parentKey : null;\n  var _state_selectionManager_focusedKey;\n  let itemKey = (_state_selectionManager_focusedKey = state.selectionManager.focusedKey) !== null && _state_selectionManager_focusedKey !== void 0 ? _state_selectionManager_focusedKey : null;\n  let lastSection = (0, $dShfP$useRef)(sectionKey);\n  let lastItem = (0, $dShfP$useRef)(itemKey);\n  (0, $dShfP$useEffect)(() => {\n    if ((0, $dShfP$isAppleDevice)() && focusedItem != null && itemKey !== lastItem.current) {\n      let isSelected = state.selectionManager.isSelected(itemKey);\n      let section = sectionKey != null ? state.collection.getItem(sectionKey) : null;\n      let sectionTitle = (section === null || section === void 0 ? void 0 : section['aria-label']) || (typeof (section === null || section === void 0 ? void 0 : section.rendered) === 'string' ? section.rendered : '') || '';\n      let announcement = stringFormatter.format('focusAnnouncement', {\n        isGroupChange: section && sectionKey !== lastSection.current,\n        groupTitle: sectionTitle,\n        groupCount: section ? [...(0, $dShfP$getChildNodes)(section, state.collection)].length : 0,\n        optionText: focusedItem['aria-label'] || focusedItem.textValue || '',\n        isSelected: isSelected\n      });\n      (0, $dShfP$announce)(announcement);\n    }\n    lastSection.current = sectionKey;\n    lastItem.current = itemKey;\n  });\n  // Announce the number of available suggestions when it changes\n  let optionCount = (0, $dShfP$getItemCount)(state.collection);\n  let lastSize = (0, $dShfP$useRef)(optionCount);\n  let lastOpen = (0, $dShfP$useRef)(state.isOpen);\n  (0, $dShfP$useEffect)(() => {\n    // Only announce the number of options available when the menu opens if there is no\n    // focused item, otherwise screen readers will typically read e.g. \"1 of 6\".\n    // The exception is VoiceOver since this isn't included in the message above.\n    let didOpenWithoutFocusedItem = state.isOpen !== lastOpen.current && (state.selectionManager.focusedKey == null || (0, $dShfP$isAppleDevice)());\n    if (state.isOpen && (didOpenWithoutFocusedItem || optionCount !== lastSize.current)) {\n      let announcement = stringFormatter.format('countAnnouncement', {\n        optionCount: optionCount\n      });\n      (0, $dShfP$announce)(announcement);\n    }\n    lastSize.current = optionCount;\n    lastOpen.current = state.isOpen;\n  });\n  // Announce when a selection occurs for VoiceOver. Other screen readers typically do this automatically.\n  let lastSelectedKey = (0, $dShfP$useRef)(state.selectedKey);\n  (0, $dShfP$useEffect)(() => {\n    if ((0, $dShfP$isAppleDevice)() && state.isFocused && state.selectedItem && state.selectedKey !== lastSelectedKey.current) {\n      let optionText = state.selectedItem['aria-label'] || state.selectedItem.textValue || '';\n      let announcement = stringFormatter.format('selectedAnnouncement', {\n        optionText: optionText\n      });\n      (0, $dShfP$announce)(announcement);\n    }\n    lastSelectedKey.current = state.selectedKey;\n  });\n  (0, $dShfP$useEffect)(() => {\n    if (state.isOpen) return (0, $dShfP$ariaHideOutside)([inputRef.current, popoverRef.current]);\n  }, [state.isOpen, inputRef, popoverRef]);\n  return {\n    labelProps: labelProps,\n    buttonProps: {\n      ...menuTriggerProps,\n      ...triggerLabelProps,\n      excludeFromTabOrder: true,\n      onPress: onPress,\n      onPressStart: onPressStart,\n      isDisabled: isDisabled || isReadOnly\n    },\n    inputProps: (0, $dShfP$mergeProps)(inputProps, {\n      role: 'combobox',\n      'aria-expanded': menuTriggerProps['aria-expanded'],\n      'aria-controls': state.isOpen ? menuProps.id : undefined,\n      // TODO: readd proper logic for completionMode = complete (aria-autocomplete: both)\n      'aria-autocomplete': 'list',\n      'aria-activedescendant': focusedItem ? (0, $dShfP$getItemId)(state, focusedItem.key) : undefined,\n      onTouchEnd: onTouchEnd,\n      // This disable's iOS's autocorrect suggestions, since the combo box provides its own suggestions.\n      autoCorrect: 'off',\n      // This disable's the macOS Safari spell check auto corrections.\n      spellCheck: 'false'\n    }),\n    listBoxProps: (0, $dShfP$mergeProps)(menuProps, listBoxProps, {\n      autoFocus: state.focusStrategy,\n      shouldUseVirtualFocus: true,\n      shouldSelectOnPressUp: true,\n      shouldFocusOnHover: true,\n      linkBehavior: 'selection'\n    }),\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps,\n    isInvalid: isInvalid,\n    validationErrors: validationErrors,\n    validationDetails: validationDetails\n  };\n}\nexport { $c350ade66beef0af$export$8c18d1b4f7232bbf as useComboBox };","map":{"version":3,"mappings":"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","names":["$c350ade66beef0af$export$8c18d1b4f7232bbf","props","state","buttonRef","popoverRef","inputRef","listBoxRef","keyboardDelegate","shouldFocusWrap","isReadOnly","isDisabled","stringFormatter","menuTriggerProps","menuProps","type","set","id","delegate","collection","disabledKeys","collectionProps","selectionManager","disallowTypeAhead","disallowEmptySelection","ref","isVirtualized","router","onKeyDown","e","key","isOpen","preventDefault","focusedKey","isLink","item","current","querySelector","CSS","escape","toString","HTMLAnchorElement","collectionItem","getItem","open","href","routerOptions","close","commit","selectedKey","inputValue","allowsCustomValue","continuePropagation","revert","setFocusedKey","onBlur","_popoverRef_current","blurFromButton","relatedTarget","blurIntoPopover","contains","setFocused","onFocus","isFocused","isInvalid","validationErrors","validationDetails","displayValidation","labelProps","inputProps","descriptionProps","errorMessageProps","onChange","setInputValue","value","autoComplete","validate","undefined","onPress","pointerType","focus","toggle","onPressStart","triggerLabelProps","format","listBoxProps","lastEventTime","onTouchEnd","timeStamp","rect","target","getBoundingClientRect","touch","changedTouches","centerX","Math","ceil","left","width","centerY","top","height","clientX","clientY","focusedItem","_focusedItem_parentKey","sectionKey","parentKey","_state_selectionManager_focusedKey","itemKey","lastSection","lastItem","isSelected","section","sectionTitle","rendered","announcement","isGroupChange","groupTitle","groupCount","length","optionText","textValue","optionCount","lastSize","lastOpen","didOpenWithoutFocusedItem","lastSelectedKey","selectedItem","buttonProps","excludeFromTabOrder","role","autoCorrect","spellCheck","autoFocus","focusStrategy","shouldUseVirtualFocus","shouldSelectOnPressUp","shouldFocusOnHover","linkBehavior"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-aria\\combobox\\dist\\packages\\@react-aria\\combobox\\src\\useComboBox.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {announce} from '@react-aria/live-announcer';\nimport {AriaButtonProps} from '@react-types/button';\nimport {AriaComboBoxProps} from '@react-types/combobox';\nimport {ariaHideOutside} from '@react-aria/overlays';\nimport {AriaListBoxOptions, getItemId, listData} from '@react-aria/listbox';\nimport {BaseEvent, DOMAttributes, KeyboardDelegate, PressEvent, RouterOptions, ValidationResult} from '@react-types/shared';\nimport {chain, isAppleDevice, mergeProps, useLabels, useRouter} from '@react-aria/utils';\nimport {ComboBoxState} from '@react-stately/combobox';\nimport {FocusEvent, InputHTMLAttributes, KeyboardEvent, RefObject, TouchEvent, useEffect, useMemo, useRef} from 'react';\nimport {getChildNodes, getItemCount} from '@react-stately/collections';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport {ListKeyboardDelegate, useSelectableCollection} from '@react-aria/selection';\nimport {privateValidationStateProp} from '@react-stately/form';\nimport {useLocalizedStringFormatter} from '@react-aria/i18n';\nimport {useMenuTrigger} from '@react-aria/menu';\nimport {useTextField} from '@react-aria/textfield';\n\nexport interface AriaComboBoxOptions<T> extends Omit<AriaComboBoxProps<T>, 'children'> {\n  /** The ref for the input element. */\n  inputRef: RefObject<HTMLInputElement>,\n  /** The ref for the list box popover. */\n  popoverRef: RefObject<Element>,\n  /** The ref for the list box. */\n  listBoxRef: RefObject<HTMLElement>,\n  /** The ref for the optional list box popup trigger button.  */\n  buttonRef?: RefObject<Element>,\n  /** An optional keyboard delegate implementation, to override the default. */\n  keyboardDelegate?: KeyboardDelegate\n}\n\nexport interface ComboBoxAria<T> extends ValidationResult {\n  /** Props for the label element. */\n  labelProps: DOMAttributes,\n  /** Props for the combo box input element. */\n  inputProps: InputHTMLAttributes<HTMLInputElement>,\n  /** Props for the list box, to be passed to [useListBox](useListBox.html). */\n  listBoxProps: AriaListBoxOptions<T>,\n  /** Props for the optional trigger button, to be passed to [useButton](useButton.html). */\n  buttonProps: AriaButtonProps,\n  /** Props for the combo box description element, if any. */\n  descriptionProps: DOMAttributes,\n  /** Props for the combo box error message element, if any. */\n  errorMessageProps: DOMAttributes\n}\n\n/**\n * Provides the behavior and accessibility implementation for a combo box component.\n * A combo box combines a text input with a listbox, allowing users to filter a list of options to items matching a query.\n * @param props - Props for the combo box.\n * @param state - State for the select, as returned by `useComboBoxState`.\n */\nexport function useComboBox<T>(props: AriaComboBoxOptions<T>, state: ComboBoxState<T>): ComboBoxAria<T> {\n  let {\n    buttonRef,\n    popoverRef,\n    inputRef,\n    listBoxRef,\n    keyboardDelegate,\n    // completionMode = 'suggest',\n    shouldFocusWrap,\n    isReadOnly,\n    isDisabled\n  } = props;\n\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/combobox');\n  let {menuTriggerProps, menuProps} = useMenuTrigger<T>(\n    {\n      type: 'listbox',\n      isDisabled: isDisabled || isReadOnly\n    },\n    state,\n    buttonRef\n  );\n\n  // Set listbox id so it can be used when calling getItemId later\n  listData.set(state, {id: menuProps.id});\n\n  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n  let delegate = useMemo(() =>\n    keyboardDelegate ||\n    new ListKeyboardDelegate(state.collection, state.disabledKeys, listBoxRef)\n  , [keyboardDelegate, state.collection, state.disabledKeys, listBoxRef]);\n\n  // Use useSelectableCollection to get the keyboard handlers to apply to the textfield\n  let {collectionProps} = useSelectableCollection({\n    selectionManager: state.selectionManager,\n    keyboardDelegate: delegate,\n    disallowTypeAhead: true,\n    disallowEmptySelection: true,\n    shouldFocusWrap,\n    ref: inputRef,\n    // Prevent item scroll behavior from being applied here, should be handled in the user's Popover + ListBox component\n    isVirtualized: true\n  });\n\n  let router = useRouter();\n\n  // For textfield specific keydown operations\n  let onKeyDown = (e: BaseEvent<KeyboardEvent<any>>) => {\n    switch (e.key) {\n      case 'Enter':\n      case 'Tab':\n        // Prevent form submission if menu is open since we may be selecting a option\n        if (state.isOpen && e.key === 'Enter') {\n          e.preventDefault();\n        }\n\n        // If the focused item is a link, trigger opening it. Items that are links are not selectable.\n        if (state.isOpen && state.selectionManager.focusedKey != null && state.selectionManager.isLink(state.selectionManager.focusedKey)) {\n          if (e.key === 'Enter') {\n            let item = listBoxRef.current.querySelector(`[data-key=\"${CSS.escape(state.selectionManager.focusedKey.toString())}\"]`);\n            if (item instanceof HTMLAnchorElement) {\n              let collectionItem = state.collection.getItem(state.selectionManager.focusedKey);\n              router.open(item, e, collectionItem.props.href, collectionItem.props.routerOptions as RouterOptions);\n            }\n          }\n\n          state.close();\n        } else {\n          state.commit();\n        }\n        break;\n      case 'Escape':\n        if (\n          state.selectedKey !== null ||\n          state.inputValue === '' ||\n          props.allowsCustomValue\n        ) {\n          e.continuePropagation();\n        }\n        state.revert();\n        break;\n      case 'ArrowDown':\n        state.open('first', 'manual');\n        break;\n      case 'ArrowUp':\n        state.open('last', 'manual');\n        break;\n      case 'ArrowLeft':\n      case 'ArrowRight':\n        state.selectionManager.setFocusedKey(null);\n        break;\n    }\n  };\n\n  let onBlur = (e: FocusEvent<HTMLInputElement>) => {\n    let blurFromButton = buttonRef?.current && buttonRef.current === e.relatedTarget;\n    let blurIntoPopover = popoverRef.current?.contains(e.relatedTarget);\n    // Ignore blur if focused moved to the button(if exists) or into the popover.\n    if (blurFromButton || blurIntoPopover) {\n      return;\n    }\n\n    if (props.onBlur) {\n      props.onBlur(e);\n    }\n\n    state.setFocused(false);\n  };\n\n  let onFocus = (e: FocusEvent<HTMLInputElement>) => {\n    if (state.isFocused) {\n      return;\n    }\n\n    if (props.onFocus) {\n      props.onFocus(e);\n    }\n\n    state.setFocused(true);\n  };\n\n  let {isInvalid, validationErrors, validationDetails} = state.displayValidation;\n  let {labelProps, inputProps, descriptionProps, errorMessageProps} = useTextField({\n    ...props,\n    onChange: state.setInputValue,\n    onKeyDown: !isReadOnly ? chain(state.isOpen && collectionProps.onKeyDown, onKeyDown, props.onKeyDown) : props.onKeyDown,\n    onBlur,\n    value: state.inputValue,\n    onFocus,\n    autoComplete: 'off',\n    validate: undefined,\n    [privateValidationStateProp]: state\n  }, inputRef);\n\n  // Press handlers for the ComboBox button\n  let onPress = (e: PressEvent) => {\n    if (e.pointerType === 'touch') {\n      // Focus the input field in case it isn't focused yet\n      inputRef.current.focus();\n      state.toggle(null, 'manual');\n    }\n  };\n\n  let onPressStart = (e: PressEvent) => {\n    if (e.pointerType !== 'touch') {\n      inputRef.current.focus();\n      state.toggle((e.pointerType === 'keyboard' || e.pointerType === 'virtual') ? 'first' : null, 'manual');\n    }\n  };\n\n  let triggerLabelProps = useLabels({\n    id: menuTriggerProps.id,\n    'aria-label': stringFormatter.format('buttonLabel'),\n    'aria-labelledby': props['aria-labelledby'] || labelProps.id\n  });\n\n  let listBoxProps = useLabels({\n    id: menuProps.id,\n    'aria-label': stringFormatter.format('listboxLabel'),\n    'aria-labelledby': props['aria-labelledby'] || labelProps.id\n  });\n\n  // If a touch happens on direct center of ComboBox input, might be virtual click from iPad so open ComboBox menu\n  let lastEventTime = useRef(0);\n  let onTouchEnd = (e: TouchEvent) => {\n    if (isDisabled || isReadOnly) {\n      return;\n    }\n\n    // Sometimes VoiceOver on iOS fires two touchend events in quick succession. Ignore the second one.\n    if (e.timeStamp - lastEventTime.current < 500) {\n      e.preventDefault();\n      inputRef.current.focus();\n      return;\n    }\n\n    let rect = (e.target as Element).getBoundingClientRect();\n    let touch = e.changedTouches[0];\n\n    let centerX = Math.ceil(rect.left + .5 * rect.width);\n    let centerY = Math.ceil(rect.top + .5 * rect.height);\n\n    if (touch.clientX === centerX && touch.clientY === centerY) {\n      e.preventDefault();\n      inputRef.current.focus();\n      state.toggle(null, 'manual');\n\n      lastEventTime.current = e.timeStamp;\n    }\n  };\n\n  // VoiceOver has issues with announcing aria-activedescendant properly on change\n  // (especially on iOS). We use a live region announcer to announce focus changes\n  // manually. In addition, section titles are announced when navigating into a new section.\n  let focusedItem = state.selectionManager.focusedKey != null && state.isOpen\n    ? state.collection.getItem(state.selectionManager.focusedKey)\n    : undefined;\n  let sectionKey = focusedItem?.parentKey ?? null;\n  let itemKey = state.selectionManager.focusedKey ?? null;\n  let lastSection = useRef(sectionKey);\n  let lastItem = useRef(itemKey);\n  useEffect(() => {\n    if (isAppleDevice() && focusedItem != null && itemKey !== lastItem.current) {\n      let isSelected = state.selectionManager.isSelected(itemKey);\n      let section = sectionKey != null ? state.collection.getItem(sectionKey) : null;\n      let sectionTitle = section?.['aria-label'] || (typeof section?.rendered === 'string' ? section.rendered : '') || '';\n\n      let announcement = stringFormatter.format('focusAnnouncement', {\n        isGroupChange: section && sectionKey !== lastSection.current,\n        groupTitle: sectionTitle,\n        groupCount: section ? [...getChildNodes(section, state.collection)].length : 0,\n        optionText: focusedItem['aria-label'] || focusedItem.textValue || '',\n        isSelected\n      });\n\n      announce(announcement);\n    }\n\n    lastSection.current = sectionKey;\n    lastItem.current = itemKey;\n  });\n\n  // Announce the number of available suggestions when it changes\n  let optionCount = getItemCount(state.collection);\n  let lastSize = useRef(optionCount);\n  let lastOpen = useRef(state.isOpen);\n  useEffect(() => {\n    // Only announce the number of options available when the menu opens if there is no\n    // focused item, otherwise screen readers will typically read e.g. \"1 of 6\".\n    // The exception is VoiceOver since this isn't included in the message above.\n    let didOpenWithoutFocusedItem =\n      state.isOpen !== lastOpen.current &&\n      (state.selectionManager.focusedKey == null || isAppleDevice());\n\n    if (state.isOpen && (didOpenWithoutFocusedItem || optionCount !== lastSize.current)) {\n      let announcement = stringFormatter.format('countAnnouncement', {optionCount});\n      announce(announcement);\n    }\n\n    lastSize.current = optionCount;\n    lastOpen.current = state.isOpen;\n  });\n\n  // Announce when a selection occurs for VoiceOver. Other screen readers typically do this automatically.\n  let lastSelectedKey = useRef(state.selectedKey);\n  useEffect(() => {\n    if (isAppleDevice() && state.isFocused && state.selectedItem && state.selectedKey !== lastSelectedKey.current) {\n      let optionText = state.selectedItem['aria-label'] || state.selectedItem.textValue || '';\n      let announcement = stringFormatter.format('selectedAnnouncement', {optionText});\n      announce(announcement);\n    }\n\n    lastSelectedKey.current = state.selectedKey;\n  });\n\n  useEffect(() => {\n    if (state.isOpen) {\n      return ariaHideOutside([inputRef.current, popoverRef.current]);\n    }\n  }, [state.isOpen, inputRef, popoverRef]);\n\n  return {\n    labelProps,\n    buttonProps: {\n      ...menuTriggerProps,\n      ...triggerLabelProps,\n      excludeFromTabOrder: true,\n      onPress,\n      onPressStart,\n      isDisabled: isDisabled || isReadOnly\n    },\n    inputProps: mergeProps(inputProps, {\n      role: 'combobox',\n      'aria-expanded': menuTriggerProps['aria-expanded'],\n      'aria-controls': state.isOpen ? menuProps.id : undefined,\n      // TODO: readd proper logic for completionMode = complete (aria-autocomplete: both)\n      'aria-autocomplete': 'list',\n      'aria-activedescendant': focusedItem ? getItemId(state, focusedItem.key) : undefined,\n      onTouchEnd,\n      // This disable's iOS's autocorrect suggestions, since the combo box provides its own suggestions.\n      autoCorrect: 'off',\n      // This disable's the macOS Safari spell check auto corrections.\n      spellCheck: 'false'\n    }),\n    listBoxProps: mergeProps(menuProps, listBoxProps, {\n      autoFocus: state.focusStrategy,\n      shouldUseVirtualFocus: true,\n      shouldSelectOnPressUp: true,\n      shouldFocusOnHover: true,\n      linkBehavior: 'selection' as const\n    }),\n    descriptionProps,\n    errorMessageProps,\n    isInvalid,\n    validationErrors,\n    validationDetails\n  };\n}\n"]},"metadata":{},"sourceType":"module"}