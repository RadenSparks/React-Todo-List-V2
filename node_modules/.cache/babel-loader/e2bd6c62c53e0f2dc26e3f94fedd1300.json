{"ast":null,"code":"import { calculateColumnSizes as $6818b1c4fc67028d$export$55d50dc687385491, getMaxWidth as $6818b1c4fc67028d$export$59185c62a7544aa0, getMinWidth as $6818b1c4fc67028d$export$f556054ce4358701, isStatic as $6818b1c4fc67028d$export$1994a077b98ee0d5, parseFractionalUnit as $6818b1c4fc67028d$export$9078bad4c3934604 } from \"./TableUtils.mjs\";\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nclass $a9e7ae544a4e41dd$export$7ff77a162970b30e {\n  /** Takes an array of columns and splits it into 2 maps of columns with controlled and columns with uncontrolled widths. */splitColumnsIntoControlledAndUncontrolled(columns) {\n    return columns.reduce((acc, col) => {\n      if (col.props.width != null) acc[0].set(col.key, col);else acc[1].set(col.key, col);\n      return acc;\n    }, [new Map(), new Map()]);\n  }\n  /** Takes uncontrolled and controlled widths and joins them into a single Map. */\n  recombineColumns(columns, uncontrolledWidths, uncontrolledColumns, controlledColumns) {\n    return new Map(columns.map(col => {\n      if (uncontrolledColumns.has(col.key)) return [col.key, uncontrolledWidths.get(col.key)];else return [col.key, controlledColumns.get(col.key).props.width];\n    }));\n  }\n  /** Used to make an initial Map of the uncontrolled widths based on default widths. */\n  getInitialUncontrolledWidths(uncontrolledColumns) {\n    return new Map(Array.from(uncontrolledColumns).map(_ref2 => {\n      let [key, col] = _ref2;\n      var _this_getDefaultWidth, _this;\n      var _col_props_defaultWidth, _ref;\n      return [key, (_ref = (_col_props_defaultWidth = col.props.defaultWidth) !== null && _col_props_defaultWidth !== void 0 ? _col_props_defaultWidth : (_this_getDefaultWidth = (_this = this).getDefaultWidth) === null || _this_getDefaultWidth === void 0 ? void 0 : _this_getDefaultWidth.call(_this, col)) !== null && _ref !== void 0 ? _ref : '1fr'];\n    }));\n  }\n  getColumnWidth(key) {\n    var _this_columnWidths_get;\n    return (_this_columnWidths_get = this.columnWidths.get(key)) !== null && _this_columnWidths_get !== void 0 ? _this_columnWidths_get : 0;\n  }\n  getColumnMinWidth(key) {\n    var _this_columnMinWidths_get;\n    return (_this_columnMinWidths_get = this.columnMinWidths.get(key)) !== null && _this_columnMinWidths_get !== void 0 ? _this_columnMinWidths_get : 0;\n  }\n  getColumnMaxWidth(key) {\n    var _this_columnMaxWidths_get;\n    return (_this_columnMaxWidths_get = this.columnMaxWidths.get(key)) !== null && _this_columnMaxWidths_get !== void 0 ? _this_columnMaxWidths_get : 0;\n  }\n  resizeColumnWidth(tableWidth, collection, controlledWidths, uncontrolledWidths) {\n    let col = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    let width = arguments.length > 5 ? arguments[5] : undefined;\n    let prevColumnWidths = this.columnWidths;\n    // resizing a column\n    let resizeIndex = Infinity;\n    let resizingChanged = new Map([...controlledWidths, ...uncontrolledWidths]);\n    let percentKeys = new Map();\n    let frKeysToTheRight = new Map();\n    let minWidths = new Map();\n    // freeze columns to the left to their previous pixel value\n    collection.columns.forEach((column, i) => {\n      var _column_props_width_endsWith, _column_props_width;\n      let frKey;\n      let frValue;\n      minWidths.set(column.key, this.getDefaultMinWidth(collection.columns[i]));\n      if (col !== column.key && !column.props.width && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(uncontrolledWidths.get(column.key))) {\n        // uncontrolled don't have props.width for us, so instead get from our state\n        frKey = column.key;\n        frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(uncontrolledWidths.get(column.key));\n      } else if (col !== column.key && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(column.props.width) && !uncontrolledWidths.get(column.key)) {\n        // controlledWidths will be the same in the collection\n        frKey = column.key;\n        frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(column.props.width);\n      } else if (col !== column.key && ((_column_props_width = column.props.width) === null || _column_props_width === void 0 ? void 0 : (_column_props_width_endsWith = _column_props_width.endsWith) === null || _column_props_width_endsWith === void 0 ? void 0 : _column_props_width_endsWith.call(_column_props_width, '%'))) percentKeys.set(column.key, column.props.width);\n      // don't freeze columns to the right of the resizing one\n      if (resizeIndex < i) {\n        if (frKey) frKeysToTheRight.set(frKey, frValue);\n        return;\n      }\n      // we already know the new size of the resizing column\n      if (column.key === col) {\n        resizeIndex = i;\n        resizingChanged.set(column.key, Math.floor(width));\n        return;\n      }\n      // freeze column to previous value\n      resizingChanged.set(column.key, prevColumnWidths.get(column.key));\n    });\n    // predict pixels sizes for all columns based on resize\n    let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map(col => ({\n      ...col.props,\n      key: col.key\n    })), resizingChanged, i => this.getDefaultWidth(collection.columns[i]), i => this.getDefaultMinWidth(collection.columns[i]));\n    // set all new column widths for onResize event\n    // columns going in will be the same order as the columns coming out\n    let newWidths = new Map();\n    // set all column widths based on calculateColumnSize\n    columnWidths.forEach((width, index) => {\n      let key = collection.columns[index].key;\n      newWidths.set(key, width);\n    });\n    // add FR's back as they were to columns to the right\n    Array.from(frKeysToTheRight).forEach(_ref3 => {\n      let [key] = _ref3;\n      newWidths.set(key, `${frKeysToTheRight.get(key)}fr`);\n    });\n    // put back in percents\n    Array.from(percentKeys).forEach(_ref4 => {\n      let [key, width] = _ref4;\n      // resizing locks a column to a px width\n      if (key === col) return;\n      newWidths.set(key, width);\n    });\n    return newWidths;\n  }\n  buildColumnWidths(tableWidth, collection, widths) {\n    this.columnWidths = new Map();\n    this.columnMinWidths = new Map();\n    this.columnMaxWidths = new Map();\n    // initial layout or table/window resizing\n    let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map(col => ({\n      ...col.props,\n      key: col.key\n    })), widths, i => this.getDefaultWidth(collection.columns[i]), i => this.getDefaultMinWidth(collection.columns[i]));\n    // columns going in will be the same order as the columns coming out\n    columnWidths.forEach((width, index) => {\n      let key = collection.columns[index].key;\n      let column = collection.columns[index];\n      this.columnWidths.set(key, width);\n      var _column_props_minWidth;\n      this.columnMinWidths.set(key, (0, $6818b1c4fc67028d$export$f556054ce4358701)((_column_props_minWidth = column.props.minWidth) !== null && _column_props_minWidth !== void 0 ? _column_props_minWidth : this.getDefaultMinWidth(column), tableWidth));\n      this.columnMaxWidths.set(key, (0, $6818b1c4fc67028d$export$59185c62a7544aa0)(column.props.maxWidth, tableWidth));\n    });\n    return this.columnWidths;\n  }\n  constructor(options) {\n    this.columnWidths = new Map();\n    this.columnMinWidths = new Map();\n    this.columnMaxWidths = new Map();\n    var _options_getDefaultWidth;\n    this.getDefaultWidth = (_options_getDefaultWidth = options === null || options === void 0 ? void 0 : options.getDefaultWidth) !== null && _options_getDefaultWidth !== void 0 ? _options_getDefaultWidth : () => '1fr';\n    var _options_getDefaultMinWidth;\n    this.getDefaultMinWidth = (_options_getDefaultMinWidth = options === null || options === void 0 ? void 0 : options.getDefaultMinWidth) !== null && _options_getDefaultMinWidth !== void 0 ? _options_getDefaultMinWidth : () => 75;\n  }\n}\nexport { $a9e7ae544a4e41dd$export$7ff77a162970b30e as TableColumnLayout };","map":{"version":3,"mappings":"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","names":["$a9e7ae544a4e41dd$export$7ff77a162970b30e","splitColumnsIntoControlledAndUncontrolled","columns","reduce","acc","col","props","width","set","key","Map","recombineColumns","uncontrolledWidths","uncontrolledColumns","controlledColumns","map","has","get","getInitialUncontrolledWidths","Array","from","_ref2","_this_getDefaultWidth","_col_props_defaultWidth","defaultWidth","getDefaultWidth","_ref","getColumnWidth","_this_columnWidths_get","columnWidths","getColumnMinWidth","_this_columnMinWidths_get","columnMinWidths","getColumnMaxWidth","_this_columnMaxWidths_get","columnMaxWidths","resizeColumnWidth","tableWidth","collection","controlledWidths","prevColumnWidths","resizeIndex","Infinity","resizingChanged","percentKeys","frKeysToTheRight","minWidths","forEach","column","i","_column_props_width_endsWith","frKey","frValue","getDefaultMinWidth","_column_props_width","endsWith","Math","floor","newWidths","index","_ref3","_ref4","buildColumnWidths","widths","_column_props_minWidth","minWidth","maxWidth","constructor","options","_options_getDefaultWidth","_options_getDefaultMinWidth"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-stately\\table\\dist\\packages\\@react-stately\\table\\src\\TableColumnLayout.ts"],"sourcesContent":["/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n  calculateColumnSizes,\n  getMaxWidth,\n  getMinWidth,\n  isStatic,\n  parseFractionalUnit\n} from './TableUtils';\nimport {ColumnSize, TableCollection} from '@react-types/table';\nimport {GridNode} from '@react-types/grid';\nimport {Key} from '@react-types/shared';\n\nexport interface TableColumnLayoutOptions<T> {\n  getDefaultWidth?: (column: GridNode<T>) => ColumnSize | null | undefined,\n  getDefaultMinWidth?: (column: GridNode<T>) => ColumnSize | null | undefined\n}\n\nexport class TableColumnLayout<T> {\n  getDefaultWidth: (column: GridNode<T>) => ColumnSize | null | undefined;\n  getDefaultMinWidth: (column: GridNode<T>) => ColumnSize | null | undefined;\n  columnWidths: Map<Key, number> = new Map();\n  columnMinWidths: Map<Key, number> = new Map();\n  columnMaxWidths: Map<Key, number> = new Map();\n\n  constructor(options: TableColumnLayoutOptions<T>) {\n    this.getDefaultWidth = options?.getDefaultWidth ?? (() => '1fr');\n    this.getDefaultMinWidth = options?.getDefaultMinWidth ?? (() => 75);\n  }\n\n  /** Takes an array of columns and splits it into 2 maps of columns with controlled and columns with uncontrolled widths. */\n  splitColumnsIntoControlledAndUncontrolled(columns: Array<GridNode<T>>): [Map<Key, GridNode<T>>, Map<Key, GridNode<T>>] {\n    return columns.reduce((acc, col) => {\n      if (col.props.width != null) {\n        acc[0].set(col.key, col);\n      } else {\n        acc[1].set(col.key, col);\n      }\n      return acc;\n    }, [new Map(), new Map()]);\n  }\n\n  /** Takes uncontrolled and controlled widths and joins them into a single Map. */\n  recombineColumns(columns: Array<GridNode<T>>, uncontrolledWidths: Map<Key, ColumnSize>, uncontrolledColumns: Map<Key, GridNode<T>>, controlledColumns: Map<Key, GridNode<T>>): Map<Key, ColumnSize> {\n    return new Map(columns.map(col => {\n      if (uncontrolledColumns.has(col.key)) {\n        return [col.key, uncontrolledWidths.get(col.key)];\n      } else {\n        return [col.key, controlledColumns.get(col.key).props.width];\n      }\n    }));\n  }\n\n  /** Used to make an initial Map of the uncontrolled widths based on default widths. */\n  getInitialUncontrolledWidths(uncontrolledColumns: Map<Key, GridNode<T>>): Map<Key, ColumnSize> {\n    return new Map(Array.from(uncontrolledColumns).map(([key, col]) =>\n      [key, col.props.defaultWidth ?? this.getDefaultWidth?.(col) ?? '1fr']\n    ));\n  }\n\n  getColumnWidth(key: Key): number {\n    return this.columnWidths.get(key) ?? 0;\n  }\n\n  getColumnMinWidth(key: Key): number {\n    return this.columnMinWidths.get(key) ?? 0;\n  }\n\n  getColumnMaxWidth(key: Key): number {\n    return this.columnMaxWidths.get(key) ?? 0;\n  }\n\n  resizeColumnWidth(tableWidth: number, collection: TableCollection<T>, controlledWidths: Map<Key, ColumnSize>, uncontrolledWidths: Map<Key, ColumnSize>, col = null, width: number): Map<Key, ColumnSize> {\n    let prevColumnWidths = this.columnWidths;\n    // resizing a column\n    let resizeIndex = Infinity;\n    let resizingChanged = new Map<Key, ColumnSize>([...controlledWidths, ...uncontrolledWidths]);\n    let percentKeys = new Map();\n    let frKeysToTheRight = new Map();\n    let minWidths = new Map();\n    // freeze columns to the left to their previous pixel value\n    collection.columns.forEach((column, i) => {\n      let frKey;\n      let frValue;\n      minWidths.set(column.key, this.getDefaultMinWidth(collection.columns[i]));\n      if (col !== column.key && !column.props.width && !isStatic(uncontrolledWidths.get(column.key))) {\n        // uncontrolled don't have props.width for us, so instead get from our state\n        frKey = column.key;\n        frValue = parseFractionalUnit(uncontrolledWidths.get(column.key) as string);\n      } else if (col !== column.key && !isStatic(column.props.width) && !uncontrolledWidths.get(column.key)) {\n        // controlledWidths will be the same in the collection\n        frKey = column.key;\n        frValue = parseFractionalUnit(column.props.width);\n      } else if (col !== column.key && column.props.width?.endsWith?.('%')) {\n        percentKeys.set(column.key, column.props.width);\n      }\n      // don't freeze columns to the right of the resizing one\n      if (resizeIndex < i) {\n        if (frKey) {\n          frKeysToTheRight.set(frKey, frValue);\n        }\n        return;\n      }\n      // we already know the new size of the resizing column\n      if (column.key === col) {\n        resizeIndex = i;\n        resizingChanged.set(column.key, Math.floor(width));\n        return;\n      }\n      // freeze column to previous value\n      resizingChanged.set(column.key, prevColumnWidths.get(column.key));\n    });\n\n    // predict pixels sizes for all columns based on resize\n    let columnWidths = calculateColumnSizes(\n      tableWidth,\n      collection.columns.map(col => ({...col.props, key: col.key})),\n      resizingChanged,\n      (i) => this.getDefaultWidth(collection.columns[i]),\n      (i) => this.getDefaultMinWidth(collection.columns[i])\n    );\n\n    // set all new column widths for onResize event\n    // columns going in will be the same order as the columns coming out\n    let newWidths = new Map<Key, ColumnSize>();\n    // set all column widths based on calculateColumnSize\n    columnWidths.forEach((width, index) => {\n      let key = collection.columns[index].key;\n      newWidths.set(key, width);\n    });\n\n    // add FR's back as they were to columns to the right\n    Array.from(frKeysToTheRight).forEach(([key]) => {\n      newWidths.set(key, `${frKeysToTheRight.get(key)}fr`);\n    });\n\n    // put back in percents\n    Array.from(percentKeys).forEach(([key, width]) => {\n      // resizing locks a column to a px width\n      if (key === col) {\n        return;\n      }\n      newWidths.set(key, width);\n    });\n    return newWidths;\n  }\n\n  buildColumnWidths(tableWidth: number, collection: TableCollection<T>, widths: Map<Key, ColumnSize>) {\n    this.columnWidths = new Map();\n    this.columnMinWidths = new Map();\n    this.columnMaxWidths = new Map();\n\n    // initial layout or table/window resizing\n    let columnWidths = calculateColumnSizes(\n      tableWidth,\n      collection.columns.map(col => ({...col.props, key: col.key})),\n      widths,\n      (i) => this.getDefaultWidth(collection.columns[i]),\n      (i) => this.getDefaultMinWidth(collection.columns[i])\n    );\n\n    // columns going in will be the same order as the columns coming out\n    columnWidths.forEach((width, index) => {\n      let key = collection.columns[index].key;\n      let column = collection.columns[index];\n      this.columnWidths.set(key, width);\n      this.columnMinWidths.set(key, getMinWidth(column.props.minWidth ?? this.getDefaultMinWidth(column), tableWidth));\n      this.columnMaxWidths.set(key, getMaxWidth(column.props.maxWidth, tableWidth));\n    });\n    return this.columnWidths;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}