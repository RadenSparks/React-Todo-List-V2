{"ast":null,"code":"import { isScrollable as $eak97$isScrollable } from \"@react-aria/utils\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nclass $2a25aae57d74318e$export$a05409b8bb224a5a {\n  isDisabled(item) {\n    var _item_props;\n    return this.disabledBehavior === 'all' && (((_item_props = item.props) === null || _item_props === void 0 ? void 0 : _item_props.isDisabled) || this.disabledKeys.has(item.key));\n  }\n  getNextKey(key) {\n    key = this.collection.getKeyAfter(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.isDisabled(item)) return key;\n      key = this.collection.getKeyAfter(key);\n    }\n    return null;\n  }\n  getPreviousKey(key) {\n    key = this.collection.getKeyBefore(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.isDisabled(item)) return key;\n      key = this.collection.getKeyBefore(key);\n    }\n    return null;\n  }\n  findKey(key, nextKey, shouldSkip) {\n    let item = this.getItem(key);\n    if (!item) return null;\n    // Find the item above or below in the same column.\n    let prevRect = item.getBoundingClientRect();\n    do {\n      key = nextKey(key);\n      item = this.getItem(key);\n    } while (item && shouldSkip(prevRect, item.getBoundingClientRect()));\n    return key;\n  }\n  isSameRow(prevRect, itemRect) {\n    return prevRect.top === itemRect.top || prevRect.left !== itemRect.left;\n  }\n  isSameColumn(prevRect, itemRect) {\n    return prevRect.left === itemRect.left || prevRect.top !== itemRect.top;\n  }\n  getKeyBelow(key) {\n    if (this.layout === 'grid' && this.orientation === 'vertical') return this.findKey(key, key => this.getNextKey(key), this.isSameRow);else return this.getNextKey(key);\n  }\n  getKeyAbove(key) {\n    if (this.layout === 'grid' && this.orientation === 'vertical') return this.findKey(key, key => this.getPreviousKey(key), this.isSameRow);else return this.getPreviousKey(key);\n  }\n  getNextColumn(key, right) {\n    return right ? this.getPreviousKey(key) : this.getNextKey(key);\n  }\n  getKeyRightOf(key) {\n    if (this.layout === 'grid') {\n      if (this.orientation === 'vertical') return this.getNextColumn(key, this.direction === 'rtl');else return this.findKey(key, key => this.getNextColumn(key, this.direction === 'rtl'), this.isSameColumn);\n    } else if (this.orientation === 'horizontal') return this.getNextColumn(key, this.direction === 'rtl');\n    return null;\n  }\n  getKeyLeftOf(key) {\n    if (this.layout === 'grid') {\n      if (this.orientation === 'vertical') return this.getNextColumn(key, this.direction === 'ltr');else return this.findKey(key, key => this.getNextColumn(key, this.direction === 'ltr'), this.isSameColumn);\n    } else if (this.orientation === 'horizontal') return this.getNextColumn(key, this.direction === 'ltr');\n    return null;\n  }\n  getFirstKey() {\n    let key = this.collection.getFirstKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if ((item === null || item === void 0 ? void 0 : item.type) === 'item' && !this.isDisabled(item)) return key;\n      key = this.collection.getKeyAfter(key);\n    }\n    return null;\n  }\n  getLastKey() {\n    let key = this.collection.getLastKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.isDisabled(item)) return key;\n      key = this.collection.getKeyBefore(key);\n    }\n    return null;\n  }\n  getItem(key) {\n    return key !== null ? this.ref.current.querySelector(`[data-key=\"${CSS.escape(key.toString())}\"]`) : null;\n  }\n  getKeyPageAbove(key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) return null;\n    if (!(0, $eak97$isScrollable)(menu)) return this.getFirstKey();\n    let containerRect = menu.getBoundingClientRect();\n    let itemRect = item.getBoundingClientRect();\n    if (this.orientation === 'horizontal') {\n      let containerX = containerRect.x - menu.scrollLeft;\n      let pageX = Math.max(0, itemRect.x - containerX + itemRect.width - containerRect.width);\n      while (item && itemRect.x - containerX > pageX) {\n        key = this.getKeyAbove(key);\n        item = key == null ? null : this.getItem(key);\n        itemRect = item === null || item === void 0 ? void 0 : item.getBoundingClientRect();\n      }\n    } else {\n      let containerY = containerRect.y - menu.scrollTop;\n      let pageY = Math.max(0, itemRect.y - containerY + itemRect.height - containerRect.height);\n      while (item && itemRect.y - containerY > pageY) {\n        key = this.getKeyAbove(key);\n        item = key == null ? null : this.getItem(key);\n        itemRect = item === null || item === void 0 ? void 0 : item.getBoundingClientRect();\n      }\n    }\n    return key !== null && key !== void 0 ? key : this.getFirstKey();\n  }\n  getKeyPageBelow(key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) return null;\n    if (!(0, $eak97$isScrollable)(menu)) return this.getLastKey();\n    let containerRect = menu.getBoundingClientRect();\n    let itemRect = item.getBoundingClientRect();\n    if (this.orientation === 'horizontal') {\n      let containerX = containerRect.x - menu.scrollLeft;\n      let pageX = Math.min(menu.scrollWidth, itemRect.x - containerX - itemRect.width + containerRect.width);\n      while (item && itemRect.x - containerX < pageX) {\n        key = this.getKeyBelow(key);\n        item = key == null ? null : this.getItem(key);\n        itemRect = item === null || item === void 0 ? void 0 : item.getBoundingClientRect();\n      }\n    } else {\n      let containerY = containerRect.y - menu.scrollTop;\n      let pageY = Math.min(menu.scrollHeight, itemRect.y - containerY - itemRect.height + containerRect.height);\n      while (item && itemRect.y - containerY < pageY) {\n        key = this.getKeyBelow(key);\n        item = key == null ? null : this.getItem(key);\n        itemRect = item === null || item === void 0 ? void 0 : item.getBoundingClientRect();\n      }\n    }\n    return key !== null && key !== void 0 ? key : this.getLastKey();\n  }\n  getKeyForSearch(search, fromKey) {\n    if (!this.collator) return null;\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n      if (item.textValue && this.collator.compare(substring, search) === 0) return key;\n      key = this.getKeyBelow(key);\n    }\n    return null;\n  }\n  constructor() {\n    if (arguments.length === 1) {\n      let opts = arguments.length <= 0 ? undefined : arguments[0];\n      this.collection = opts.collection;\n      this.ref = opts.ref;\n      this.collator = opts.collator;\n      this.disabledKeys = opts.disabledKeys || new Set();\n      this.disabledBehavior = opts.disabledBehavior || 'all';\n      this.orientation = opts.orientation;\n      this.direction = opts.direction;\n      this.layout = opts.layout || 'stack';\n    } else {\n      this.collection = arguments.length <= 0 ? undefined : arguments[0];\n      this.disabledKeys = arguments.length <= 1 ? undefined : arguments[1];\n      this.ref = arguments.length <= 2 ? undefined : arguments[2];\n      this.collator = arguments.length <= 3 ? undefined : arguments[3];\n      this.layout = 'stack';\n      this.orientation = 'vertical';\n      this.disabledBehavior = 'all';\n    }\n    // If this is a vertical stack, remove the left/right methods completely\n    // so they aren't called by useDroppableCollection.\n    if (this.layout === 'stack' && this.orientation === 'vertical') {\n      this.getKeyLeftOf = undefined;\n      this.getKeyRightOf = undefined;\n    }\n  }\n}\nexport { $2a25aae57d74318e$export$a05409b8bb224a5a as ListKeyboardDelegate };","map":{"version":3,"mappings":"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","names":["$2a25aae57d74318e$export$a05409b8bb224a5a","isDisabled","item","_item_props","disabledBehavior","props","disabledKeys","has","key","getNextKey","collection","getKeyAfter","getItem","type","getPreviousKey","getKeyBefore","findKey","nextKey","shouldSkip","prevRect","getBoundingClientRect","isSameRow","itemRect","top","left","isSameColumn","getKeyBelow","layout","orientation","getKeyAbove","getNextColumn","right","getKeyRightOf","direction","getKeyLeftOf","getFirstKey","getLastKey","ref","current","querySelector","CSS","escape","toString","getKeyPageAbove","menu","containerRect","containerX","x","scrollLeft","pageX","Math","max","width","containerY","y","scrollTop","pageY","height","getKeyPageBelow","min","scrollWidth","scrollHeight","getKeyForSearch","search","fromKey","collator","substring","textValue","slice","length","compare","constructor","arguments","opts","Set","undefined"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\ListKeyboardDelegate.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, Direction, DisabledBehavior, Key, KeyboardDelegate, Node, Orientation} from '@react-types/shared';\nimport {isScrollable} from '@react-aria/utils';\nimport {RefObject} from 'react';\n\ninterface ListKeyboardDelegateOptions<T> {\n  collection: Collection<Node<T>>,\n  ref: RefObject<HTMLElement>,\n  collator?: Intl.Collator,\n  layout?: 'stack' | 'grid',\n  orientation?: Orientation,\n  direction?: Direction,\n  disabledKeys?: Set<Key>,\n  disabledBehavior?: DisabledBehavior\n}\n\nexport class ListKeyboardDelegate<T> implements KeyboardDelegate {\n  private collection: Collection<Node<T>>;\n  private disabledKeys: Set<Key>;\n  private disabledBehavior: DisabledBehavior;\n  private ref: RefObject<HTMLElement>;\n  private collator: Intl.Collator | undefined;\n  private layout: 'stack' | 'grid';\n  private orientation?: Orientation;\n  private direction?: Direction;\n\n  constructor(collection: Collection<Node<T>>, disabledKeys: Set<Key>, ref: RefObject<HTMLElement>, collator?: Intl.Collator);\n  constructor(options: ListKeyboardDelegateOptions<T>);\n  constructor(...args: any[]) {\n    if (args.length === 1) {\n      let opts = args[0] as ListKeyboardDelegateOptions<T>;\n      this.collection = opts.collection;\n      this.ref = opts.ref;\n      this.collator = opts.collator;\n      this.disabledKeys = opts.disabledKeys || new Set();\n      this.disabledBehavior = opts.disabledBehavior || 'all';\n      this.orientation = opts.orientation;\n      this.direction = opts.direction;\n      this.layout = opts.layout || 'stack';\n    } else {\n      this.collection = args[0];\n      this.disabledKeys = args[1];\n      this.ref = args[2];\n      this.collator = args[3];\n      this.layout = 'stack';\n      this.orientation = 'vertical';\n      this.disabledBehavior = 'all';\n    }\n\n    // If this is a vertical stack, remove the left/right methods completely\n    // so they aren't called by useDroppableCollection.\n    if (this.layout === 'stack' && this.orientation === 'vertical') {\n      this.getKeyLeftOf = undefined;\n      this.getKeyRightOf = undefined;\n    }\n  }\n\n  private isDisabled(item: Node<unknown>) {\n    return this.disabledBehavior === 'all' && (item.props?.isDisabled || this.disabledKeys.has(item.key));\n  }\n\n  getNextKey(key: Key) {\n    key = this.collection.getKeyAfter(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.isDisabled(item)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n\n    return null;\n  }\n\n  getPreviousKey(key: Key) {\n    key = this.collection.getKeyBefore(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.isDisabled(item)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n\n    return null;\n  }\n\n  private findKey(\n    key: Key,\n    nextKey: (key: Key) => Key,\n    shouldSkip: (prevRect: DOMRect, itemRect: DOMRect) => boolean\n  ) {\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    // Find the item above or below in the same column.\n    let prevRect = item.getBoundingClientRect();\n    do {\n      key = nextKey(key);\n      item = this.getItem(key);\n    } while (item && shouldSkip(prevRect, item.getBoundingClientRect()));\n\n    return key;\n  }\n\n  private isSameRow(prevRect: DOMRect, itemRect: DOMRect) {\n    return prevRect.top === itemRect.top || prevRect.left !== itemRect.left;\n  }\n\n  private isSameColumn(prevRect: DOMRect, itemRect: DOMRect) {\n    return prevRect.left === itemRect.left || prevRect.top !== itemRect.top;\n  }\n\n  getKeyBelow(key: Key) {\n    if (this.layout === 'grid' && this.orientation === 'vertical') {\n      return this.findKey(key, (key) => this.getNextKey(key), this.isSameRow);\n    } else {\n      return this.getNextKey(key);\n    }\n  }\n\n  getKeyAbove(key: Key) {\n    if (this.layout === 'grid' && this.orientation === 'vertical') {\n      return this.findKey(key, (key) => this.getPreviousKey(key), this.isSameRow);\n    } else {\n      return this.getPreviousKey(key);\n    }\n  }\n\n  private getNextColumn(key: Key, right: boolean) {\n    return right ? this.getPreviousKey(key) : this.getNextKey(key);\n  }\n\n  getKeyRightOf(key: Key) {\n    if (this.layout === 'grid') {\n      if (this.orientation === 'vertical') {\n        return this.getNextColumn(key, this.direction === 'rtl');\n      } else {\n        return this.findKey(key, (key) => this.getNextColumn(key, this.direction === 'rtl'), this.isSameColumn);\n      }\n    } else if (this.orientation === 'horizontal') {\n      return this.getNextColumn(key, this.direction === 'rtl');\n    }\n\n    return null;\n  }\n\n  getKeyLeftOf(key: Key) {\n    if (this.layout === 'grid') {\n      if (this.orientation === 'vertical') {\n        return this.getNextColumn(key, this.direction === 'ltr');\n      } else {\n        return this.findKey(key, (key) => this.getNextColumn(key, this.direction === 'ltr'), this.isSameColumn);\n      }\n    } else if (this.orientation === 'horizontal') {\n      return this.getNextColumn(key, this.direction === 'ltr');\n    }\n\n    return null;\n  }\n\n  getFirstKey() {\n    let key = this.collection.getFirstKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item?.type === 'item' && !this.isDisabled(item)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n\n    return null;\n  }\n\n  getLastKey() {\n    let key = this.collection.getLastKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.isDisabled(item)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n\n    return null;\n  }\n\n  private getItem(key: Key): HTMLElement {\n    return key !== null ? this.ref.current.querySelector(`[data-key=\"${CSS.escape(key.toString())}\"]`) : null;\n  }\n\n  getKeyPageAbove(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    if (!isScrollable(menu)) {\n      return this.getFirstKey();\n    }\n\n    let containerRect = menu.getBoundingClientRect();\n    let itemRect = item.getBoundingClientRect();\n    if (this.orientation === 'horizontal') {\n      let containerX = containerRect.x - menu.scrollLeft;\n      let pageX = Math.max(0, (itemRect.x - containerX) + itemRect.width - containerRect.width);\n\n      while (item && (itemRect.x - containerX) > pageX) {\n        key = this.getKeyAbove(key);\n        item = key == null ? null : this.getItem(key);\n        itemRect = item?.getBoundingClientRect();\n      }\n    } else {\n      let containerY = containerRect.y - menu.scrollTop;\n      let pageY = Math.max(0, (itemRect.y - containerY) + itemRect.height - containerRect.height);\n\n      while (item && (itemRect.y - containerY) > pageY) {\n        key = this.getKeyAbove(key);\n        item = key == null ? null : this.getItem(key);\n        itemRect = item?.getBoundingClientRect();\n      }\n    }\n\n    return key ?? this.getFirstKey();\n  }\n\n  getKeyPageBelow(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    if (!isScrollable(menu)) {\n      return this.getLastKey();\n    }\n\n    let containerRect = menu.getBoundingClientRect();\n    let itemRect = item.getBoundingClientRect();\n    if (this.orientation === 'horizontal') {\n      let containerX = containerRect.x - menu.scrollLeft;\n      let pageX = Math.min(menu.scrollWidth, (itemRect.x - containerX) - itemRect.width + containerRect.width);\n\n      while (item && (itemRect.x - containerX) < pageX) {\n        key = this.getKeyBelow(key);\n        item = key == null ? null : this.getItem(key);\n        itemRect = item?.getBoundingClientRect();\n      }\n    } else {\n      let containerY = containerRect.y - menu.scrollTop;\n      let pageY = Math.min(menu.scrollHeight, (itemRect.y - containerY) - itemRect.height + containerRect.height);\n\n      while (item && (itemRect.y - containerY) < pageY) {\n        key = this.getKeyBelow(key);\n        item = key == null ? null : this.getItem(key);\n        itemRect = item?.getBoundingClientRect();\n      }\n    }\n\n    return key ?? this.getLastKey();\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n      if (item.textValue && this.collator.compare(substring, search) === 0) {\n        return key;\n      }\n\n      key = this.getKeyBelow(key);\n    }\n\n    return null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}