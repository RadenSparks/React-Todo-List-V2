{"ast":null,"code":"import { DOMLayoutDelegate as $kbsd1$DOMLayoutDelegate } from \"@react-aria/selection\";\nimport { getNthItem as $kbsd1$getNthItem, getChildNodes as $kbsd1$getChildNodes, getLastItem as $kbsd1$getLastItem, getFirstItem as $kbsd1$getFirstItem } from \"@react-stately/collections\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nclass $d1c300d9c497e402$export$de9feff04fda126e {\n  isCell(node) {\n    return node.type === 'cell';\n  }\n  isRow(node) {\n    return node.type === 'row' || node.type === 'item';\n  }\n  isDisabled(item) {\n    var _item_props;\n    return this.disabledBehavior === 'all' && (((_item_props = item.props) === null || _item_props === void 0 ? void 0 : _item_props.isDisabled) || this.disabledKeys.has(item.key));\n  }\n  findPreviousKey(fromKey, pred) {\n    let key = fromKey != null ? this.collection.getKeyBefore(fromKey) : this.collection.getLastKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (!this.isDisabled(item) && (!pred || pred(item))) return key;\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n  findNextKey(fromKey, pred) {\n    let key = fromKey != null ? this.collection.getKeyAfter(fromKey) : this.collection.getFirstKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (!this.isDisabled(item) && (!pred || pred(item))) return key;\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n  getKeyBelow(key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) return;\n    // If focus was on a cell, start searching from the parent row\n    if (this.isCell(startItem)) key = startItem.parentKey;\n    // Find the next item\n    key = this.findNextKey(key, item => item.type === 'item');\n    if (key != null) {\n      // If focus was on a cell, focus the cell with the same index in the next row.\n      if (this.isCell(startItem)) {\n        let item = this.collection.getItem(key);\n        return (0, $kbsd1$getNthItem)((0, $kbsd1$getChildNodes)(item, this.collection), startItem.index).key;\n      }\n      // Otherwise, focus the next row\n      if (this.focusMode === 'row') return key;\n    }\n  }\n  getKeyAbove(key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) return;\n    // If focus is on a cell, start searching from the parent row\n    if (this.isCell(startItem)) key = startItem.parentKey;\n    // Find the previous item\n    key = this.findPreviousKey(key, item => item.type === 'item');\n    if (key != null) {\n      // If focus was on a cell, focus the cell with the same index in the previous row.\n      if (this.isCell(startItem)) {\n        let item = this.collection.getItem(key);\n        return (0, $kbsd1$getNthItem)((0, $kbsd1$getChildNodes)(item, this.collection), startItem.index).key;\n      }\n      // Otherwise, focus the previous row\n      if (this.focusMode === 'row') return key;\n    }\n  }\n  getKeyRightOf(key) {\n    let item = this.collection.getItem(key);\n    if (!item) return;\n    // If focus is on a row, focus the first child cell.\n    if (this.isRow(item)) {\n      let children = (0, $kbsd1$getChildNodes)(item, this.collection);\n      return this.direction === 'rtl' ? (0, $kbsd1$getLastItem)(children).key : (0, $kbsd1$getFirstItem)(children).key;\n    }\n    // If focus is on a cell, focus the next cell if any,\n    // otherwise focus the parent row.\n    if (this.isCell(item)) {\n      let parent = this.collection.getItem(item.parentKey);\n      let children = (0, $kbsd1$getChildNodes)(parent, this.collection);\n      let next = this.direction === 'rtl' ? (0, $kbsd1$getNthItem)(children, item.index - 1) : (0, $kbsd1$getNthItem)(children, item.index + 1);\n      if (next) return next.key;\n      // focus row only if focusMode is set to row\n      if (this.focusMode === 'row') return item.parentKey;\n      return this.direction === 'rtl' ? this.getFirstKey(key) : this.getLastKey(key);\n    }\n  }\n  getKeyLeftOf(key) {\n    let item = this.collection.getItem(key);\n    if (!item) return;\n    // If focus is on a row, focus the last child cell.\n    if (this.isRow(item)) {\n      let children = (0, $kbsd1$getChildNodes)(item, this.collection);\n      return this.direction === 'rtl' ? (0, $kbsd1$getFirstItem)(children).key : (0, $kbsd1$getLastItem)(children).key;\n    }\n    // If focus is on a cell, focus the previous cell if any,\n    // otherwise focus the parent row.\n    if (this.isCell(item)) {\n      let parent = this.collection.getItem(item.parentKey);\n      let children = (0, $kbsd1$getChildNodes)(parent, this.collection);\n      let prev = this.direction === 'rtl' ? (0, $kbsd1$getNthItem)(children, item.index + 1) : (0, $kbsd1$getNthItem)(children, item.index - 1);\n      if (prev) return prev.key;\n      // focus row only if focusMode is set to row\n      if (this.focusMode === 'row') return item.parentKey;\n      return this.direction === 'rtl' ? this.getLastKey(key) : this.getFirstKey(key);\n    }\n  }\n  getFirstKey(key, global) {\n    let item;\n    if (key != null) {\n      item = this.collection.getItem(key);\n      if (!item) return;\n      // If global flag is not set, and a cell is currently focused,\n      // move focus to the first cell in the parent row.\n      if (this.isCell(item) && !global) {\n        let parent = this.collection.getItem(item.parentKey);\n        return (0, $kbsd1$getFirstItem)((0, $kbsd1$getChildNodes)(parent, this.collection)).key;\n      }\n    }\n    // Find the first row\n    key = this.findNextKey(null, item => item.type === 'item');\n    // If global flag is set (or if focus mode is cell), focus the first cell in the first row.\n    if (key != null && item && this.isCell(item) && global || this.focusMode === 'cell') {\n      let item = this.collection.getItem(key);\n      key = (0, $kbsd1$getFirstItem)((0, $kbsd1$getChildNodes)(item, this.collection)).key;\n    }\n    // Otherwise, focus the row itself.\n    return key;\n  }\n  getLastKey(key, global) {\n    let item;\n    if (key != null) {\n      item = this.collection.getItem(key);\n      if (!item) return;\n      // If global flag is not set, and a cell is currently focused,\n      // move focus to the last cell in the parent row.\n      if (this.isCell(item) && !global) {\n        let parent = this.collection.getItem(item.parentKey);\n        let children = (0, $kbsd1$getChildNodes)(parent, this.collection);\n        return (0, $kbsd1$getLastItem)(children).key;\n      }\n    }\n    // Find the last row\n    key = this.findPreviousKey(null, item => item.type === 'item');\n    // If global flag is set (or if focus mode is cell), focus the last cell in the last row.\n    if (key != null && item && this.isCell(item) && global || this.focusMode === 'cell') {\n      let item = this.collection.getItem(key);\n      let children = (0, $kbsd1$getChildNodes)(item, this.collection);\n      key = (0, $kbsd1$getLastItem)(children).key;\n    }\n    // Otherwise, focus the row itself.\n    return key;\n  }\n  getKeyPageAbove(key) {\n    let itemRect = this.layoutDelegate.getItemRect(key);\n    if (!itemRect) return null;\n    let pageY = Math.max(0, itemRect.y + itemRect.height - this.layoutDelegate.getVisibleRect().height);\n    while (itemRect && itemRect.y > pageY) {\n      key = this.getKeyAbove(key);\n      itemRect = this.layoutDelegate.getItemRect(key);\n    }\n    return key;\n  }\n  getKeyPageBelow(key) {\n    let itemRect = this.layoutDelegate.getItemRect(key);\n    if (!itemRect) return null;\n    let pageHeight = this.layoutDelegate.getVisibleRect().height;\n    let pageY = Math.min(this.layoutDelegate.getContentSize().height, itemRect.y + pageHeight);\n    while (itemRect && itemRect.y + itemRect.height < pageY) {\n      let nextKey = this.getKeyBelow(key);\n      // If nextKey is undefined, we've reached the last row already\n      if (nextKey == null) break;\n      itemRect = this.layoutDelegate.getItemRect(nextKey);\n      key = nextKey;\n    }\n    return key;\n  }\n  getKeyForSearch(search, fromKey) {\n    if (!this.collator) return null;\n    let collection = this.collection;\n    let key = fromKey !== null && fromKey !== void 0 ? fromKey : this.getFirstKey();\n    // If the starting key is a cell, search from its parent row.\n    let startItem = collection.getItem(key);\n    if (startItem.type === 'cell') key = startItem.parentKey;\n    let hasWrapped = false;\n    while (key != null) {\n      let item = collection.getItem(key);\n      // check row text value for match\n      if (item.textValue) {\n        let substring = item.textValue.slice(0, search.length);\n        if (this.collator.compare(substring, search) === 0) {\n          if (this.isRow(item) && this.focusMode === 'cell') return (0, $kbsd1$getFirstItem)((0, $kbsd1$getChildNodes)(item, this.collection)).key;\n          return item.key;\n        }\n      }\n      key = this.findNextKey(key, item => item.type === 'item');\n      // Wrap around when reaching the end of the collection\n      if (key == null && !hasWrapped) {\n        key = this.getFirstKey();\n        hasWrapped = true;\n      }\n    }\n    return null;\n  }\n  constructor(options) {\n    this.collection = options.collection;\n    this.disabledKeys = options.disabledKeys;\n    this.disabledBehavior = options.disabledBehavior || 'all';\n    this.direction = options.direction;\n    this.collator = options.collator;\n    this.layoutDelegate = options.layoutDelegate || (options.layout ? new $d1c300d9c497e402$var$DeprecatedLayoutDelegate(options.layout) : new (0, $kbsd1$DOMLayoutDelegate)(options.ref));\n    this.focusMode = options.focusMode || 'row';\n  }\n}\nclass $d1c300d9c497e402$var$DeprecatedLayoutDelegate {\n  getContentSize() {\n    return this.layout.getContentSize();\n  }\n  getItemRect(key) {\n    var _this_layout_getLayoutInfo;\n    return ((_this_layout_getLayoutInfo = this.layout.getLayoutInfo(key)) === null || _this_layout_getLayoutInfo === void 0 ? void 0 : _this_layout_getLayoutInfo.rect) || null;\n  }\n  getVisibleRect() {\n    return this.layout.virtualizer.visibleRect;\n  }\n  constructor(layout) {\n    this.layout = layout;\n  }\n}\nexport { $d1c300d9c497e402$export$de9feff04fda126e as GridKeyboardDelegate };","map":{"version":3,"mappings":"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","names":["$d1c300d9c497e402$export$de9feff04fda126e","isCell","node","type","isRow","isDisabled","item","_item_props","disabledBehavior","props","disabledKeys","has","key","findPreviousKey","fromKey","pred","collection","getKeyBefore","getLastKey","getItem","findNextKey","getKeyAfter","getFirstKey","getKeyBelow","startItem","parentKey","index","focusMode","getKeyAbove","getKeyRightOf","children","direction","parent","next","getKeyLeftOf","prev","global","getKeyPageAbove","itemRect","layoutDelegate","getItemRect","pageY","Math","max","y","height","getVisibleRect","getKeyPageBelow","pageHeight","min","getContentSize","nextKey","getKeyForSearch","search","collator","hasWrapped","textValue","substring","slice","length","compare","constructor","options","layout","$d1c300d9c497e402$var$DeprecatedLayoutDelegate","ref","_this_layout_getLayoutInfo","getLayoutInfo","rect","virtualizer","visibleRect"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-aria\\grid\\dist\\packages\\@react-aria\\grid\\src\\GridKeyboardDelegate.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Direction, DisabledBehavior, Key, KeyboardDelegate, LayoutDelegate, Node, Rect, RefObject, Size} from '@react-types/shared';\nimport {DOMLayoutDelegate} from '@react-aria/selection';\nimport {getChildNodes, getFirstItem, getLastItem, getNthItem} from '@react-stately/collections';\nimport {GridCollection} from '@react-types/grid';\n\nexport interface GridKeyboardDelegateOptions<C> {\n  collection: C,\n  disabledKeys: Set<Key>,\n  disabledBehavior?: DisabledBehavior,\n  ref?: RefObject<HTMLElement | null>,\n  direction: Direction,\n  collator?: Intl.Collator,\n  layoutDelegate?: LayoutDelegate,\n  /** @deprecated - Use layoutDelegate instead. */\n  layout?: DeprecatedLayout,\n  focusMode?: 'row' | 'cell'\n}\n\nexport class GridKeyboardDelegate<T, C extends GridCollection<T>> implements KeyboardDelegate {\n  collection: C;\n  protected disabledKeys: Set<Key>;\n  protected disabledBehavior: DisabledBehavior;\n  protected direction: Direction;\n  protected collator: Intl.Collator;\n  protected layoutDelegate: LayoutDelegate;\n  protected focusMode;\n\n  constructor(options: GridKeyboardDelegateOptions<C>) {\n    this.collection = options.collection;\n    this.disabledKeys = options.disabledKeys;\n    this.disabledBehavior = options.disabledBehavior || 'all';\n    this.direction = options.direction;\n    this.collator = options.collator;\n    this.layoutDelegate = options.layoutDelegate || (options.layout ? new DeprecatedLayoutDelegate(options.layout) : new DOMLayoutDelegate(options.ref));\n    this.focusMode = options.focusMode || 'row';\n  }\n\n  protected isCell(node: Node<T>) {\n    return node.type === 'cell';\n  }\n\n  protected isRow(node: Node<T>) {\n    return node.type === 'row' || node.type === 'item';\n  }\n\n  private isDisabled(item: Node<unknown>) {\n    return this.disabledBehavior === 'all' && (item.props?.isDisabled || this.disabledKeys.has(item.key));\n  }\n\n  protected findPreviousKey(fromKey?: Key, pred?: (item: Node<T>) => boolean) {\n    let key = fromKey != null\n      ? this.collection.getKeyBefore(fromKey)\n      : this.collection.getLastKey();\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (!this.isDisabled(item) && (!pred || pred(item))) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  protected findNextKey(fromKey?: Key, pred?: (item: Node<T>) => boolean) {\n    let key = fromKey != null\n      ? this.collection.getKeyAfter(fromKey)\n      : this.collection.getFirstKey();\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (!this.isDisabled(item) && (!pred || pred(item))) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyBelow(key: Key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) {\n      return;\n    }\n\n    // If focus was on a cell, start searching from the parent row\n    if (this.isCell(startItem)) {\n      key = startItem.parentKey;\n    }\n\n    // Find the next item\n    key = this.findNextKey(key, (item => item.type === 'item'));\n    if (key != null) {\n      // If focus was on a cell, focus the cell with the same index in the next row.\n      if (this.isCell(startItem)) {\n        let item = this.collection.getItem(key);\n        return getNthItem(getChildNodes(item, this.collection), startItem.index).key;\n      }\n\n      // Otherwise, focus the next row\n      if (this.focusMode === 'row') {\n        return key;\n      }\n    }\n  }\n\n  getKeyAbove(key: Key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) {\n      return;\n    }\n\n    // If focus is on a cell, start searching from the parent row\n    if (this.isCell(startItem)) {\n      key = startItem.parentKey;\n    }\n\n    // Find the previous item\n    key = this.findPreviousKey(key, item => item.type === 'item');\n    if (key != null) {\n      // If focus was on a cell, focus the cell with the same index in the previous row.\n      if (this.isCell(startItem)) {\n        let item = this.collection.getItem(key);\n        return getNthItem(getChildNodes(item, this.collection), startItem.index).key;\n      }\n\n      // Otherwise, focus the previous row\n      if (this.focusMode === 'row') {\n        return key;\n      }\n    }\n  }\n\n  getKeyRightOf(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      return;\n    }\n\n    // If focus is on a row, focus the first child cell.\n    if (this.isRow(item)) {\n      let children = getChildNodes(item, this.collection);\n      return this.direction === 'rtl'\n        ? getLastItem(children).key\n        : getFirstItem(children).key;\n    }\n\n    // If focus is on a cell, focus the next cell if any,\n    // otherwise focus the parent row.\n    if (this.isCell(item)) {\n      let parent = this.collection.getItem(item.parentKey);\n      let children = getChildNodes(parent, this.collection);\n      let next = this.direction === 'rtl'\n        ? getNthItem(children, item.index - 1)\n        : getNthItem(children, item.index + 1);\n\n      if (next) {\n        return next.key;\n      }\n\n      // focus row only if focusMode is set to row\n      if (this.focusMode === 'row') {\n        return item.parentKey;\n      }\n\n      return this.direction === 'rtl' ? this.getFirstKey(key) : this.getLastKey(key);\n    }\n  }\n\n  getKeyLeftOf(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      return;\n    }\n\n    // If focus is on a row, focus the last child cell.\n    if (this.isRow(item)) {\n      let children = getChildNodes(item, this.collection);\n      return this.direction === 'rtl'\n        ? getFirstItem(children).key\n        : getLastItem(children).key;\n    }\n\n    // If focus is on a cell, focus the previous cell if any,\n    // otherwise focus the parent row.\n    if (this.isCell(item)) {\n      let parent = this.collection.getItem(item.parentKey);\n      let children = getChildNodes(parent, this.collection);\n      let prev = this.direction === 'rtl'\n        ? getNthItem(children, item.index + 1)\n        : getNthItem(children, item.index - 1);\n\n      if (prev) {\n        return prev.key;\n      }\n\n      // focus row only if focusMode is set to row\n      if (this.focusMode === 'row') {\n        return item.parentKey;\n      }\n\n      return this.direction === 'rtl' ? this.getLastKey(key) : this.getFirstKey(key);\n    }\n  }\n\n  getFirstKey(key?: Key, global?: boolean) {\n    let item: Node<T>;\n    if (key != null) {\n      item = this.collection.getItem(key);\n      if (!item) {\n        return;\n      }\n\n      // If global flag is not set, and a cell is currently focused,\n      // move focus to the first cell in the parent row.\n      if (this.isCell(item) && !global) {\n        let parent = this.collection.getItem(item.parentKey);\n        return getFirstItem(getChildNodes(parent, this.collection)).key;\n      }\n    }\n\n    // Find the first row\n    key = this.findNextKey(null, item => item.type === 'item');\n\n    // If global flag is set (or if focus mode is cell), focus the first cell in the first row.\n    if ((key != null && item && this.isCell(item) && global) || this.focusMode === 'cell') {\n      let item = this.collection.getItem(key);\n      key = getFirstItem(getChildNodes(item, this.collection)).key;\n    }\n\n    // Otherwise, focus the row itself.\n    return key;\n  }\n\n  getLastKey(key?: Key, global?: boolean) {\n    let item: Node<T>;\n    if (key != null) {\n      item = this.collection.getItem(key);\n      if (!item) {\n        return;\n      }\n\n      // If global flag is not set, and a cell is currently focused,\n      // move focus to the last cell in the parent row.\n      if (this.isCell(item) && !global) {\n        let parent = this.collection.getItem(item.parentKey);\n        let children = getChildNodes(parent, this.collection);\n        return getLastItem(children).key;\n      }\n    }\n\n    // Find the last row\n    key = this.findPreviousKey(null, item => item.type === 'item');\n\n    // If global flag is set (or if focus mode is cell), focus the last cell in the last row.\n    if ((key != null && item && this.isCell(item) && global) || this.focusMode === 'cell') {\n      let item = this.collection.getItem(key);\n      let children = getChildNodes(item, this.collection);\n      key = getLastItem(children).key;\n    }\n\n    // Otherwise, focus the row itself.\n    return key;\n  }\n\n  getKeyPageAbove(key: Key) {\n    let itemRect = this.layoutDelegate.getItemRect(key);\n    if (!itemRect) {\n      return null;\n    }\n\n    let pageY = Math.max(0, itemRect.y + itemRect.height - this.layoutDelegate.getVisibleRect().height);\n\n    while (itemRect && itemRect.y > pageY) {\n      key = this.getKeyAbove(key);\n      itemRect = this.layoutDelegate.getItemRect(key);\n    }\n\n    return key;\n  }\n\n  getKeyPageBelow(key: Key) {\n    let itemRect = this.layoutDelegate.getItemRect(key);\n\n    if (!itemRect) {\n      return null;\n    }\n\n    let pageHeight = this.layoutDelegate.getVisibleRect().height;\n    let pageY = Math.min(this.layoutDelegate.getContentSize().height, itemRect.y + pageHeight);\n\n    while (itemRect && (itemRect.y + itemRect.height) < pageY) {\n      let nextKey = this.getKeyBelow(key);\n      // If nextKey is undefined, we've reached the last row already\n      if (nextKey == null) {\n        break;\n      }\n\n      itemRect = this.layoutDelegate.getItemRect(nextKey);\n      key = nextKey;\n    }\n\n    return key;\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey ?? this.getFirstKey();\n\n    // If the starting key is a cell, search from its parent row.\n    let startItem = collection.getItem(key);\n    if (startItem.type === 'cell') {\n      key = startItem.parentKey;\n    }\n\n    let hasWrapped = false;\n    while (key != null) {\n      let item = collection.getItem(key);\n\n      // check row text value for match\n      if (item.textValue) {\n        let substring = item.textValue.slice(0, search.length);\n        if (this.collator.compare(substring, search) === 0) {\n          if (this.isRow(item) && this.focusMode === 'cell') {\n            return getFirstItem(getChildNodes(item, this.collection)).key;\n          }\n\n          return item.key;\n        }\n      }\n\n      key = this.findNextKey(key, item => item.type === 'item');\n\n      // Wrap around when reaching the end of the collection\n      if (key == null && !hasWrapped) {\n        key = this.getFirstKey();\n        hasWrapped = true;\n      }\n    }\n\n    return null;\n  }\n}\n\n/* Backward compatibility for old Virtualizer Layout interface. */\ninterface DeprecatedLayout {\n  getLayoutInfo(key: Key): DeprecatedLayoutInfo,\n  getContentSize(): Size,\n  virtualizer: DeprecatedVirtualizer\n}\n\ninterface DeprecatedLayoutInfo {\n  rect: Rect\n}\n\ninterface DeprecatedVirtualizer {\n  visibleRect: Rect\n}\n\nclass DeprecatedLayoutDelegate implements LayoutDelegate {\n  layout: DeprecatedLayout;\n\n  constructor(layout: DeprecatedLayout) {\n    this.layout = layout;\n  }\n\n  getContentSize(): Size {\n    return this.layout.getContentSize();\n  }\n\n  getItemRect(key: Key): Rect | null {\n    return this.layout.getLayoutInfo(key)?.rect || null;\n  }\n\n  getVisibleRect(): Rect {\n    return this.layout.virtualizer.visibleRect;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}