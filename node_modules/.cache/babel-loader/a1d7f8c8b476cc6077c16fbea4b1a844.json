{"ast":null,"code":"import { add as $735220c2d4774dd3$export$e16d8520af44a096, addTime as $735220c2d4774dd3$export$7ed87b6bc2506470, addZoned as $735220c2d4774dd3$export$96b1d28349274637, constrain as $735220c2d4774dd3$export$c4e2ecac49351ef2, constrainTime as $735220c2d4774dd3$export$7555de1e070510cb, cycleDate as $735220c2d4774dd3$export$d52ced6badfb9a4c, cycleTime as $735220c2d4774dd3$export$dd02b3e0007dfe28, cycleZoned as $735220c2d4774dd3$export$9a297d111fc86b79, set as $735220c2d4774dd3$export$adaa4cf7ef1b65be, setTime as $735220c2d4774dd3$export$e5d5e1c1822b6e56, setZoned as $735220c2d4774dd3$export$31b5430eb18be4f8, subtract as $735220c2d4774dd3$export$4e2d2ead65e5f7e3, subtractTime as $735220c2d4774dd3$export$fe34d3a381cd7501, subtractZoned as $735220c2d4774dd3$export$6814caac34ca03c7 } from \"./manipulation.mjs\";\nimport { compareDate as $14e0f24ef4ac5c92$export$68781ddf31c0090f, compareTime as $14e0f24ef4ac5c92$export$c19a80a9721b80f6 } from \"./queries.mjs\";\nimport { dateTimeToString as $fae977aafc393c5c$export$4223de14708adc63, dateToString as $fae977aafc393c5c$export$60dfd74aa96791bd, timeToString as $fae977aafc393c5c$export$f59dee82248f5ad4, zonedDateTimeToString as $fae977aafc393c5c$export$bf79f1ebf4b18792 } from \"./string.mjs\";\nimport { GregorianCalendar as $3b62074eb05584b2$export$80ee6245ec4f29ec } from \"./GregorianCalendar.mjs\";\nimport { toCalendarDateTime as $11d87f3f76e88657$export$b21e0b124e224484, toDate as $11d87f3f76e88657$export$e67a095c620b86fe, toZoned as $11d87f3f76e88657$export$84c95a83c799e074, zonedToDate as $11d87f3f76e88657$export$83aac07b4c37b25 } from \"./conversion.mjs\";\nimport { _ as $aksy1$_ } from \"@swc/helpers/_/_class_private_field_init\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $35ea8db9cb2ccb90$var$shiftArgs(args) {\n  let calendar = typeof args[0] === 'object' ? args.shift() : new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)();\n  let era;\n  if (typeof args[0] === 'string') era = args.shift();else {\n    let eras = calendar.getEras();\n    era = eras[eras.length - 1];\n  }\n  let year = args.shift();\n  let month = args.shift();\n  let day = args.shift();\n  return [calendar, era, year, month, day];\n}\nvar\n// This prevents TypeScript from allowing other types with the same fields to match.\n// i.e. a ZonedDateTime should not be be passable to a parameter that expects CalendarDate.\n// If that behavior is desired, use the AnyCalendarDate interface instead.\n// @ts-ignore\n$35ea8db9cb2ccb90$var$_type = /*#__PURE__*/new WeakMap();\nclass $35ea8db9cb2ccb90$export$99faa760c7908e4f {\n  /** Returns a copy of this date. */copy() {\n    if (this.era) return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.era, this.year, this.month, this.day);else return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.year, this.month, this.day);\n  }\n  /** Returns a new `CalendarDate` with the given duration added to it. */\n  add(duration) {\n    return (0, $735220c2d4774dd3$export$e16d8520af44a096)(this, duration);\n  }\n  /** Returns a new `CalendarDate` with the given duration subtracted from it. */\n  subtract(duration) {\n    return (0, $735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);\n  }\n  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */\n  set(fields) {\n    return (0, $735220c2d4774dd3$export$adaa4cf7ef1b65be)(this, fields);\n  }\n  /**\n  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.\n  * When the resulting value reaches the limits of the field, it wraps around.\n  */\n  cycle(field, amount, options) {\n    return (0, $735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);\n  }\n  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */\n  toDate(timeZone) {\n    return (0, $11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone);\n  }\n  /** Converts the date to an ISO 8601 formatted string. */\n  toString() {\n    return (0, $fae977aafc393c5c$export$60dfd74aa96791bd)(this);\n  }\n  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */\n  compare(b) {\n    return (0, $14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b);\n  }\n  constructor() {\n    (0, $aksy1$_)(this, $35ea8db9cb2ccb90$var$_type, {\n      writable: true,\n      value: void 0\n    });\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);\n    this.calendar = calendar;\n    this.era = era;\n    this.year = year;\n    this.month = month;\n    this.day = day;\n    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);\n  }\n}\nvar\n// This prevents TypeScript from allowing other types with the same fields to match.\n// @ts-ignore\n$35ea8db9cb2ccb90$var$_type1 = /*#__PURE__*/new WeakMap();\nclass $35ea8db9cb2ccb90$export$680ea196effce5f {\n  /** Returns a copy of this time. */copy() {\n    return new $35ea8db9cb2ccb90$export$680ea196effce5f(this.hour, this.minute, this.second, this.millisecond);\n  }\n  /** Returns a new `Time` with the given duration added to it. */\n  add(duration) {\n    return (0, $735220c2d4774dd3$export$7ed87b6bc2506470)(this, duration);\n  }\n  /** Returns a new `Time` with the given duration subtracted from it. */\n  subtract(duration) {\n    return (0, $735220c2d4774dd3$export$fe34d3a381cd7501)(this, duration);\n  }\n  /** Returns a new `Time` with the given fields set to the provided values. Other fields will be constrained accordingly. */\n  set(fields) {\n    return (0, $735220c2d4774dd3$export$e5d5e1c1822b6e56)(this, fields);\n  }\n  /**\n  * Returns a new `Time` with the given field adjusted by a specified amount.\n  * When the resulting value reaches the limits of the field, it wraps around.\n  */\n  cycle(field, amount, options) {\n    return (0, $735220c2d4774dd3$export$dd02b3e0007dfe28)(this, field, amount, options);\n  }\n  /** Converts the time to an ISO 8601 formatted string. */\n  toString() {\n    return (0, $fae977aafc393c5c$export$f59dee82248f5ad4)(this);\n  }\n  /** Compares this time with another. A negative result indicates that this time is before the given one, and a positive time indicates that it is after. */\n  compare(b) {\n    return (0, $14e0f24ef4ac5c92$export$c19a80a9721b80f6)(this, b);\n  }\n  constructor() {\n    let hour = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let minute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let second = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let millisecond = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    (0, $aksy1$_)(this, $35ea8db9cb2ccb90$var$_type1, {\n      writable: true,\n      value: void 0\n    });\n    this.hour = hour;\n    this.minute = minute;\n    this.second = second;\n    this.millisecond = millisecond;\n    (0, $735220c2d4774dd3$export$7555de1e070510cb)(this);\n  }\n}\nvar\n// This prevents TypeScript from allowing other types with the same fields to match.\n// @ts-ignore\n$35ea8db9cb2ccb90$var$_type2 = /*#__PURE__*/new WeakMap();\nclass $35ea8db9cb2ccb90$export$ca871e8dbb80966f {\n  /** Returns a copy of this date. */copy() {\n    if (this.era) return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);else return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\n  }\n  /** Returns a new `CalendarDateTime` with the given duration added to it. */\n  add(duration) {\n    return (0, $735220c2d4774dd3$export$e16d8520af44a096)(this, duration);\n  }\n  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */\n  subtract(duration) {\n    return (0, $735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);\n  }\n  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */\n  set(fields) {\n    return (0, $735220c2d4774dd3$export$adaa4cf7ef1b65be)((0, $735220c2d4774dd3$export$e5d5e1c1822b6e56)(this, fields), fields);\n  }\n  /**\n  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.\n  * When the resulting value reaches the limits of the field, it wraps around.\n  */\n  cycle(field, amount, options) {\n    switch (field) {\n      case 'era':\n      case 'year':\n      case 'month':\n      case 'day':\n        return (0, $735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);\n      default:\n        return (0, $735220c2d4774dd3$export$dd02b3e0007dfe28)(this, field, amount, options);\n    }\n  }\n  /** Converts the date to a native JavaScript Date object in the given time zone. */\n  toDate(timeZone, disambiguation) {\n    return (0, $11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone, disambiguation);\n  }\n  /** Converts the date to an ISO 8601 formatted string. */\n  toString() {\n    return (0, $fae977aafc393c5c$export$4223de14708adc63)(this);\n  }\n  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */\n  compare(b) {\n    let res = (0, $14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b);\n    if (res === 0) return (0, $14e0f24ef4ac5c92$export$c19a80a9721b80f6)(this, (0, $11d87f3f76e88657$export$b21e0b124e224484)(b));\n    return res;\n  }\n  constructor() {\n    (0, $aksy1$_)(this, $35ea8db9cb2ccb90$var$_type2, {\n      writable: true,\n      value: void 0\n    });\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);\n    this.calendar = calendar;\n    this.era = era;\n    this.year = year;\n    this.month = month;\n    this.day = day;\n    this.hour = args.shift() || 0;\n    this.minute = args.shift() || 0;\n    this.second = args.shift() || 0;\n    this.millisecond = args.shift() || 0;\n    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);\n  }\n}\nvar\n// This prevents TypeScript from allowing other types with the same fields to match.\n// @ts-ignore\n$35ea8db9cb2ccb90$var$_type3 = /*#__PURE__*/new WeakMap();\nclass $35ea8db9cb2ccb90$export$d3b7288e7994edea {\n  /** Returns a copy of this date. */copy() {\n    if (this.era) return new $35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);else return new $35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);\n  }\n  /** Returns a new `ZonedDateTime` with the given duration added to it. */\n  add(duration) {\n    return (0, $735220c2d4774dd3$export$96b1d28349274637)(this, duration);\n  }\n  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */\n  subtract(duration) {\n    return (0, $735220c2d4774dd3$export$6814caac34ca03c7)(this, duration);\n  }\n  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */\n  set(fields, disambiguation) {\n    return (0, $735220c2d4774dd3$export$31b5430eb18be4f8)(this, fields, disambiguation);\n  }\n  /**\n  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.\n  * When the resulting value reaches the limits of the field, it wraps around.\n  */\n  cycle(field, amount, options) {\n    return (0, $735220c2d4774dd3$export$9a297d111fc86b79)(this, field, amount, options);\n  }\n  /** Converts the date to a native JavaScript Date object. */\n  toDate() {\n    return (0, $11d87f3f76e88657$export$83aac07b4c37b25)(this);\n  }\n  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */\n  toString() {\n    return (0, $fae977aafc393c5c$export$bf79f1ebf4b18792)(this);\n  }\n  /** Converts the date to an ISO 8601 formatted string in UTC. */\n  toAbsoluteString() {\n    return this.toDate().toISOString();\n  }\n  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */\n  compare(b) {\n    // TODO: Is this a bad idea??\n    return this.toDate().getTime() - (0, $11d87f3f76e88657$export$84c95a83c799e074)(b, this.timeZone).toDate().getTime();\n  }\n  constructor() {\n    (0, $aksy1$_)(this, $35ea8db9cb2ccb90$var$_type3, {\n      writable: true,\n      value: void 0\n    });\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);\n    let timeZone = args.shift();\n    let offset = args.shift();\n    this.calendar = calendar;\n    this.era = era;\n    this.year = year;\n    this.month = month;\n    this.day = day;\n    this.timeZone = timeZone;\n    this.offset = offset;\n    this.hour = args.shift() || 0;\n    this.minute = args.shift() || 0;\n    this.second = args.shift() || 0;\n    this.millisecond = args.shift() || 0;\n    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);\n  }\n}\nexport { $35ea8db9cb2ccb90$export$99faa760c7908e4f as CalendarDate, $35ea8db9cb2ccb90$export$680ea196effce5f as Time, $35ea8db9cb2ccb90$export$ca871e8dbb80966f as CalendarDateTime, $35ea8db9cb2ccb90$export$d3b7288e7994edea as ZonedDateTime };","map":{"version":3,"mappings":"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","names":["$35ea8db9cb2ccb90$var$shiftArgs","args","calendar","shift","era","eras","getEras","length","year","month","day","$35ea8db9cb2ccb90$var$_type","$35ea8db9cb2ccb90$export$99faa760c7908e4f","copy","add","duration","subtract","set","fields","cycle","field","amount","options","toDate","timeZone","toString","compare","b","constructor","$35ea8db9cb2ccb90$var$_type1","$35ea8db9cb2ccb90$export$680ea196effce5f","hour","minute","second","millisecond","$35ea8db9cb2ccb90$var$_type2","$35ea8db9cb2ccb90$export$ca871e8dbb80966f","disambiguation","res","$35ea8db9cb2ccb90$var$_type3","$35ea8db9cb2ccb90$export$d3b7288e7994edea","offset","toAbsoluteString","toISOString","getTime"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@internationalized\\date\\dist\\packages\\@internationalized\\date\\src\\CalendarDate.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {add, addTime, addZoned, constrain, constrainTime, cycleDate, cycleTime, cycleZoned, set, setTime, setZoned, subtract, subtractTime, subtractZoned} from './manipulation';\nimport {AnyCalendarDate, AnyTime, Calendar, CycleOptions, CycleTimeOptions, DateDuration, DateField, DateFields, DateTimeDuration, Disambiguation, TimeDuration, TimeField, TimeFields} from './types';\nimport {compareDate, compareTime} from './queries';\nimport {dateTimeToString, dateToString, timeToString, zonedDateTimeToString} from './string';\nimport {GregorianCalendar} from './calendars/GregorianCalendar';\nimport {toCalendarDateTime, toDate, toZoned, zonedToDate} from './conversion';\n\nfunction shiftArgs(args: any[]) {\n  let calendar: Calendar = typeof args[0] === 'object'\n    ? args.shift()\n    : new GregorianCalendar();\n\n  let era: string;\n  if (typeof args[0] === 'string') {\n    era = args.shift();\n  } else {\n    let eras = calendar.getEras();\n    era = eras[eras.length - 1];\n  }\n\n  let year = args.shift();\n  let month = args.shift();\n  let day = args.shift();\n\n  return [calendar, era, year, month, day];\n}\n\n/** A CalendarDate represents a date without any time components in a specific calendar system. */\nexport class CalendarDate {\n  // This prevents TypeScript from allowing other types with the same fields to match.\n  // i.e. a ZonedDateTime should not be be passable to a parameter that expects CalendarDate.\n  // If that behavior is desired, use the AnyCalendarDate interface instead.\n  // @ts-ignore\n  #type;\n  /** The calendar system associated with this date, e.g. Gregorian. */\n  public readonly calendar: Calendar;\n  /** The calendar era for this date, e.g. \"BC\" or \"AD\". */\n  public readonly era: string;\n  /** The year of this date within the era. */\n  public readonly year: number;\n  /**\n   * The month number within the year. Note that some calendar systems such as Hebrew\n   * may have a variable number of months per year. Therefore, month numbers may not\n   * always correspond to the same month names in different years.\n   */\n  public readonly month: number;\n  /** The day number within the month. */\n  public readonly day: number;\n\n  constructor(year: number, month: number, day: number);\n  constructor(era: string, year: number, month: number, day: number);\n  constructor(calendar: Calendar, year: number, month: number, day: number);\n  constructor(calendar: Calendar, era: string, year: number, month: number, day: number);\n  constructor(...args: any[]) {\n    let [calendar, era, year, month, day] = shiftArgs(args);\n    this.calendar = calendar;\n    this.era = era;\n    this.year = year;\n    this.month = month;\n    this.day = day;\n\n    constrain(this);\n  }\n\n  /** Returns a copy of this date. */\n  copy(): CalendarDate {\n    if (this.era) {\n      return new CalendarDate(this.calendar, this.era, this.year, this.month, this.day);\n    } else {\n      return new CalendarDate(this.calendar, this.year, this.month, this.day);\n    }\n  }\n\n  /** Returns a new `CalendarDate` with the given duration added to it. */\n  add(duration: DateDuration): CalendarDate {\n    return add(this, duration);\n  }\n\n  /** Returns a new `CalendarDate` with the given duration subtracted from it. */\n  subtract(duration: DateDuration): CalendarDate {\n    return subtract(this, duration);\n  }\n\n  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */\n  set(fields: DateFields): CalendarDate {\n    return set(this, fields);\n  }\n\n  /**\n   * Returns a new `CalendarDate` with the given field adjusted by a specified amount.\n   * When the resulting value reaches the limits of the field, it wraps around.\n   */\n  cycle(field: DateField, amount: number, options?: CycleOptions): CalendarDate {\n    return cycleDate(this, field, amount, options);\n  }\n\n  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */\n  toDate(timeZone: string): Date {\n    return toDate(this, timeZone);\n  }\n\n  /** Converts the date to an ISO 8601 formatted string. */\n  toString(): string {\n    return dateToString(this);\n  }\n\n  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */\n  compare(b: AnyCalendarDate): number {\n    return compareDate(this, b);\n  }\n}\n\n/** A Time represents a clock time without any date components. */\nexport class Time {\n  // This prevents TypeScript from allowing other types with the same fields to match.\n  // @ts-ignore\n  #type;\n  /** The hour, numbered from 0 to 23. */\n  public readonly hour: number;\n  /** The minute in the hour. */\n  public readonly minute: number;\n  /** The second in the minute. */\n  public readonly second: number;\n  /** The millisecond in the second. */\n  public readonly millisecond: number;\n\n  constructor(\n    hour: number = 0,\n    minute: number = 0,\n    second: number = 0,\n    millisecond: number = 0\n  ) {\n    this.hour = hour;\n    this.minute = minute;\n    this.second = second;\n    this.millisecond = millisecond;\n    constrainTime(this);\n  }\n\n  /** Returns a copy of this time. */\n  copy(): Time {\n    return new Time(this.hour, this.minute, this.second, this.millisecond);\n  }\n\n  /** Returns a new `Time` with the given duration added to it. */\n  add(duration: TimeDuration) {\n    return addTime(this, duration);\n  }\n\n  /** Returns a new `Time` with the given duration subtracted from it. */\n  subtract(duration: TimeDuration) {\n    return subtractTime(this, duration);\n  }\n\n  /** Returns a new `Time` with the given fields set to the provided values. Other fields will be constrained accordingly. */\n  set(fields: TimeFields) {\n    return setTime(this, fields);\n  }\n\n  /**\n   * Returns a new `Time` with the given field adjusted by a specified amount.\n   * When the resulting value reaches the limits of the field, it wraps around.\n   */\n  cycle(field: TimeField, amount: number, options?: CycleTimeOptions) {\n    return cycleTime(this, field, amount, options);\n  }\n\n  /** Converts the time to an ISO 8601 formatted string. */\n  toString() {\n    return timeToString(this);\n  }\n\n  /** Compares this time with another. A negative result indicates that this time is before the given one, and a positive time indicates that it is after. */\n  compare(b: AnyTime) {\n    return compareTime(this, b);\n  }\n}\n\n/** A CalendarDateTime represents a date and time without a time zone, in a specific calendar system. */\nexport class CalendarDateTime {\n  // This prevents TypeScript from allowing other types with the same fields to match.\n  // @ts-ignore\n  #type;\n  /** The calendar system associated with this date, e.g. Gregorian. */\n  public readonly calendar: Calendar;\n  /** The calendar era for this date, e.g. \"BC\" or \"AD\". */\n  public readonly era: string;\n  /** The year of this date within the era. */\n  public readonly year: number;\n  /**\n   * The month number within the year. Note that some calendar systems such as Hebrew\n   * may have a variable number of months per year. Therefore, month numbers may not\n   * always correspond to the same month names in different years.\n   */\n  public readonly month: number;\n  /** The day number within the month. */\n  public readonly day: number;\n  /** The hour in the day, numbered from 0 to 23. */\n  public readonly hour: number;\n  /** The minute in the hour. */\n  public readonly minute: number;\n  /** The second in the minute. */\n  public readonly second: number;\n  /** The millisecond in the second. */\n  public readonly millisecond: number;\n\n  constructor(year: number, month: number, day: number, hour?: number, minute?: number, second?: number, millisecond?: number);\n  constructor(era: string, year: number, month: number, day: number, hour?: number, minute?: number, second?: number, millisecond?: number);\n  constructor(calendar: Calendar, year: number, month: number, day: number, hour?: number, minute?: number, second?: number, millisecond?: number);\n  constructor(calendar: Calendar, era: string, year: number, month: number, day: number, hour?: number, minute?: number, second?: number, millisecond?: number);\n  constructor(...args: any[]) {\n    let [calendar, era, year, month, day] = shiftArgs(args);\n    this.calendar = calendar;\n    this.era = era;\n    this.year = year;\n    this.month = month;\n    this.day = day;\n    this.hour = args.shift() || 0;\n    this.minute = args.shift() || 0;\n    this.second = args.shift() || 0;\n    this.millisecond = args.shift() || 0;\n\n    constrain(this);\n  }\n\n  /** Returns a copy of this date. */\n  copy(): CalendarDateTime {\n    if (this.era) {\n      return new CalendarDateTime(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\n    } else {\n      return new CalendarDateTime(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\n    }\n  }\n\n  /** Returns a new `CalendarDateTime` with the given duration added to it. */\n  add(duration: DateTimeDuration): CalendarDateTime {\n    return add(this, duration);\n  }\n\n  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */\n  subtract(duration: DateTimeDuration): CalendarDateTime {\n    return subtract(this, duration);\n  }\n\n  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */\n  set(fields: DateFields & TimeFields): CalendarDateTime {\n    return set(setTime(this, fields), fields);\n  }\n\n  /**\n   * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.\n   * When the resulting value reaches the limits of the field, it wraps around.\n   */\n  cycle(field: DateField | TimeField, amount: number, options?: CycleTimeOptions): CalendarDateTime {\n    switch (field) {\n      case 'era':\n      case 'year':\n      case 'month':\n      case 'day':\n        return cycleDate(this, field, amount, options);\n      default:\n        return cycleTime(this, field, amount, options);\n    }\n  }\n\n  /** Converts the date to a native JavaScript Date object in the given time zone. */\n  toDate(timeZone: string, disambiguation?: Disambiguation): Date {\n    return toDate(this, timeZone, disambiguation);\n  }\n\n  /** Converts the date to an ISO 8601 formatted string. */\n  toString(): string {\n    return dateTimeToString(this);\n  }\n\n  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */\n  compare(b: CalendarDate | CalendarDateTime | ZonedDateTime): number {\n    let res = compareDate(this, b);\n    if (res === 0) {\n      return compareTime(this, toCalendarDateTime(b));\n    }\n\n    return res;\n  }\n}\n\n/** A ZonedDateTime represents a date and time in a specific time zone and calendar system. */\nexport class ZonedDateTime {\n  // This prevents TypeScript from allowing other types with the same fields to match.\n  // @ts-ignore\n  #type;\n  /** The calendar system associated with this date, e.g. Gregorian. */\n  public readonly calendar: Calendar;\n  /** The calendar era for this date, e.g. \"BC\" or \"AD\". */\n  public readonly era: string;\n  /** The year of this date within the era. */\n  public readonly year: number;\n  /**\n   * The month number within the year. Note that some calendar systems such as Hebrew\n   * may have a variable number of months per year. Therefore, month numbers may not\n   * always correspond to the same month names in different years.\n   */\n  public readonly month: number;\n  /** The day number within the month. */\n  public readonly day: number;\n  /** The hour in the day, numbered from 0 to 23. */\n  public readonly hour: number;\n  /** The minute in the hour. */\n  public readonly minute: number;\n  /** The second in the minute. */\n  public readonly second: number;\n  /** The millisecond in the second. */\n  public readonly millisecond: number;\n  /** The IANA time zone identifier that this date and time is represented in. */\n  public readonly timeZone: string;\n  /** The UTC offset for this time, in milliseconds. */\n  public readonly offset: number;\n\n  constructor(year: number, month: number, day: number, timeZone: string, offset: number, hour?: number, minute?: number, second?: number, millisecond?: number);\n  constructor(era: string, year: number, month: number, day: number, timeZone: string, offset: number, hour?: number, minute?: number, second?: number, millisecond?: number);\n  constructor(calendar: Calendar, year: number, month: number, day: number, timeZone: string, offset: number, hour?: number, minute?: number, second?: number, millisecond?: number);\n  constructor(calendar: Calendar, era: string, year: number, month: number, day: number, timeZone: string, offset: number, hour?: number, minute?: number, second?: number, millisecond?: number);\n  constructor(...args: any[]) {\n    let [calendar, era, year, month, day] = shiftArgs(args);\n    let timeZone = args.shift();\n    let offset = args.shift();\n    this.calendar = calendar;\n    this.era = era;\n    this.year = year;\n    this.month = month;\n    this.day = day;\n    this.timeZone = timeZone;\n    this.offset = offset;\n    this.hour = args.shift() || 0;\n    this.minute = args.shift() || 0;\n    this.second = args.shift() || 0;\n    this.millisecond = args.shift() || 0;\n\n    constrain(this);\n  }\n\n  /** Returns a copy of this date. */\n  copy(): ZonedDateTime {\n    if (this.era) {\n      return new ZonedDateTime(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);\n    } else {\n      return new ZonedDateTime(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);\n    }\n  }\n\n  /** Returns a new `ZonedDateTime` with the given duration added to it. */\n  add(duration: DateTimeDuration) {\n    return addZoned(this, duration);\n  }\n\n  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */\n  subtract(duration: DateTimeDuration) {\n    return subtractZoned(this, duration);\n  }\n\n  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */\n  set(fields: DateFields & TimeFields, disambiguation?: Disambiguation) {\n    return setZoned(this, fields, disambiguation);\n  }\n\n  /**\n   * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.\n   * When the resulting value reaches the limits of the field, it wraps around.\n   */\n  cycle(field: DateField | TimeField, amount: number, options?: CycleTimeOptions) {\n    return cycleZoned(this, field, amount, options);\n  }\n\n  /** Converts the date to a native JavaScript Date object. */\n  toDate() {\n    return zonedToDate(this);\n  }\n\n   /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */\n  toString() {\n    return zonedDateTimeToString(this);\n  }\n\n   /** Converts the date to an ISO 8601 formatted string in UTC. */\n  toAbsoluteString() {\n    return this.toDate().toISOString();\n  }\n\n  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */\n  compare(b: CalendarDate | CalendarDateTime | ZonedDateTime) {\n    // TODO: Is this a bad idea??\n    return this.toDate().getTime() - toZoned(b, this.timeZone).toDate().getTime();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}