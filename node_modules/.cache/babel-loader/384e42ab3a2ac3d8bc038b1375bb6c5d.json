{"ast":null,"code":"import { getChildNodes as $7nPCv$getChildNodes, getLastItem as $7nPCv$getLastItem, getFirstItem as $7nPCv$getFirstItem } from \"@react-stately/collections\";\nimport { useMultipleSelectionState as $7nPCv$useMultipleSelectionState, SelectionManager as $7nPCv$SelectionManager } from \"@react-stately/selection\";\nimport { useMemo as $7nPCv$useMemo, useRef as $7nPCv$useRef, useEffect as $7nPCv$useEffect } from \"react\";\nfunction $62967d126f3aa823$export$4007ac09ff9c68ed(props) {\n  let {\n    collection: collection,\n    focusMode: focusMode\n  } = props;\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  let selectionState = props.UNSAFE_selectionState || (0, $7nPCv$useMultipleSelectionState)(props);\n  let disabledKeys = (0, $7nPCv$useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [props.disabledKeys]);\n  let setFocusedKey = selectionState.setFocusedKey;\n  selectionState.setFocusedKey = (key, child) => {\n    // If focusMode is cell and an item is focused, focus a child cell instead.\n    if (focusMode === 'cell' && key != null) {\n      let item = collection.getItem(key);\n      if ((item === null || item === void 0 ? void 0 : item.type) === 'item') {\n        var _getLastItem, _getFirstItem;\n        let children = (0, $7nPCv$getChildNodes)(item, collection);\n        if (child === 'last') key = (_getLastItem = (0, $7nPCv$getLastItem)(children)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;else key = (_getFirstItem = (0, $7nPCv$getFirstItem)(children)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;\n      }\n    }\n    setFocusedKey(key, child);\n  };\n  let selectionManager = (0, $7nPCv$useMemo)(() => new (0, $7nPCv$SelectionManager)(collection, selectionState), [collection, selectionState]);\n  // Reset focused key if that item is deleted from the collection.\n  const cachedCollection = (0, $7nPCv$useRef)(null);\n  (0, $7nPCv$useEffect)(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      const node = cachedCollection.current.getItem(selectionState.focusedKey);\n      const parentNode = node.parentKey != null && (node.type === 'cell' || node.type === 'rowheader' || node.type === 'column') ? cachedCollection.current.getItem(node.parentKey) : node;\n      const cachedRows = cachedCollection.current.rows;\n      const rows = collection.rows;\n      const diff = cachedRows.length - rows.length;\n      let index = Math.min(diff > 1 ? Math.max(parentNode.index - diff + 1, 0) : parentNode.index, rows.length - 1);\n      let newRow;\n      while (index >= 0) {\n        if (!selectionManager.isDisabled(rows[index].key) && rows[index].type !== 'headerrow') {\n          newRow = rows[index];\n          break;\n        }\n        // Find next, not disabled row.\n        if (index < rows.length - 1) index++;else {\n          if (index > parentNode.index) index = parentNode.index;\n          index--;\n        }\n      }\n      if (newRow) {\n        const childNodes = newRow.hasChildNodes ? [...(0, $7nPCv$getChildNodes)(newRow, collection)] : [];\n        const keyToFocus = newRow.hasChildNodes && parentNode !== node && node.index < childNodes.length ? childNodes[node.index].key : newRow.key;\n        selectionState.setFocusedKey(keyToFocus);\n      } else selectionState.setFocusedKey(null);\n    }\n    cachedCollection.current = collection;\n  }, [collection, selectionManager, selectionState, selectionState.focusedKey]);\n  return {\n    collection: collection,\n    disabledKeys: disabledKeys,\n    isKeyboardNavigationDisabled: false,\n    selectionManager: selectionManager\n  };\n}\nexport { $62967d126f3aa823$export$4007ac09ff9c68ed as useGridState };","map":{"version":3,"mappings":"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","names":["$62967d126f3aa823$export$4007ac09ff9c68ed","props","collection","focusMode","selectionState","UNSAFE_selectionState","disabledKeys","Set","setFocusedKey","key","child","item","getItem","type","_getLastItem","_getFirstItem","children","selectionManager","cachedCollection","focusedKey","node","current","parentNode","parentKey","cachedRows","rows","diff","length","index","Math","min","max","newRow","isDisabled","childNodes","hasChildNodes","keyToFocus","isKeyboardNavigationDisabled"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-stately\\grid\\dist\\packages\\@react-stately\\grid\\src\\useGridState.ts"],"sourcesContent":["import {getChildNodes, getFirstItem, getLastItem} from '@react-stately/collections';\nimport {GridCollection, GridNode} from '@react-types/grid';\nimport {Key} from '@react-types/shared';\nimport {MultipleSelectionState, MultipleSelectionStateProps, SelectionManager, useMultipleSelectionState} from '@react-stately/selection';\nimport {useEffect, useMemo, useRef} from 'react';\n\nexport interface GridState<T, C extends GridCollection<T>> {\n  collection: C,\n  /** A set of keys for rows that are disabled. */\n  disabledKeys: Set<Key>,\n  /** A selection manager to read and update row selection state. */\n  selectionManager: SelectionManager,\n  /** Whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. */\n  isKeyboardNavigationDisabled: boolean\n}\n\nexport interface GridStateOptions<T, C extends GridCollection<T>> extends MultipleSelectionStateProps {\n  collection: C,\n  disabledKeys?: Iterable<Key>,\n  focusMode?: 'row' | 'cell',\n  /** @private - do not use unless you know what you're doing. */\n  UNSAFE_selectionState?: MultipleSelectionState\n}\n\n/**\n * Provides state management for a grid component. Handles row selection and focusing a grid cell's focusable child if applicable.\n */\nexport function useGridState<T extends object, C extends GridCollection<T>>(props: GridStateOptions<T, C>): GridState<T, C> {\n  let {collection, focusMode} = props;\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  let selectionState = props.UNSAFE_selectionState || useMultipleSelectionState(props);\n  let disabledKeys = useMemo(() =>\n      props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n    , [props.disabledKeys]);\n\n  let setFocusedKey = selectionState.setFocusedKey;\n  selectionState.setFocusedKey = (key, child) => {\n    // If focusMode is cell and an item is focused, focus a child cell instead.\n    if (focusMode === 'cell' && key != null) {\n      let item = collection.getItem(key);\n      if (item?.type === 'item') {\n        let children = getChildNodes(item, collection);\n        if (child === 'last') {\n          key = getLastItem(children)?.key;\n        } else {\n          key = getFirstItem(children)?.key;\n        }\n      }\n    }\n\n    setFocusedKey(key, child);\n  };\n\n  let selectionManager = useMemo(() =>\n    new SelectionManager(collection, selectionState)\n    , [collection, selectionState]\n  );\n\n  // Reset focused key if that item is deleted from the collection.\n  const cachedCollection = useRef(null);\n  useEffect(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      const node = cachedCollection.current.getItem(selectionState.focusedKey);\n      const parentNode =\n        node.parentKey != null && (node.type === 'cell' || node.type === 'rowheader' || node.type === 'column') ?\n        cachedCollection.current.getItem(node.parentKey) :\n        node;\n      const cachedRows = cachedCollection.current.rows;\n      const rows = collection.rows;\n      const diff = cachedRows.length - rows.length;\n      let index = Math.min(\n        (\n          diff > 1 ?\n          Math.max(parentNode.index - diff + 1, 0) :\n          parentNode.index\n        ),\n        rows.length - 1);\n      let newRow:GridNode<T>;\n      while (index >= 0) {\n        if (!selectionManager.isDisabled(rows[index].key) && rows[index].type !== 'headerrow') {\n          newRow = rows[index];\n          break;\n        }\n        // Find next, not disabled row.\n        if (index < rows.length - 1) {\n          index++;\n        // Otherwise, find previous, not disabled row.\n        } else {\n          if (index > parentNode.index) {\n            index = parentNode.index;\n          }\n          index--;\n        }\n      }\n      if (newRow) {\n        const childNodes = newRow.hasChildNodes ? [...getChildNodes(newRow, collection)] : [];\n        const keyToFocus =\n          newRow.hasChildNodes &&\n          parentNode !== node &&\n          node.index < childNodes.length ?\n          childNodes[node.index].key :\n          newRow.key;\n        selectionState.setFocusedKey(keyToFocus);\n      } else {\n        selectionState.setFocusedKey(null);\n      }\n    }\n    cachedCollection.current = collection;\n  }, [collection, selectionManager, selectionState, selectionState.focusedKey]);\n\n  return {\n    collection,\n    disabledKeys,\n    isKeyboardNavigationDisabled: false,\n    selectionManager\n  };\n}\n"]},"metadata":{},"sourceType":"module"}