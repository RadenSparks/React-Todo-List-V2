{"ast":null,"code":"import $bUJMr$intlStringsmodulejs from \"./intlStrings.mjs\";\nimport { DateFormatter as $bUJMr$DateFormatter, Time as $bUJMr$Time, toCalendar as $bUJMr$toCalendar, now as $bUJMr$now, toCalendarDate as $bUJMr$toCalendarDate, toCalendarDateTime as $bUJMr$toCalendarDateTime } from \"@internationalized/date\";\nimport { LocalizedStringDictionary as $bUJMr$LocalizedStringDictionary, LocalizedStringFormatter as $bUJMr$LocalizedStringFormatter } from \"@internationalized/string\";\nimport { mergeValidation as $bUJMr$mergeValidation, VALID_VALIDITY_STATE as $bUJMr$VALID_VALIDITY_STATE } from \"@react-stately/form\";\nimport { useState as $bUJMr$useState } from \"react\";\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $35a22f14a1f04b11$var$dictionary = new (0, $bUJMr$LocalizedStringDictionary)((0, $parcel$interopDefault($bUJMr$intlStringsmodulejs)));\nfunction $35a22f14a1f04b11$var$getLocale() {\n  // Match browser language setting here, NOT react-aria's I18nProvider, so that we match other browser-provided\n  // validation messages, which to not respect our provider's language.\n  // @ts-ignore\n  return typeof navigator !== 'undefined' && (navigator.language || navigator.userLanguage) || 'en-US';\n}\nfunction $35a22f14a1f04b11$export$f18627323ab57ac0(value, minValue, maxValue, isDateUnavailable, options) {\n  let rangeOverflow = value != null && maxValue != null && value.compare(maxValue) > 0;\n  let rangeUnderflow = value != null && minValue != null && value.compare(minValue) < 0;\n  let isUnavailable = value != null && (isDateUnavailable === null || isDateUnavailable === void 0 ? void 0 : isDateUnavailable(value)) || false;\n  let isInvalid = rangeOverflow || rangeUnderflow || isUnavailable;\n  let errors = [];\n  if (isInvalid) {\n    let locale = $35a22f14a1f04b11$var$getLocale();\n    let strings = (0, $bUJMr$LocalizedStringDictionary).getGlobalDictionaryForPackage('@react-stately/datepicker') || $35a22f14a1f04b11$var$dictionary;\n    let formatter = new (0, $bUJMr$LocalizedStringFormatter)(locale, strings);\n    let dateFormatter = new (0, $bUJMr$DateFormatter)(locale, $35a22f14a1f04b11$export$7e319ea407e63bc0({}, options));\n    let timeZone = dateFormatter.resolvedOptions().timeZone;\n    if (rangeUnderflow) errors.push(formatter.format('rangeUnderflow', {\n      minValue: dateFormatter.format(minValue.toDate(timeZone))\n    }));\n    if (rangeOverflow) errors.push(formatter.format('rangeOverflow', {\n      maxValue: dateFormatter.format(maxValue.toDate(timeZone))\n    }));\n    if (isUnavailable) errors.push(formatter.format('unavailableDate'));\n  }\n  return {\n    isInvalid: isInvalid,\n    validationErrors: errors,\n    validationDetails: {\n      badInput: isUnavailable,\n      customError: false,\n      patternMismatch: false,\n      rangeOverflow: rangeOverflow,\n      rangeUnderflow: rangeUnderflow,\n      stepMismatch: false,\n      tooLong: false,\n      tooShort: false,\n      typeMismatch: false,\n      valueMissing: false,\n      valid: !isInvalid\n    }\n  };\n}\nfunction $35a22f14a1f04b11$export$80ff8fc0ae339c13(value, minValue, maxValue, isDateUnavailable, options) {\n  let startValidation = $35a22f14a1f04b11$export$f18627323ab57ac0(value === null || value === void 0 ? void 0 : value.start, minValue, maxValue, isDateUnavailable, options);\n  let endValidation = $35a22f14a1f04b11$export$f18627323ab57ac0(value === null || value === void 0 ? void 0 : value.end, minValue, maxValue, isDateUnavailable, options);\n  let result = (0, $bUJMr$mergeValidation)(startValidation, endValidation);\n  if (value.end != null && value.start != null && value.end.compare(value.start) < 0) {\n    let strings = (0, $bUJMr$LocalizedStringDictionary).getGlobalDictionaryForPackage('@react-stately/datepicker') || $35a22f14a1f04b11$var$dictionary;\n    result = (0, $bUJMr$mergeValidation)(result, {\n      isInvalid: true,\n      validationErrors: [strings.getStringForLocale('rangeReversed', $35a22f14a1f04b11$var$getLocale())],\n      validationDetails: {\n        ...(0, $bUJMr$VALID_VALIDITY_STATE),\n        rangeUnderflow: true,\n        rangeOverflow: true,\n        valid: false\n      }\n    });\n  }\n  return result;\n}\nconst $35a22f14a1f04b11$var$DEFAULT_FIELD_OPTIONS = {\n  year: 'numeric',\n  month: 'numeric',\n  day: 'numeric',\n  hour: 'numeric',\n  minute: '2-digit',\n  second: '2-digit'\n};\nconst $35a22f14a1f04b11$var$TWO_DIGIT_FIELD_OPTIONS = {\n  year: 'numeric',\n  month: '2-digit',\n  day: '2-digit',\n  hour: '2-digit',\n  minute: '2-digit',\n  second: '2-digit'\n};\nfunction $35a22f14a1f04b11$export$7e319ea407e63bc0(fieldOptions, options) {\n  let defaultFieldOptions = options.shouldForceLeadingZeros ? $35a22f14a1f04b11$var$TWO_DIGIT_FIELD_OPTIONS : $35a22f14a1f04b11$var$DEFAULT_FIELD_OPTIONS;\n  fieldOptions = {\n    ...defaultFieldOptions,\n    ...fieldOptions\n  };\n  let granularity = options.granularity || 'minute';\n  let keys = Object.keys(fieldOptions);\n  var _options_maxGranularity;\n  let startIdx = keys.indexOf((_options_maxGranularity = options.maxGranularity) !== null && _options_maxGranularity !== void 0 ? _options_maxGranularity : 'year');\n  if (startIdx < 0) startIdx = 0;\n  let endIdx = keys.indexOf(granularity);\n  if (endIdx < 0) endIdx = 2;\n  if (startIdx > endIdx) throw new Error('maxGranularity must be greater than granularity');\n  let opts = keys.slice(startIdx, endIdx + 1).reduce((opts, key) => {\n    opts[key] = fieldOptions[key];\n    return opts;\n  }, {});\n  if (options.hourCycle != null) opts.hour12 = options.hourCycle === 12;\n  opts.timeZone = options.timeZone || 'UTC';\n  let hasTime = granularity === 'hour' || granularity === 'minute' || granularity === 'second';\n  if (hasTime && options.timeZone && !options.hideTimeZone) opts.timeZoneName = 'short';\n  if (options.showEra && startIdx === 0) opts.era = 'short';\n  return opts;\n}\nfunction $35a22f14a1f04b11$export$c5221a78ef73c5e9(placeholderValue) {\n  if (placeholderValue && 'hour' in placeholderValue) return placeholderValue;\n  return new (0, $bUJMr$Time)();\n}\nfunction $35a22f14a1f04b11$export$61a490a80c552550(value, calendar) {\n  if (value === null) return null;\n  if (!value) return undefined;\n  return (0, $bUJMr$toCalendar)(value, calendar);\n}\nfunction $35a22f14a1f04b11$export$66aa2b09de4b1ea5(placeholderValue, granularity, calendar, timeZone) {\n  if (placeholderValue) return $35a22f14a1f04b11$export$61a490a80c552550(placeholderValue, calendar);\n  let date = (0, $bUJMr$toCalendar)((0, $bUJMr$now)(timeZone).set({\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0\n  }), calendar);\n  if (granularity === 'year' || granularity === 'month' || granularity === 'day') return (0, $bUJMr$toCalendarDate)(date);\n  if (!timeZone) return (0, $bUJMr$toCalendarDateTime)(date);\n  return date;\n}\nfunction $35a22f14a1f04b11$export$2440da353cedad43(v, granularity) {\n  // Compute default granularity and time zone from the value. If the value becomes null, keep the last values.\n  let defaultTimeZone = v && 'timeZone' in v ? v.timeZone : undefined;\n  let defaultGranularity = v && 'minute' in v ? 'minute' : 'day';\n  // props.granularity must actually exist in the value if one is provided.\n  if (v && granularity && !(granularity in v)) throw new Error('Invalid granularity ' + granularity + ' for value ' + v.toString());\n  let [lastValue, setLastValue] = (0, $bUJMr$useState)([defaultGranularity, defaultTimeZone]);\n  // If the granularity or time zone changed, update the last value.\n  if (v && (lastValue[0] !== defaultGranularity || lastValue[1] !== defaultTimeZone)) setLastValue([defaultGranularity, defaultTimeZone]);\n  if (!granularity) granularity = v ? defaultGranularity : lastValue[0];\n  let timeZone = v ? defaultTimeZone : lastValue[1];\n  return [granularity, timeZone];\n}\nexport { $35a22f14a1f04b11$export$f18627323ab57ac0 as getValidationResult, $35a22f14a1f04b11$export$7e319ea407e63bc0 as getFormatOptions, $35a22f14a1f04b11$export$80ff8fc0ae339c13 as getRangeValidationResult, $35a22f14a1f04b11$export$c5221a78ef73c5e9 as getPlaceholderTime, $35a22f14a1f04b11$export$61a490a80c552550 as convertValue, $35a22f14a1f04b11$export$66aa2b09de4b1ea5 as createPlaceholderDate, $35a22f14a1f04b11$export$2440da353cedad43 as useDefaultProps };","map":{"version":3,"mappings":"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","names":["$35a22f14a1f04b11$var$dictionary","$35a22f14a1f04b11$var$getLocale","navigator","language","userLanguage","$35a22f14a1f04b11$export$f18627323ab57ac0","value","minValue","maxValue","isDateUnavailable","options","rangeOverflow","compare","rangeUnderflow","isUnavailable","isInvalid","errors","locale","strings","getGlobalDictionaryForPackage","formatter","dateFormatter","$35a22f14a1f04b11$export$7e319ea407e63bc0","timeZone","resolvedOptions","push","format","toDate","validationErrors","validationDetails","badInput","customError","patternMismatch","stepMismatch","tooLong","tooShort","typeMismatch","valueMissing","valid","$35a22f14a1f04b11$export$80ff8fc0ae339c13","startValidation","start","endValidation","end","result","getStringForLocale","$35a22f14a1f04b11$var$DEFAULT_FIELD_OPTIONS","year","month","day","hour","minute","second","$35a22f14a1f04b11$var$TWO_DIGIT_FIELD_OPTIONS","fieldOptions","defaultFieldOptions","shouldForceLeadingZeros","granularity","keys","Object","_options_maxGranularity","startIdx","indexOf","maxGranularity","endIdx","Error","opts","slice","reduce","key","hourCycle","hour12","hasTime","hideTimeZone","timeZoneName","showEra","era","$35a22f14a1f04b11$export$c5221a78ef73c5e9","placeholderValue","$35a22f14a1f04b11$export$61a490a80c552550","calendar","undefined","$35a22f14a1f04b11$export$66aa2b09de4b1ea5","date","set","millisecond","$35a22f14a1f04b11$export$2440da353cedad43","v","defaultTimeZone","defaultGranularity","toString","lastValue","setLastValue"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-stately\\datepicker\\dist\\packages\\@react-stately\\datepicker\\src\\utils.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Calendar, DateFormatter, now, Time, toCalendar, toCalendarDate, toCalendarDateTime} from '@internationalized/date';\nimport {DatePickerProps, DateValue, Granularity, TimeValue} from '@react-types/datepicker';\n// @ts-ignore\nimport i18nMessages from '../intl/*.json';\nimport {LocalizedStringDictionary, LocalizedStringFormatter} from '@internationalized/string';\nimport {mergeValidation, VALID_VALIDITY_STATE} from '@react-stately/form';\nimport {RangeValue, ValidationResult} from '@react-types/shared';\nimport {useState} from 'react';\n\nconst dictionary = new LocalizedStringDictionary(i18nMessages);\n\nfunction getLocale() {\n  // Match browser language setting here, NOT react-aria's I18nProvider, so that we match other browser-provided\n  // validation messages, which to not respect our provider's language.\n  // @ts-ignore\n  return (typeof navigator !== 'undefined' && (navigator.language || navigator.userLanguage)) || 'en-US';\n}\n\nexport function getValidationResult(\n  value: DateValue,\n  minValue: DateValue,\n  maxValue: DateValue,\n  isDateUnavailable: (v: DateValue) => boolean,\n  options: FormatterOptions\n): ValidationResult {\n  let rangeOverflow = value != null && maxValue != null && value.compare(maxValue) > 0;\n  let rangeUnderflow = value != null && minValue != null && value.compare(minValue) < 0;\n  let isUnavailable = (value != null && isDateUnavailable?.(value)) || false;\n  let isInvalid = rangeOverflow || rangeUnderflow || isUnavailable;\n  let errors = [];\n\n  if (isInvalid) {\n    let locale = getLocale();\n    let strings = LocalizedStringDictionary.getGlobalDictionaryForPackage('@react-stately/datepicker') || dictionary;\n    let formatter = new LocalizedStringFormatter(locale, strings);\n    let dateFormatter = new DateFormatter(locale, getFormatOptions({}, options));\n    let timeZone = dateFormatter.resolvedOptions().timeZone;\n\n    if (rangeUnderflow) {\n      errors.push(formatter.format('rangeUnderflow', {minValue: dateFormatter.format(minValue.toDate(timeZone))}));\n    }\n\n    if (rangeOverflow) {\n      errors.push(formatter.format('rangeOverflow', {maxValue: dateFormatter.format(maxValue.toDate(timeZone))}));\n    }\n\n    if (isUnavailable) {\n      errors.push(formatter.format('unavailableDate'));\n    }\n  }\n\n  return {\n    isInvalid,\n    validationErrors: errors,\n    validationDetails: {\n      badInput: isUnavailable,\n      customError: false,\n      patternMismatch: false,\n      rangeOverflow,\n      rangeUnderflow,\n      stepMismatch: false,\n      tooLong: false,\n      tooShort: false,\n      typeMismatch: false,\n      valueMissing: false,\n      valid: !isInvalid\n    }\n  };\n}\n\nexport function getRangeValidationResult(\n  value: RangeValue<DateValue>,\n  minValue: DateValue,\n  maxValue: DateValue,\n  isDateUnavailable: (v: DateValue) => boolean,\n  options: FormatterOptions\n) {\n  let startValidation = getValidationResult(\n    value?.start,\n    minValue,\n    maxValue,\n    isDateUnavailable,\n    options\n  );\n\n  let endValidation = getValidationResult(\n    value?.end,\n    minValue,\n    maxValue,\n    isDateUnavailable,\n    options\n  );\n\n  let result = mergeValidation(startValidation, endValidation);\n  if (value.end != null && value.start != null && value.end.compare(value.start) < 0) {\n    let strings = LocalizedStringDictionary.getGlobalDictionaryForPackage('@react-stately/datepicker') || dictionary;\n    result = mergeValidation(result, {\n      isInvalid: true,\n      validationErrors: [strings.getStringForLocale('rangeReversed', getLocale())],\n      validationDetails: {\n        ...VALID_VALIDITY_STATE,\n        rangeUnderflow: true,\n        rangeOverflow: true,\n        valid: false\n      }\n    });\n  }\n\n  return result;\n}\n\nexport type FieldOptions = Pick<Intl.DateTimeFormatOptions, 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second'>;\ninterface FormatterOptions {\n  timeZone?: string,\n  hideTimeZone?: boolean,\n  granularity?: DatePickerProps<any>['granularity'],\n  maxGranularity?: 'year' | 'month' | DatePickerProps<any>['granularity'],\n  hourCycle?: 12 | 24,\n  showEra?: boolean,\n  shouldForceLeadingZeros?: boolean\n}\n\nconst DEFAULT_FIELD_OPTIONS: FieldOptions = {\n  year: 'numeric',\n  month: 'numeric',\n  day: 'numeric',\n  hour: 'numeric',\n  minute: '2-digit',\n  second: '2-digit'\n};\n\nconst TWO_DIGIT_FIELD_OPTIONS: FieldOptions = {\n  year: 'numeric',\n  month: '2-digit',\n  day: '2-digit',\n  hour: '2-digit',\n  minute: '2-digit',\n  second: '2-digit'\n};\n\nexport function getFormatOptions(\n  fieldOptions: FieldOptions,\n  options: FormatterOptions\n): Intl.DateTimeFormatOptions {\n  let defaultFieldOptions = options.shouldForceLeadingZeros ? TWO_DIGIT_FIELD_OPTIONS : DEFAULT_FIELD_OPTIONS;\n  fieldOptions = {...defaultFieldOptions, ...fieldOptions};\n  let granularity = options.granularity || 'minute';\n  let keys = Object.keys(fieldOptions);\n  let startIdx = keys.indexOf(options.maxGranularity ?? 'year');\n  if (startIdx < 0) {\n    startIdx = 0;\n  }\n\n  let endIdx = keys.indexOf(granularity);\n  if (endIdx < 0) {\n    endIdx = 2;\n  }\n\n  if (startIdx > endIdx) {\n    throw new Error('maxGranularity must be greater than granularity');\n  }\n\n  let opts: Intl.DateTimeFormatOptions = keys.slice(startIdx, endIdx + 1).reduce((opts, key) => {\n    opts[key] = fieldOptions[key];\n    return opts;\n  }, {});\n\n  if (options.hourCycle != null) {\n    opts.hour12 = options.hourCycle === 12;\n  }\n\n  opts.timeZone = options.timeZone || 'UTC';\n\n  let hasTime = granularity === 'hour' || granularity === 'minute' || granularity === 'second';\n  if (hasTime && options.timeZone && !options.hideTimeZone) {\n    opts.timeZoneName = 'short';\n  }\n\n  if (options.showEra && startIdx === 0) {\n    opts.era = 'short';\n  }\n\n  return opts;\n}\n\nexport function getPlaceholderTime(placeholderValue: DateValue): TimeValue {\n  if (placeholderValue && 'hour' in placeholderValue) {\n    return placeholderValue;\n  }\n\n  return new Time();\n}\n\nexport function convertValue(value: DateValue, calendar: Calendar): DateValue {\n  if (value === null) {\n    return null;\n  }\n\n  if (!value) {\n    return undefined;\n  }\n\n  return toCalendar(value, calendar);\n}\n\n\nexport function createPlaceholderDate(placeholderValue: DateValue, granularity: string, calendar: Calendar, timeZone: string) {\n  if (placeholderValue) {\n    return convertValue(placeholderValue, calendar);\n  }\n\n  let date = toCalendar(now(timeZone).set({\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0\n  }), calendar);\n\n  if (granularity === 'year' || granularity === 'month' || granularity === 'day') {\n    return toCalendarDate(date);\n  }\n\n  if (!timeZone) {\n    return toCalendarDateTime(date);\n  }\n\n  return date;\n}\n\nexport function useDefaultProps(v: DateValue, granularity: Granularity): [Granularity, string] {\n  // Compute default granularity and time zone from the value. If the value becomes null, keep the last values.\n  let defaultTimeZone = (v && 'timeZone' in v ? v.timeZone : undefined);\n  let defaultGranularity: Granularity = (v && 'minute' in v ? 'minute' : 'day');\n\n  // props.granularity must actually exist in the value if one is provided.\n  if (v && granularity && !(granularity in v)) {\n    throw new Error('Invalid granularity ' + granularity + ' for value ' + v.toString());\n  }\n\n  let [lastValue, setLastValue] = useState<[Granularity, string]>([defaultGranularity, defaultTimeZone]);\n\n  // If the granularity or time zone changed, update the last value.\n  if (v && (lastValue[0] !== defaultGranularity || lastValue[1] !== defaultTimeZone)) {\n    setLastValue([defaultGranularity, defaultTimeZone]);\n  }\n\n  if (!granularity) {\n    granularity = v ? defaultGranularity : lastValue[0];\n  }\n\n  let timeZone = v ? defaultTimeZone : lastValue[1];\n  return [granularity, timeZone];\n}\n"]},"metadata":{},"sourceType":"module"}