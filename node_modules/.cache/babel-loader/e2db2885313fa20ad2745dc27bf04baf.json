{"ast":null,"code":"import { alignCenter as $f62d864046160412$export$f4a51ff076cc9a09, constrainValue as $f62d864046160412$export$4f5203c0d889109e, isInvalid as $f62d864046160412$export$eac50920cf2fd59a, previousAvailableDate as $f62d864046160412$export$a1d3911297b952d7 } from \"./utils.mjs\";\nimport { useCalendarState as $131cf43a05231e1e$export$6d095e787d2b5e1f } from \"./useCalendarState.mjs\";\nimport { toCalendarDate as $d0gbl$toCalendarDate, maxDate as $d0gbl$maxDate, minDate as $d0gbl$minDate, isEqualDay as $d0gbl$isEqualDay, toCalendar as $d0gbl$toCalendar, GregorianCalendar as $d0gbl$GregorianCalendar } from \"@internationalized/date\";\nimport { useControlledState as $d0gbl$useControlledState } from \"@react-stately/utils\";\nimport { useState as $d0gbl$useState, useRef as $d0gbl$useRef, useMemo as $d0gbl$useMemo } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $9a36b6ba2fb1a7c5$export$9a987164d97ecc90(props) {\n  let {\n    value: valueProp,\n    defaultValue: defaultValue,\n    onChange: onChange,\n    createCalendar: createCalendar,\n    locale: locale,\n    visibleDuration = {\n      months: 1\n    },\n    minValue: minValue,\n    maxValue: maxValue,\n    ...calendarProps\n  } = props;\n  let [value, setValue] = (0, $d0gbl$useControlledState)(valueProp, defaultValue || null, onChange);\n  let [anchorDate, setAnchorDateState] = (0, $d0gbl$useState)(null);\n  let alignment = 'center';\n  if (value && value.start && value.end) {\n    let start = (0, $f62d864046160412$export$f4a51ff076cc9a09)((0, $d0gbl$toCalendarDate)(value.start), visibleDuration, locale, minValue, maxValue);\n    let end = start.add(visibleDuration).subtract({\n      days: 1\n    });\n    if (value.end.compare(end) > 0) alignment = 'start';\n  }\n  // Available range must be stored in a ref so we have access to the updated version immediately in `isInvalid`.\n  let availableRangeRef = (0, $d0gbl$useRef)(null);\n  let [availableRange, setAvailableRange] = (0, $d0gbl$useState)(null);\n  let min = (0, $d0gbl$useMemo)(() => (0, $d0gbl$maxDate)(minValue, availableRange === null || availableRange === void 0 ? void 0 : availableRange.start), [minValue, availableRange]);\n  let max = (0, $d0gbl$useMemo)(() => (0, $d0gbl$minDate)(maxValue, availableRange === null || availableRange === void 0 ? void 0 : availableRange.end), [maxValue, availableRange]);\n  let calendar = (0, $131cf43a05231e1e$export$6d095e787d2b5e1f)({\n    ...calendarProps,\n    value: value && value.start,\n    createCalendar: createCalendar,\n    locale: locale,\n    visibleDuration: visibleDuration,\n    minValue: min,\n    maxValue: max,\n    selectionAlignment: alignment\n  });\n  let updateAvailableRange = date => {\n    if (date && props.isDateUnavailable && !props.allowsNonContiguousRanges) {\n      availableRangeRef.current = {\n        start: $9a36b6ba2fb1a7c5$var$nextUnavailableDate(date, calendar, -1),\n        end: $9a36b6ba2fb1a7c5$var$nextUnavailableDate(date, calendar, 1)\n      };\n      setAvailableRange(availableRangeRef.current);\n    } else {\n      availableRangeRef.current = null;\n      setAvailableRange(null);\n    }\n  };\n  // If the visible range changes, we need to update the available range.\n  let [lastVisibleRange, setLastVisibleRange] = (0, $d0gbl$useState)(calendar.visibleRange);\n  if (!(0, $d0gbl$isEqualDay)(calendar.visibleRange.start, lastVisibleRange.start) || !(0, $d0gbl$isEqualDay)(calendar.visibleRange.end, lastVisibleRange.end)) {\n    updateAvailableRange(anchorDate);\n    setLastVisibleRange(calendar.visibleRange);\n  }\n  let setAnchorDate = date => {\n    if (date) {\n      setAnchorDateState(date);\n      updateAvailableRange(date);\n    } else {\n      setAnchorDateState(null);\n      updateAvailableRange(null);\n    }\n  };\n  let highlightedRange = anchorDate ? $9a36b6ba2fb1a7c5$var$makeRange(anchorDate, calendar.focusedDate) : value && $9a36b6ba2fb1a7c5$var$makeRange(value.start, value.end);\n  let selectDate = date => {\n    if (props.isReadOnly) return;\n    date = (0, $f62d864046160412$export$4f5203c0d889109e)(date, min, max);\n    date = (0, $f62d864046160412$export$a1d3911297b952d7)(date, calendar.visibleRange.start, props.isDateUnavailable);\n    if (!date) return;\n    if (!anchorDate) setAnchorDate(date);else {\n      let range = $9a36b6ba2fb1a7c5$var$makeRange(anchorDate, date);\n      setValue({\n        start: $9a36b6ba2fb1a7c5$var$convertValue(range.start, value === null || value === void 0 ? void 0 : value.start),\n        end: $9a36b6ba2fb1a7c5$var$convertValue(range.end, value === null || value === void 0 ? void 0 : value.end)\n      });\n      setAnchorDate(null);\n    }\n  };\n  let [isDragging, setDragging] = (0, $d0gbl$useState)(false);\n  let {\n    isDateUnavailable: isDateUnavailable\n  } = props;\n  let isInvalidSelection = (0, $d0gbl$useMemo)(() => {\n    if (!value || anchorDate) return false;\n    if (isDateUnavailable && (isDateUnavailable(value.start) || isDateUnavailable(value.end))) return true;\n    return (0, $f62d864046160412$export$eac50920cf2fd59a)(value.start, minValue, maxValue) || (0, $f62d864046160412$export$eac50920cf2fd59a)(value.end, minValue, maxValue);\n  }, [isDateUnavailable, value, anchorDate, minValue, maxValue]);\n  let isValueInvalid = props.isInvalid || props.validationState === 'invalid' || isInvalidSelection;\n  let validationState = isValueInvalid ? 'invalid' : null;\n  return {\n    ...calendar,\n    value: value,\n    setValue: setValue,\n    anchorDate: anchorDate,\n    setAnchorDate: setAnchorDate,\n    highlightedRange: highlightedRange,\n    validationState: validationState,\n    isValueInvalid: isValueInvalid,\n    selectFocusedDate() {\n      selectDate(calendar.focusedDate);\n    },\n    selectDate: selectDate,\n    highlightDate(date) {\n      if (anchorDate) calendar.setFocusedDate(date);\n    },\n    isSelected(date) {\n      return highlightedRange && date.compare(highlightedRange.start) >= 0 && date.compare(highlightedRange.end) <= 0 && !calendar.isCellDisabled(date) && !calendar.isCellUnavailable(date);\n    },\n    isInvalid(date) {\n      var _availableRangeRef_current, _availableRangeRef_current1;\n      return calendar.isInvalid(date) || (0, $f62d864046160412$export$eac50920cf2fd59a)(date, (_availableRangeRef_current = availableRangeRef.current) === null || _availableRangeRef_current === void 0 ? void 0 : _availableRangeRef_current.start, (_availableRangeRef_current1 = availableRangeRef.current) === null || _availableRangeRef_current1 === void 0 ? void 0 : _availableRangeRef_current1.end);\n    },\n    isDragging: isDragging,\n    setDragging: setDragging\n  };\n}\nfunction $9a36b6ba2fb1a7c5$var$makeRange(start, end) {\n  if (!start || !end) return null;\n  if (end.compare(start) < 0) [start, end] = [end, start];\n  return {\n    start: (0, $d0gbl$toCalendarDate)(start),\n    end: (0, $d0gbl$toCalendarDate)(end)\n  };\n}\nfunction $9a36b6ba2fb1a7c5$var$convertValue(newValue, oldValue) {\n  // The display calendar should not have any effect on the emitted value.\n  // Emit dates in the same calendar as the original value, if any, otherwise gregorian.\n  newValue = (0, $d0gbl$toCalendar)(newValue, (oldValue === null || oldValue === void 0 ? void 0 : oldValue.calendar) || new (0, $d0gbl$GregorianCalendar)());\n  // Preserve time if the input value had one.\n  if (oldValue && 'hour' in oldValue) return oldValue.set(newValue);\n  return newValue;\n}\nfunction $9a36b6ba2fb1a7c5$var$nextUnavailableDate(anchorDate, state, dir) {\n  let nextDate = anchorDate.add({\n    days: dir\n  });\n  while ((dir < 0 ? nextDate.compare(state.visibleRange.start) >= 0 : nextDate.compare(state.visibleRange.end) <= 0) && !state.isCellUnavailable(nextDate)) nextDate = nextDate.add({\n    days: dir\n  });\n  if (state.isCellUnavailable(nextDate)) return nextDate.add({\n    days: -dir\n  });\n  return null;\n}\nexport { $9a36b6ba2fb1a7c5$export$9a987164d97ecc90 as useRangeCalendarState };","map":{"version":3,"mappings":"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","names":["$9a36b6ba2fb1a7c5$export$9a987164d97ecc90","props","value","valueProp","defaultValue","onChange","createCalendar","locale","visibleDuration","months","minValue","maxValue","calendarProps","setValue","anchorDate","setAnchorDateState","alignment","start","end","add","subtract","days","compare","availableRangeRef","availableRange","setAvailableRange","min","max","calendar","selectionAlignment","updateAvailableRange","date","isDateUnavailable","allowsNonContiguousRanges","current","$9a36b6ba2fb1a7c5$var$nextUnavailableDate","lastVisibleRange","setLastVisibleRange","visibleRange","setAnchorDate","highlightedRange","$9a36b6ba2fb1a7c5$var$makeRange","focusedDate","selectDate","isReadOnly","range","$9a36b6ba2fb1a7c5$var$convertValue","isDragging","setDragging","isInvalidSelection","isValueInvalid","isInvalid","validationState","selectFocusedDate","highlightDate","setFocusedDate","isSelected","isCellDisabled","isCellUnavailable","_availableRangeRef_current","_availableRangeRef_current1","newValue","oldValue","set","state","dir","nextDate"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-stately\\calendar\\dist\\packages\\@react-stately\\calendar\\src\\useRangeCalendarState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {alignCenter, constrainValue, isInvalid, previousAvailableDate} from './utils';\nimport {Calendar, CalendarDate, DateDuration, GregorianCalendar, isEqualDay, maxDate, minDate, toCalendar, toCalendarDate} from '@internationalized/date';\nimport {CalendarState, RangeCalendarState} from './types';\nimport {DateRange, DateValue, RangeCalendarProps} from '@react-types/calendar';\nimport {RangeValue, ValidationState} from '@react-types/shared';\nimport {useCalendarState} from './useCalendarState';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo, useRef, useState} from 'react';\n\nexport interface RangeCalendarStateOptions<T extends DateValue = DateValue> extends RangeCalendarProps<T> {\n  /** The locale to display and edit the value according to. */\n  locale: string,\n  /**\n   * A function that creates a [Calendar](../internationalized/date/Calendar.html)\n   * object for a given calendar identifier. Such a function may be imported from the\n   * `@internationalized/date` package, or manually implemented to include support for\n   * only certain calendars.\n   */\n  createCalendar: (name: string) => Calendar,\n  /**\n   * The amount of days that will be displayed at once. This affects how pagination works.\n   * @default {months: 1}\n   */\n  visibleDuration?: DateDuration\n}\n\n/**\n * Provides state management for a range calendar component.\n * A range calendar displays one or more date grids and allows users to select a contiguous range of dates.\n */\nexport function useRangeCalendarState<T extends DateValue = DateValue>(props: RangeCalendarStateOptions<T>): RangeCalendarState {\n  let {value: valueProp, defaultValue, onChange, createCalendar, locale, visibleDuration = {months: 1}, minValue, maxValue, ...calendarProps} = props;\n  let [value, setValue] = useControlledState<DateRange>(\n    valueProp,\n    defaultValue || null,\n    onChange\n  );\n\n  let [anchorDate, setAnchorDateState] = useState(null);\n  let alignment: 'center' | 'start' = 'center';\n  if (value && value.start && value.end) {\n    let start = alignCenter(toCalendarDate(value.start), visibleDuration, locale, minValue, maxValue);\n    let end = start.add(visibleDuration).subtract({days: 1});\n\n    if (value.end.compare(end) > 0) {\n      alignment = 'start';\n    }\n  }\n\n  // Available range must be stored in a ref so we have access to the updated version immediately in `isInvalid`.\n  let availableRangeRef = useRef<RangeValue<DateValue>>(null);\n  let [availableRange, setAvailableRange] = useState<RangeValue<DateValue>>(null);\n  let min = useMemo(() => maxDate(minValue, availableRange?.start), [minValue, availableRange]);\n  let max = useMemo(() => minDate(maxValue, availableRange?.end), [maxValue, availableRange]);\n\n  let calendar = useCalendarState({\n    ...calendarProps,\n    value: value && value.start,\n    createCalendar,\n    locale,\n    visibleDuration,\n    minValue: min,\n    maxValue: max,\n    selectionAlignment: alignment\n  });\n\n  let updateAvailableRange = (date) => {\n    if (date && props.isDateUnavailable && !props.allowsNonContiguousRanges) {\n      availableRangeRef.current = {\n        start: nextUnavailableDate(date, calendar, -1),\n        end: nextUnavailableDate(date, calendar, 1)\n      };\n      setAvailableRange(availableRangeRef.current);\n    } else {\n      availableRangeRef.current = null;\n      setAvailableRange(null);\n    }\n  };\n\n  // If the visible range changes, we need to update the available range.\n  let [lastVisibleRange, setLastVisibleRange] = useState(calendar.visibleRange);\n  if (!isEqualDay(calendar.visibleRange.start, lastVisibleRange.start) || !isEqualDay(calendar.visibleRange.end, lastVisibleRange.end)) {\n    updateAvailableRange(anchorDate);\n    setLastVisibleRange(calendar.visibleRange);\n  }\n\n  let setAnchorDate = (date: CalendarDate) => {\n    if (date) {\n      setAnchorDateState(date);\n      updateAvailableRange(date);\n    } else {\n      setAnchorDateState(null);\n      updateAvailableRange(null);\n    }\n  };\n\n  let highlightedRange = anchorDate ? makeRange(anchorDate, calendar.focusedDate) : value && makeRange(value.start, value.end);\n  let selectDate = (date: CalendarDate) => {\n    if (props.isReadOnly) {\n      return;\n    }\n\n    date = constrainValue(date, min, max);\n    date = previousAvailableDate(date, calendar.visibleRange.start, props.isDateUnavailable);\n    if (!date) {\n      return;\n    }\n\n    if (!anchorDate) {\n      setAnchorDate(date);\n    } else {\n      let range = makeRange(anchorDate, date);\n      setValue({\n        start: convertValue(range.start, value?.start),\n        end: convertValue(range.end, value?.end)\n      });\n      setAnchorDate(null);\n    }\n  };\n\n  let [isDragging, setDragging] = useState(false);\n\n  let {isDateUnavailable} = props;\n  let isInvalidSelection = useMemo(() => {\n    if (!value || anchorDate) {\n      return false;\n    }\n\n    if (isDateUnavailable && (isDateUnavailable(value.start) || isDateUnavailable(value.end))) {\n      return true;\n    }\n\n    return isInvalid(value.start, minValue, maxValue) || isInvalid(value.end, minValue, maxValue);\n  }, [isDateUnavailable, value, anchorDate, minValue, maxValue]);\n\n  let isValueInvalid = props.isInvalid || props.validationState === 'invalid' || isInvalidSelection;\n  let validationState: ValidationState = isValueInvalid ? 'invalid' : null;\n\n  return {\n    ...calendar,\n    value,\n    setValue,\n    anchorDate,\n    setAnchorDate,\n    highlightedRange,\n    validationState,\n    isValueInvalid,\n    selectFocusedDate() {\n      selectDate(calendar.focusedDate);\n    },\n    selectDate,\n    highlightDate(date) {\n      if (anchorDate) {\n        calendar.setFocusedDate(date);\n      }\n    },\n    isSelected(date) {\n      return highlightedRange && date.compare(highlightedRange.start) >= 0 && date.compare(highlightedRange.end) <= 0 && !calendar.isCellDisabled(date) && !calendar.isCellUnavailable(date);\n    },\n    isInvalid(date) {\n      return calendar.isInvalid(date) || isInvalid(date, availableRangeRef.current?.start, availableRangeRef.current?.end);\n    },\n    isDragging,\n    setDragging\n  };\n}\n\nfunction makeRange(start: DateValue, end: DateValue): RangeValue<CalendarDate> {\n  if (!start || !end) {\n    return null;\n  }\n\n  if (end.compare(start) < 0) {\n    [start, end] = [end, start];\n  }\n\n  return {start: toCalendarDate(start), end: toCalendarDate(end)};\n}\n\nfunction convertValue(newValue: CalendarDate, oldValue: DateValue) {\n  // The display calendar should not have any effect on the emitted value.\n  // Emit dates in the same calendar as the original value, if any, otherwise gregorian.\n  newValue = toCalendar(newValue, oldValue?.calendar || new GregorianCalendar());\n\n  // Preserve time if the input value had one.\n  if (oldValue && 'hour' in oldValue) {\n    return oldValue.set(newValue);\n  }\n\n  return newValue;\n}\n\nfunction nextUnavailableDate(anchorDate: CalendarDate, state: CalendarState, dir: number) {\n  let nextDate = anchorDate.add({days: dir});\n  while (\n    (dir < 0 ? nextDate.compare(state.visibleRange.start) >= 0 : nextDate.compare(state.visibleRange.end) <= 0) &&\n    !state.isCellUnavailable(nextDate)\n  ) {\n    nextDate = nextDate.add({days: dir});\n  }\n\n  if (state.isCellUnavailable(nextDate)) {\n    return nextDate.add({days: -dir});\n  }\n\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}