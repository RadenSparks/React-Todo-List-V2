{"ast":null,"code":"/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Keeps a ref count of all hidden elements. Added to when hiding an element, and\n// subtracted from when showing it again. When it reaches zero, aria-hidden is removed.\nlet $5e3802645cc19319$var$refCountMap = new WeakMap();\nlet $5e3802645cc19319$var$observerStack = [];\nfunction $5e3802645cc19319$export$1c3ebcada18427bf(targets) {\n  let root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.body;\n  let visibleNodes = new Set(targets);\n  let hiddenNodes = new Set();\n  let walk = root => {\n    // Keep live announcer and top layer elements (e.g. toasts) visible.\n    for (let element of root.querySelectorAll('[data-live-announcer], [data-react-aria-top-layer]')) visibleNodes.add(element);\n    let acceptNode = node => {\n      // Skip this node and its children if it is one of the target nodes, or a live announcer.\n      // Also skip children of already hidden nodes, as aria-hidden is recursive. An exception is\n      // made for elements with role=\"row\" since VoiceOver on iOS has issues hiding elements with role=\"row\".\n      // For that case we want to hide the cells inside as well (https://bugs.webkit.org/show_bug.cgi?id=222623).\n      if (visibleNodes.has(node) || hiddenNodes.has(node.parentElement) && node.parentElement.getAttribute('role') !== 'row') return NodeFilter.FILTER_REJECT;\n      // Skip this node but continue to children if one of the targets is inside the node.\n      for (let target of visibleNodes) {\n        if (node.contains(target)) return NodeFilter.FILTER_SKIP;\n      }\n      return NodeFilter.FILTER_ACCEPT;\n    };\n    let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {\n      acceptNode: acceptNode\n    });\n    // TreeWalker does not include the root.\n    let acceptRoot = acceptNode(root);\n    if (acceptRoot === NodeFilter.FILTER_ACCEPT) hide(root);\n    if (acceptRoot !== NodeFilter.FILTER_REJECT) {\n      let node = walker.nextNode();\n      while (node != null) {\n        hide(node);\n        node = walker.nextNode();\n      }\n    }\n  };\n  let hide = node => {\n    var _refCountMap_get;\n    let refCount = (_refCountMap_get = $5e3802645cc19319$var$refCountMap.get(node)) !== null && _refCountMap_get !== void 0 ? _refCountMap_get : 0;\n    // If already aria-hidden, and the ref count is zero, then this element\n    // was already hidden and there's nothing for us to do.\n    if (node.getAttribute('aria-hidden') === 'true' && refCount === 0) return;\n    if (refCount === 0) node.setAttribute('aria-hidden', 'true');\n    hiddenNodes.add(node);\n    $5e3802645cc19319$var$refCountMap.set(node, refCount + 1);\n  };\n  // If there is already a MutationObserver listening from a previous call,\n  // disconnect it so the new on takes over.\n  if ($5e3802645cc19319$var$observerStack.length) $5e3802645cc19319$var$observerStack[$5e3802645cc19319$var$observerStack.length - 1].disconnect();\n  walk(root);\n  let observer = new MutationObserver(changes => {\n    for (let change of changes) {\n      if (change.type !== 'childList' || change.addedNodes.length === 0) continue;\n      // If the parent element of the added nodes is not within one of the targets,\n      // and not already inside a hidden node, hide all of the new children.\n      if (![...visibleNodes, ...hiddenNodes].some(node => node.contains(change.target))) {\n        for (let node of change.removedNodes) if (node instanceof Element) {\n          visibleNodes.delete(node);\n          hiddenNodes.delete(node);\n        }\n        for (let node of change.addedNodes) {\n          if ((node instanceof HTMLElement || node instanceof SVGElement) && (node.dataset.liveAnnouncer === 'true' || node.dataset.reactAriaTopLayer === 'true')) visibleNodes.add(node);else if (node instanceof Element) walk(node);\n        }\n      }\n    }\n  });\n  observer.observe(root, {\n    childList: true,\n    subtree: true\n  });\n  let observerWrapper = {\n    observe() {\n      observer.observe(root, {\n        childList: true,\n        subtree: true\n      });\n    },\n    disconnect() {\n      observer.disconnect();\n    }\n  };\n  $5e3802645cc19319$var$observerStack.push(observerWrapper);\n  return () => {\n    observer.disconnect();\n    for (let node of hiddenNodes) {\n      let count = $5e3802645cc19319$var$refCountMap.get(node);\n      if (count === 1) {\n        node.removeAttribute('aria-hidden');\n        $5e3802645cc19319$var$refCountMap.delete(node);\n      } else $5e3802645cc19319$var$refCountMap.set(node, count - 1);\n    }\n    // Remove this observer from the stack, and start the previous one.\n    if (observerWrapper === $5e3802645cc19319$var$observerStack[$5e3802645cc19319$var$observerStack.length - 1]) {\n      $5e3802645cc19319$var$observerStack.pop();\n      if ($5e3802645cc19319$var$observerStack.length) $5e3802645cc19319$var$observerStack[$5e3802645cc19319$var$observerStack.length - 1].observe();\n    } else $5e3802645cc19319$var$observerStack.splice($5e3802645cc19319$var$observerStack.indexOf(observerWrapper), 1);\n  };\n}\nexport { $5e3802645cc19319$export$1c3ebcada18427bf as ariaHideOutside };","map":{"version":3,"mappings":"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","names":["$5e3802645cc19319$var$refCountMap","WeakMap","$5e3802645cc19319$var$observerStack","$5e3802645cc19319$export$1c3ebcada18427bf","targets","root","document","body","visibleNodes","Set","hiddenNodes","walk","element","querySelectorAll","add","acceptNode","node","has","parentElement","getAttribute","NodeFilter","FILTER_REJECT","target","contains","FILTER_SKIP","FILTER_ACCEPT","walker","createTreeWalker","SHOW_ELEMENT","acceptRoot","hide","nextNode","_refCountMap_get","refCount","get","setAttribute","set","length","disconnect","observer","MutationObserver","changes","change","type","addedNodes","some","removedNodes","Element","delete","HTMLElement","SVGElement","dataset","liveAnnouncer","reactAriaTopLayer","observe","childList","subtree","observerWrapper","push","count","removeAttribute","pop","splice","indexOf"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-aria\\overlays\\dist\\packages\\@react-aria\\overlays\\src\\ariaHideOutside.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Keeps a ref count of all hidden elements. Added to when hiding an element, and\n// subtracted from when showing it again. When it reaches zero, aria-hidden is removed.\nlet refCountMap = new WeakMap<Element, number>();\nlet observerStack = [];\n\n/**\n * Hides all elements in the DOM outside the given targets from screen readers using aria-hidden,\n * and returns a function to revert these changes. In addition, changes to the DOM are watched\n * and new elements outside the targets are automatically hidden.\n * @param targets - The elements that should remain visible.\n * @param root - Nothing will be hidden above this element.\n * @returns - A function to restore all hidden elements.\n */\nexport function ariaHideOutside(targets: Element[], root = document.body) {\n  let visibleNodes = new Set<Element>(targets);\n  let hiddenNodes = new Set<Element>();\n\n  let walk = (root: Element) => {\n    // Keep live announcer and top layer elements (e.g. toasts) visible.\n    for (let element of root.querySelectorAll('[data-live-announcer], [data-react-aria-top-layer]')) {\n      visibleNodes.add(element);\n    }\n\n    let acceptNode = (node: Element) => {\n      // Skip this node and its children if it is one of the target nodes, or a live announcer.\n      // Also skip children of already hidden nodes, as aria-hidden is recursive. An exception is\n      // made for elements with role=\"row\" since VoiceOver on iOS has issues hiding elements with role=\"row\".\n      // For that case we want to hide the cells inside as well (https://bugs.webkit.org/show_bug.cgi?id=222623).\n      if (\n        visibleNodes.has(node) ||\n        (hiddenNodes.has(node.parentElement) && node.parentElement.getAttribute('role') !== 'row')\n      ) {\n        return NodeFilter.FILTER_REJECT;\n      }\n\n      // Skip this node but continue to children if one of the targets is inside the node.\n      for (let target of visibleNodes) {\n        if (node.contains(target)) {\n          return NodeFilter.FILTER_SKIP;\n        }\n      }\n\n      return NodeFilter.FILTER_ACCEPT;\n    };\n\n    let walker = document.createTreeWalker(\n      root,\n      NodeFilter.SHOW_ELEMENT,\n      {acceptNode}\n    );\n\n    // TreeWalker does not include the root.\n    let acceptRoot = acceptNode(root);\n    if (acceptRoot === NodeFilter.FILTER_ACCEPT) {\n      hide(root);\n    }\n\n    if (acceptRoot !== NodeFilter.FILTER_REJECT) {\n      let node = walker.nextNode() as Element;\n      while (node != null) {\n        hide(node);\n        node = walker.nextNode() as Element;\n      }\n    }\n  };\n\n  let hide = (node: Element) => {\n    let refCount = refCountMap.get(node) ?? 0;\n\n    // If already aria-hidden, and the ref count is zero, then this element\n    // was already hidden and there's nothing for us to do.\n    if (node.getAttribute('aria-hidden') === 'true' && refCount === 0) {\n      return;\n    }\n\n    if (refCount === 0) {\n      node.setAttribute('aria-hidden', 'true');\n    }\n\n    hiddenNodes.add(node);\n    refCountMap.set(node, refCount + 1);\n  };\n\n  // If there is already a MutationObserver listening from a previous call,\n  // disconnect it so the new on takes over.\n  if (observerStack.length) {\n    observerStack[observerStack.length - 1].disconnect();\n  }\n\n  walk(root);\n\n  let observer = new MutationObserver(changes => {\n    for (let change of changes) {\n      if (change.type !== 'childList' || change.addedNodes.length === 0) {\n        continue;\n      }\n\n      // If the parent element of the added nodes is not within one of the targets,\n      // and not already inside a hidden node, hide all of the new children.\n      if (![...visibleNodes, ...hiddenNodes].some(node => node.contains(change.target))) {\n        for (let node of change.removedNodes) {\n          if (node instanceof Element) {\n            visibleNodes.delete(node);\n            hiddenNodes.delete(node);\n          }\n        }\n\n        for (let node of change.addedNodes) {\n          if (\n            (node instanceof HTMLElement || node instanceof SVGElement) &&\n            (node.dataset.liveAnnouncer === 'true' || node.dataset.reactAriaTopLayer === 'true')\n          ) {\n            visibleNodes.add(node);\n          } else if (node instanceof Element) {\n            walk(node);\n          }\n        }\n      }\n    }\n  });\n\n  observer.observe(root, {childList: true, subtree: true});\n\n  let observerWrapper = {\n    observe() {\n      observer.observe(root, {childList: true, subtree: true});\n    },\n    disconnect() {\n      observer.disconnect();\n    }\n  };\n\n  observerStack.push(observerWrapper);\n\n  return () => {\n    observer.disconnect();\n\n    for (let node of hiddenNodes) {\n      let count = refCountMap.get(node);\n      if (count === 1) {\n        node.removeAttribute('aria-hidden');\n        refCountMap.delete(node);\n      } else {\n        refCountMap.set(node, count - 1);\n      }\n    }\n\n    // Remove this observer from the stack, and start the previous one.\n    if (observerWrapper === observerStack[observerStack.length - 1]) {\n      observerStack.pop();\n      if (observerStack.length) {\n        observerStack[observerStack.length - 1].observe();\n      }\n    } else {\n      observerStack.splice(observerStack.indexOf(observerWrapper), 1);\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}