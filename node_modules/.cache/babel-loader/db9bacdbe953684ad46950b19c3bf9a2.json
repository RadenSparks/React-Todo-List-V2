{"ast":null,"code":"import { ListCollection as $a02d57049d202695$export$d085fb9e920b5ca7 } from \"./ListCollection.mjs\";\nimport { useMultipleSelectionState as $d5vlZ$useMultipleSelectionState, SelectionManager as $d5vlZ$SelectionManager } from \"@react-stately/selection\";\nimport { useMemo as $d5vlZ$useMemo, useCallback as $d5vlZ$useCallback, useRef as $d5vlZ$useRef, useEffect as $d5vlZ$useEffect } from \"react\";\nimport { useCollection as $d5vlZ$useCollection } from \"@react-stately/collections\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $e72dd72e1c76a225$export$2f645645f7bca764(props) {\n  let {\n    filter: filter\n  } = props;\n  let selectionState = (0, $d5vlZ$useMultipleSelectionState)(props);\n  let disabledKeys = (0, $d5vlZ$useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [props.disabledKeys]);\n  let factory = (0, $d5vlZ$useCallback)(nodes => filter ? new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(filter(nodes)) : new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(nodes), [filter]);\n  let context = (0, $d5vlZ$useMemo)(() => ({\n    suppressTextValueWarning: props.suppressTextValueWarning\n  }), [props.suppressTextValueWarning]);\n  let collection = (0, $d5vlZ$useCollection)(props, factory, context);\n  let selectionManager = (0, $d5vlZ$useMemo)(() => new (0, $d5vlZ$SelectionManager)(collection, selectionState), [collection, selectionState]);\n  // Reset focused key if that item is deleted from the collection.\n  const cachedCollection = (0, $d5vlZ$useRef)(null);\n  (0, $d5vlZ$useEffect)(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      const startItem = cachedCollection.current.getItem(selectionState.focusedKey);\n      const cachedItemNodes = [...cachedCollection.current.getKeys()].map(key => {\n        const itemNode = cachedCollection.current.getItem(key);\n        return itemNode.type === 'item' ? itemNode : null;\n      }).filter(node => node !== null);\n      const itemNodes = [...collection.getKeys()].map(key => {\n        const itemNode = collection.getItem(key);\n        return itemNode.type === 'item' ? itemNode : null;\n      }).filter(node => node !== null);\n      const diff = cachedItemNodes.length - itemNodes.length;\n      let index = Math.min(diff > 1 ? Math.max(startItem.index - diff + 1, 0) : startItem.index, itemNodes.length - 1);\n      let newNode;\n      while (index >= 0) {\n        if (!selectionManager.isDisabled(itemNodes[index].key)) {\n          newNode = itemNodes[index];\n          break;\n        }\n        // Find next, not disabled item.\n        if (index < itemNodes.length - 1) index++;else {\n          if (index > startItem.index) index = startItem.index;\n          index--;\n        }\n      }\n      selectionState.setFocusedKey(newNode ? newNode.key : null);\n    }\n    cachedCollection.current = collection;\n  }, [collection, selectionManager, selectionState, selectionState.focusedKey]);\n  return {\n    collection: collection,\n    disabledKeys: disabledKeys,\n    selectionManager: selectionManager\n  };\n}\nexport { $e72dd72e1c76a225$export$2f645645f7bca764 as useListState };","map":{"version":3,"mappings":";;;;;AAAA;;;;;;;;;;;;AAwCO,SAASA,0CAA+BC,KAAmB;EAChE,IAAI;IAAAC,QAACA;EAAM,CAAC,GAAGD;EAEf,IAAIE,iBAAiB,oCAAwB,EAAEF;EAC/C,IAAIG,eAAe,kBAAM,EAAE,MACzBH,MAAMG,YAAY,GAAG,IAAIC,IAAIJ,MAAMG,YAAY,IAAI,IAAIC,OACvD,CAACJ,MAAMG,YAAY,CAAC;EAEtB,IAAIE,UAAU,sBAAU,EAAEC,SAASL,SAAS,KAAI,4CAAa,EAAEA,OAAOK,UAAU,KAAI,4CAAa,EAAEA,QAA6B,CAACL,OAAO;EACxI,IAAIM,UAAU,kBAAM,EAAE,OAAO;IAACC,0BAA0BR,MAAMQ;EAAwB,IAAI,CAACR,MAAMQ,wBAAwB,CAAC;EAE1H,IAAIC,aAAa,wBAAY,EAAET,OAAOK,SAASE;EAE/C,IAAIG,mBAAmB,kBAAM,EAAE,MAC7B,KAAI,0BAAe,EAAED,YAAYP,iBAC/B,CAACO,YAAYP,eAAe;EAGhC;EACA,MAAMS,mBAAmB,iBAAK,EAAE;EAChC,oBAAQ,EAAE;IACR,IAAIT,eAAeU,UAAU,IAAI,QAAQ,CAACH,WAAWI,OAAO,CAACX,eAAeU,UAAU,GAAG;MACvF,MAAME,YAAYH,iBAAiBI,OAAO,CAACF,OAAO,CAACX,eAAeU,UAAU;MAC5E,MAAMI,kBAAkB,IAAIL,iBAAiBI,OAAO,CAACE,OAAO,GAAG,CAACC,GAAG,CACjEC;QACE,MAAMC,WAAWT,iBAAiBI,OAAO,CAACF,OAAO,CAACM;QAClD,OAAOC,SAASC,IAAI,KAAK,SAASD,WAAW;MAC/C,GACAnB,MAAM,CAACqB,QAAQA,SAAS;MAC1B,MAAMC,YAAY,IAAId,WAAWQ,OAAO,GAAG,CAACC,GAAG,CAC7CC;QACE,MAAMC,WAAWX,WAAWI,OAAO,CAACM;QACpC,OAAOC,SAASC,IAAI,KAAK,SAASD,WAAW;MAC/C,GACAnB,MAAM,CAACqB,QAAQA,SAAS;MAC1B,MAAME,OAAOR,gBAAgBS,MAAM,GAAGF,UAAUE,MAAM;MACtD,IAAIC,QAAQC,KAAKC,GAAG,CAEhBJ,OAAO,IACPG,KAAKE,GAAG,CAACf,UAAUY,KAAK,GAAGF,OAAO,GAAG,KACrCV,UAAUY,KAAK,EAEjBH,UAAUE,MAAM,GAAG;MACrB,IAAIK;MACJ,OAAOJ,SAAS,GAAG;QACjB,IAAI,CAAChB,iBAAiBqB,UAAU,CAACR,SAAS,CAACG,MAAM,CAACP,GAAG,GAAG;UACtDW,UAAUP,SAAS,CAACG,MAAM;UAC1B;QACF;QACA;QACA,IAAIA,QAAQH,UAAUE,MAAM,GAAG,GAC7BC,aAEK;UACL,IAAIA,QAAQZ,UAAUY,KAAK,EACzBA,QAAQZ,UAAUY,KAAK;UAEzBA;QACF;MACF;MACAxB,eAAe8B,aAAa,CAACF,UAAUA,QAAQX,GAAG,GAAG;IACvD;IACAR,iBAAiBI,OAAO,GAAGN;EAC7B,GAAG,CAACA,YAAYC,kBAAkBR,gBAAgBA,eAAeU,UAAU,CAAC;EAE5E,OAAO;gBACLH;kBACAN;sBACAO;EACF;AACF","names":["$e72dd72e1c76a225$export$2f645645f7bca764","props","filter","selectionState","disabledKeys","Set","factory","nodes","context","suppressTextValueWarning","collection","selectionManager","cachedCollection","focusedKey","getItem","startItem","current","cachedItemNodes","getKeys","map","key","itemNode","type","node","itemNodes","diff","length","index","Math","min","max","newNode","isDisabled","setFocusedKey"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-stately\\list\\dist\\packages\\@react-stately\\list\\src\\useListState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, CollectionStateBase, Key, Node} from '@react-types/shared';\nimport {ListCollection} from './ListCollection';\nimport {MultipleSelectionStateProps, SelectionManager, useMultipleSelectionState} from '@react-stately/selection';\nimport {useCallback, useEffect, useMemo, useRef} from 'react';\nimport {useCollection} from '@react-stately/collections';\n\nexport interface ListProps<T> extends CollectionStateBase<T>, MultipleSelectionStateProps {\n  /** Filter function to generate a filtered list of nodes. */\n  filter?: (nodes: Iterable<Node<T>>) => Iterable<Node<T>>,\n  /** @private */\n  suppressTextValueWarning?: boolean\n}\n\nexport interface ListState<T> {\n  /** A collection of items in the list. */\n  collection: Collection<Node<T>>,\n\n  /** A set of items that are disabled. */\n  disabledKeys: Set<Key>,\n\n  /** A selection manager to read and update multiple selection state. */\n  selectionManager: SelectionManager\n}\n\n/**\n * Provides state management for list-like components. Handles building a collection\n * of items from props, and manages multiple selection state.\n */\nexport function useListState<T extends object>(props: ListProps<T>): ListState<T>  {\n  let {filter} = props;\n\n  let selectionState = useMultipleSelectionState(props);\n  let disabledKeys = useMemo(() =>\n    props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n  , [props.disabledKeys]);\n\n  let factory = useCallback(nodes => filter ? new ListCollection(filter(nodes)) : new ListCollection(nodes as Iterable<Node<T>>), [filter]);\n  let context = useMemo(() => ({suppressTextValueWarning: props.suppressTextValueWarning}), [props.suppressTextValueWarning]);\n\n  let collection = useCollection(props, factory, context);\n\n  let selectionManager = useMemo(() =>\n    new SelectionManager(collection, selectionState)\n    , [collection, selectionState]\n  );\n\n  // Reset focused key if that item is deleted from the collection.\n  const cachedCollection = useRef(null);\n  useEffect(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      const startItem = cachedCollection.current.getItem(selectionState.focusedKey);\n      const cachedItemNodes = [...cachedCollection.current.getKeys()].map(\n        key => {\n          const itemNode = cachedCollection.current.getItem(key);\n          return itemNode.type === 'item' ? itemNode : null;\n        }\n      ).filter(node => node !== null);\n      const itemNodes = [...collection.getKeys()].map(\n        key => {\n          const itemNode = collection.getItem(key);\n          return itemNode.type === 'item' ? itemNode : null;\n        }\n      ).filter(node => node !== null);\n      const diff = cachedItemNodes.length - itemNodes.length;\n      let index = Math.min(\n        (\n          diff > 1 ?\n          Math.max(startItem.index - diff + 1, 0) :\n          startItem.index\n        ),\n        itemNodes.length - 1);\n      let newNode:Node<T>;\n      while (index >= 0) {\n        if (!selectionManager.isDisabled(itemNodes[index].key)) {\n          newNode = itemNodes[index];\n          break;\n        }\n        // Find next, not disabled item.\n        if (index < itemNodes.length - 1) {\n          index++;\n        // Otherwise, find previous, not disabled item.\n        } else {\n          if (index > startItem.index) {\n            index = startItem.index;\n          }\n          index--;\n        }\n      }\n      selectionState.setFocusedKey(newNode ? newNode.key : null);\n    }\n    cachedCollection.current = collection;\n  }, [collection, selectionManager, selectionState, selectionState.focusedKey]);\n\n  return {\n    collection,\n    disabledKeys,\n    selectionManager\n  };\n}\n"]},"metadata":{},"sourceType":"module"}