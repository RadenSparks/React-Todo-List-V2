{"ast":null,"code":"import { CalendarDate as $35ea8db9cb2ccb90$export$99faa760c7908e4f } from \"./CalendarDate.mjs\";\nimport { GregorianCalendar as $3b62074eb05584b2$export$80ee6245ec4f29ec } from \"./GregorianCalendar.mjs\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from the TC39 Temporal proposal.\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\n\nconst $62225008020f0a13$var$ERA_START_DATES = [[1868, 9, 8], [1912, 7, 30], [1926, 12, 25], [1989, 1, 8], [2019, 5, 1]];\nconst $62225008020f0a13$var$ERA_END_DATES = [[1912, 7, 29], [1926, 12, 24], [1989, 1, 7], [2019, 4, 30]];\nconst $62225008020f0a13$var$ERA_ADDENDS = [1867, 1911, 1925, 1988, 2018];\nconst $62225008020f0a13$var$ERA_NAMES = ['meiji', 'taisho', 'showa', 'heisei', 'reiwa'];\nfunction $62225008020f0a13$var$findEraFromGregorianDate(date) {\n  const idx = $62225008020f0a13$var$ERA_START_DATES.findIndex(_ref => {\n    let [year, month, day] = _ref;\n    if (date.year < year) return true;\n    if (date.year === year && date.month < month) return true;\n    if (date.year === year && date.month === month && date.day < day) return true;\n    return false;\n  });\n  if (idx === -1) return $62225008020f0a13$var$ERA_START_DATES.length - 1;\n  if (idx === 0) return 0;\n  return idx - 1;\n}\nfunction $62225008020f0a13$var$toGregorian(date) {\n  let eraAddend = $62225008020f0a13$var$ERA_ADDENDS[$62225008020f0a13$var$ERA_NAMES.indexOf(date.era)];\n  if (!eraAddend) throw new Error('Unknown era: ' + date.era);\n  return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(date.year + eraAddend, date.month, date.day);\n}\nclass $62225008020f0a13$export$b746ab2b60cdffbf extends (0, $3b62074eb05584b2$export$80ee6245ec4f29ec) {\n  fromJulianDay(jd) {\n    let date = super.fromJulianDay(jd);\n    let era = $62225008020f0a13$var$findEraFromGregorianDate(date);\n    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, $62225008020f0a13$var$ERA_NAMES[era], date.year - $62225008020f0a13$var$ERA_ADDENDS[era], date.month, date.day);\n  }\n  toJulianDay(date) {\n    return super.toJulianDay($62225008020f0a13$var$toGregorian(date));\n  }\n  balanceDate(date) {\n    let gregorianDate = $62225008020f0a13$var$toGregorian(date);\n    let era = $62225008020f0a13$var$findEraFromGregorianDate(gregorianDate);\n    if ($62225008020f0a13$var$ERA_NAMES[era] !== date.era) {\n      date.era = $62225008020f0a13$var$ERA_NAMES[era];\n      date.year = gregorianDate.year - $62225008020f0a13$var$ERA_ADDENDS[era];\n    }\n    // Constrain in case we went before the first supported era.\n    this.constrainDate(date);\n  }\n  constrainDate(date) {\n    let idx = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);\n    let end = $62225008020f0a13$var$ERA_END_DATES[idx];\n    if (end != null) {\n      let [endYear, endMonth, endDay] = end;\n      // Constrain the year to the maximum possible value in the era.\n      // Then constrain the month and day fields within that.\n      let maxYear = endYear - $62225008020f0a13$var$ERA_ADDENDS[idx];\n      date.year = Math.max(1, Math.min(maxYear, date.year));\n      if (date.year === maxYear) {\n        date.month = Math.min(endMonth, date.month);\n        if (date.month === endMonth) date.day = Math.min(endDay, date.day);\n      }\n    }\n    if (date.year === 1 && idx >= 0) {\n      let [, startMonth, startDay] = $62225008020f0a13$var$ERA_START_DATES[idx];\n      date.month = Math.max(startMonth, date.month);\n      if (date.month === startMonth) date.day = Math.max(startDay, date.day);\n    }\n  }\n  getEras() {\n    return $62225008020f0a13$var$ERA_NAMES;\n  }\n  getYearsInEra(date) {\n    // Get the number of years in the era, taking into account the date's month and day fields.\n    let era = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);\n    let cur = $62225008020f0a13$var$ERA_START_DATES[era];\n    let next = $62225008020f0a13$var$ERA_START_DATES[era + 1];\n    if (next == null)\n      // 9999 gregorian is the maximum year allowed.\n      return 9999 - cur[0] + 1;\n    let years = next[0] - cur[0];\n    if (date.month < next[1] || date.month === next[1] && date.day < next[2]) years++;\n    return years;\n  }\n  getDaysInMonth(date) {\n    return super.getDaysInMonth($62225008020f0a13$var$toGregorian(date));\n  }\n  getMinimumMonthInYear(date) {\n    let start = $62225008020f0a13$var$getMinimums(date);\n    return start ? start[1] : 1;\n  }\n  getMinimumDayInMonth(date) {\n    let start = $62225008020f0a13$var$getMinimums(date);\n    return start && date.month === start[1] ? start[2] : 1;\n  }\n  constructor() {\n    super(...arguments);\n    this.identifier = 'japanese';\n  }\n}\nfunction $62225008020f0a13$var$getMinimums(date) {\n  if (date.year === 1) {\n    let idx = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);\n    return $62225008020f0a13$var$ERA_START_DATES[idx];\n  }\n}\nexport { $62225008020f0a13$export$b746ab2b60cdffbf as JapaneseCalendar };","map":{"version":3,"mappings":"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","names":["$62225008020f0a13$var$ERA_START_DATES","$62225008020f0a13$var$ERA_END_DATES","$62225008020f0a13$var$ERA_ADDENDS","$62225008020f0a13$var$ERA_NAMES","$62225008020f0a13$var$findEraFromGregorianDate","date","idx","findIndex","_ref","year","month","day","length","$62225008020f0a13$var$toGregorian","eraAddend","indexOf","era","Error","$62225008020f0a13$export$b746ab2b60cdffbf","fromJulianDay","jd","toJulianDay","balanceDate","gregorianDate","constrainDate","end","endYear","endMonth","endDay","maxYear","Math","max","min","startMonth","startDay","getEras","getYearsInEra","cur","next","years","getDaysInMonth","getMinimumMonthInYear","start","$62225008020f0a13$var$getMinimums","getMinimumDayInMonth","identifier"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@internationalized\\date\\dist\\packages\\@internationalized\\date\\src\\calendars\\JapaneseCalendar.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from the TC39 Temporal proposal.\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\n\nimport {AnyCalendarDate} from '../types';\nimport {CalendarDate} from '../CalendarDate';\nimport {GregorianCalendar} from './GregorianCalendar';\nimport {Mutable} from '../utils';\n\nconst ERA_START_DATES = [[1868, 9, 8], [1912, 7, 30], [1926, 12, 25], [1989, 1, 8], [2019, 5, 1]];\nconst ERA_END_DATES = [[1912, 7, 29], [1926, 12, 24], [1989, 1, 7], [2019, 4, 30]];\nconst ERA_ADDENDS = [1867, 1911, 1925, 1988, 2018];\nconst ERA_NAMES = ['meiji', 'taisho', 'showa', 'heisei', 'reiwa'];\n\nfunction findEraFromGregorianDate(date: AnyCalendarDate) {\n  const idx = ERA_START_DATES.findIndex(([year, month, day]) => {\n    if (date.year < year) {\n      return true;\n    }\n\n    if (date.year === year && date.month < month) {\n      return true;\n    }\n\n    if (date.year === year && date.month === month && date.day < day) {\n      return true;\n    }\n\n    return false;\n  });\n\n  if (idx === -1) {\n    return ERA_START_DATES.length - 1;\n  }\n\n  if (idx === 0) {\n    return 0;\n  }\n\n  return idx - 1;\n}\n\nfunction toGregorian(date: AnyCalendarDate) {\n  let eraAddend = ERA_ADDENDS[ERA_NAMES.indexOf(date.era)];\n  if (!eraAddend) {\n    throw new Error('Unknown era: ' + date.era);\n  }\n\n  return new CalendarDate(\n    date.year + eraAddend,\n    date.month,\n    date.day\n  );\n}\n\n/**\n * The Japanese calendar is based on the Gregorian calendar, but with eras for the reign of each Japanese emperor.\n * Whenever a new emperor ascends to the throne, a new era begins and the year starts again from 1.\n * Note that eras before 1868 (Gregorian) are not currently supported by this implementation.\n */\nexport class JapaneseCalendar extends GregorianCalendar {\n  identifier = 'japanese';\n\n  fromJulianDay(jd: number): CalendarDate {\n    let date = super.fromJulianDay(jd);\n    let era = findEraFromGregorianDate(date);\n\n    return new CalendarDate(\n      this,\n      ERA_NAMES[era],\n      date.year - ERA_ADDENDS[era],\n      date.month,\n      date.day\n    );\n  }\n\n  toJulianDay(date: AnyCalendarDate) {\n    return super.toJulianDay(toGregorian(date));\n  }\n\n  balanceDate(date: Mutable<AnyCalendarDate>) {\n    let gregorianDate = toGregorian(date);\n    let era = findEraFromGregorianDate(gregorianDate);\n\n    if (ERA_NAMES[era] !== date.era) {\n      date.era = ERA_NAMES[era];\n      date.year = gregorianDate.year - ERA_ADDENDS[era];\n    }\n\n    // Constrain in case we went before the first supported era.\n    this.constrainDate(date);\n  }\n\n  constrainDate(date: Mutable<AnyCalendarDate>) {\n    let idx = ERA_NAMES.indexOf(date.era);\n    let end = ERA_END_DATES[idx];\n    if (end != null) {\n      let [endYear, endMonth, endDay] = end;\n\n      // Constrain the year to the maximum possible value in the era.\n      // Then constrain the month and day fields within that.\n      let maxYear = endYear - ERA_ADDENDS[idx];\n      date.year = Math.max(1, Math.min(maxYear, date.year));\n      if (date.year === maxYear) {\n        date.month = Math.min(endMonth, date.month);\n\n        if (date.month === endMonth) {\n          date.day = Math.min(endDay, date.day);\n        }\n      }\n    }\n\n    if (date.year === 1 && idx >= 0) {\n      let [, startMonth, startDay] = ERA_START_DATES[idx];\n      date.month = Math.max(startMonth, date.month);\n\n      if (date.month === startMonth) {\n        date.day = Math.max(startDay, date.day);\n      }\n    }\n  }\n\n  getEras() {\n    return ERA_NAMES;\n  }\n\n  getYearsInEra(date: AnyCalendarDate): number {\n    // Get the number of years in the era, taking into account the date's month and day fields.\n    let era = ERA_NAMES.indexOf(date.era);\n    let cur = ERA_START_DATES[era];\n    let next = ERA_START_DATES[era + 1];\n    if (next == null) {\n      // 9999 gregorian is the maximum year allowed.\n      return 9999 - cur[0] + 1;\n    }\n\n    let years = next[0] - cur[0];\n\n    if (date.month < next[1] || (date.month === next[1] && date.day < next[2])) {\n      years++;\n    }\n\n    return years;\n  }\n\n  getDaysInMonth(date: AnyCalendarDate): number {\n    return super.getDaysInMonth(toGregorian(date));\n  }\n\n  getMinimumMonthInYear(date: AnyCalendarDate): number {\n    let start = getMinimums(date);\n    return start ? start[1] : 1;\n  }\n\n  getMinimumDayInMonth(date: AnyCalendarDate): number {\n    let start = getMinimums(date);\n    return start && date.month === start[1] ? start[2] : 1;\n  }\n}\n\nfunction getMinimums(date: AnyCalendarDate) {\n  if (date.year === 1) {\n    let idx = ERA_NAMES.indexOf(date.era);\n    return ERA_START_DATES[idx];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}