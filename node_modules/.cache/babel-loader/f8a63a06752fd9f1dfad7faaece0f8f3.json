{"ast":null,"code":"import { alignCenter as $f62d864046160412$export$f4a51ff076cc9a09, alignEnd as $f62d864046160412$export$530edbfc915b2b04, alignStart as $f62d864046160412$export$144a00ba6044eb9, constrainStart as $f62d864046160412$export$5bb865b12696a77d, constrainValue as $f62d864046160412$export$4f5203c0d889109e, isInvalid as $f62d864046160412$export$eac50920cf2fd59a, previousAvailableDate as $f62d864046160412$export$a1d3911297b952d7 } from \"./utils.mjs\";\nimport { DateFormatter as $7G4ZY$DateFormatter, toCalendar as $7G4ZY$toCalendar, toCalendarDate as $7G4ZY$toCalendarDate, today as $7G4ZY$today, GregorianCalendar as $7G4ZY$GregorianCalendar, startOfWeek as $7G4ZY$startOfWeek, startOfMonth as $7G4ZY$startOfMonth, endOfWeek as $7G4ZY$endOfWeek, endOfMonth as $7G4ZY$endOfMonth, isSameDay as $7G4ZY$isSameDay, getDayOfWeek as $7G4ZY$getDayOfWeek } from \"@internationalized/date\";\nimport { useControlledState as $7G4ZY$useControlledState } from \"@react-stately/utils\";\nimport { useMemo as $7G4ZY$useMemo, useState as $7G4ZY$useState } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $131cf43a05231e1e$export$6d095e787d2b5e1f(props) {\n  let defaultFormatter = (0, $7G4ZY$useMemo)(() => new (0, $7G4ZY$DateFormatter)(props.locale), [props.locale]);\n  let resolvedOptions = (0, $7G4ZY$useMemo)(() => defaultFormatter.resolvedOptions(), [defaultFormatter]);\n  let {\n    locale: locale,\n    createCalendar: createCalendar,\n    visibleDuration = {\n      months: 1\n    },\n    minValue: minValue,\n    maxValue: maxValue,\n    selectionAlignment: selectionAlignment,\n    isDateUnavailable: isDateUnavailable,\n    pageBehavior = 'visible'\n  } = props;\n  let calendar = (0, $7G4ZY$useMemo)(() => createCalendar(resolvedOptions.calendar), [createCalendar, resolvedOptions.calendar]);\n  let [value, setControlledValue] = (0, $7G4ZY$useControlledState)(props.value, props.defaultValue, props.onChange);\n  let calendarDateValue = (0, $7G4ZY$useMemo)(() => value ? (0, $7G4ZY$toCalendar)((0, $7G4ZY$toCalendarDate)(value), calendar) : null, [value, calendar]);\n  let timeZone = (0, $7G4ZY$useMemo)(() => value && 'timeZone' in value ? value.timeZone : resolvedOptions.timeZone, [value, resolvedOptions.timeZone]);\n  let focusedCalendarDate = (0, $7G4ZY$useMemo)(() => props.focusedValue ? (0, $f62d864046160412$export$4f5203c0d889109e)((0, $7G4ZY$toCalendar)((0, $7G4ZY$toCalendarDate)(props.focusedValue), calendar), minValue, maxValue) : undefined, [props.focusedValue, calendar, minValue, maxValue]);\n  let defaultFocusedCalendarDate = (0, $7G4ZY$useMemo)(() => (0, $f62d864046160412$export$4f5203c0d889109e)(props.defaultFocusedValue ? (0, $7G4ZY$toCalendar)((0, $7G4ZY$toCalendarDate)(props.defaultFocusedValue), calendar) : calendarDateValue || (0, $7G4ZY$toCalendar)((0, $7G4ZY$today)(timeZone), calendar), minValue, maxValue), [props.defaultFocusedValue, calendarDateValue, timeZone, calendar, minValue, maxValue]);\n  let [focusedDate, setFocusedDate] = (0, $7G4ZY$useControlledState)(focusedCalendarDate, defaultFocusedCalendarDate, props.onFocusChange);\n  let [startDate, setStartDate] = (0, $7G4ZY$useState)(() => {\n    switch (selectionAlignment) {\n      case 'start':\n        return (0, $f62d864046160412$export$144a00ba6044eb9)(focusedDate, visibleDuration, locale, minValue, maxValue);\n      case 'end':\n        return (0, $f62d864046160412$export$530edbfc915b2b04)(focusedDate, visibleDuration, locale, minValue, maxValue);\n      case 'center':\n      default:\n        return (0, $f62d864046160412$export$f4a51ff076cc9a09)(focusedDate, visibleDuration, locale, minValue, maxValue);\n    }\n  });\n  let [isFocused, setFocused] = (0, $7G4ZY$useState)(props.autoFocus || false);\n  let endDate = (0, $7G4ZY$useMemo)(() => {\n    let duration = {\n      ...visibleDuration\n    };\n    if (duration.days) duration.days--;else duration.days = -1;\n    return startDate.add(duration);\n  }, [startDate, visibleDuration]);\n  // Reset focused date and visible range when calendar changes.\n  let [lastCalendarIdentifier, setLastCalendarIdentifier] = (0, $7G4ZY$useState)(calendar.identifier);\n  if (calendar.identifier !== lastCalendarIdentifier) {\n    let newFocusedDate = (0, $7G4ZY$toCalendar)(focusedDate, calendar);\n    setStartDate((0, $f62d864046160412$export$f4a51ff076cc9a09)(newFocusedDate, visibleDuration, locale, minValue, maxValue));\n    setFocusedDate(newFocusedDate);\n    setLastCalendarIdentifier(calendar.identifier);\n  }\n  if ((0, $f62d864046160412$export$eac50920cf2fd59a)(focusedDate, minValue, maxValue))\n    // If the focused date was moved to an invalid value, it can't be focused, so constrain it.\n    setFocusedDate((0, $f62d864046160412$export$4f5203c0d889109e)(focusedDate, minValue, maxValue));else if (focusedDate.compare(startDate) < 0) setStartDate((0, $f62d864046160412$export$530edbfc915b2b04)(focusedDate, visibleDuration, locale, minValue, maxValue));else if (focusedDate.compare(endDate) > 0) setStartDate((0, $f62d864046160412$export$144a00ba6044eb9)(focusedDate, visibleDuration, locale, minValue, maxValue));\n  // Sets focus to a specific cell date\n  function focusCell(date) {\n    date = (0, $f62d864046160412$export$4f5203c0d889109e)(date, minValue, maxValue);\n    setFocusedDate(date);\n  }\n  function setValue(newValue) {\n    if (!props.isDisabled && !props.isReadOnly) {\n      if (newValue === null) {\n        setControlledValue(null);\n        return;\n      }\n      newValue = (0, $f62d864046160412$export$4f5203c0d889109e)(newValue, minValue, maxValue);\n      newValue = (0, $f62d864046160412$export$a1d3911297b952d7)(newValue, startDate, isDateUnavailable);\n      if (!newValue) return;\n      // The display calendar should not have any effect on the emitted value.\n      // Emit dates in the same calendar as the original value, if any, otherwise gregorian.\n      newValue = (0, $7G4ZY$toCalendar)(newValue, (value === null || value === void 0 ? void 0 : value.calendar) || new (0, $7G4ZY$GregorianCalendar)());\n      // Preserve time if the input value had one.\n      if (value && 'hour' in value) setControlledValue(value.set(newValue));else setControlledValue(newValue);\n    }\n  }\n  let isUnavailable = (0, $7G4ZY$useMemo)(() => {\n    if (!calendarDateValue) return false;\n    if (isDateUnavailable && isDateUnavailable(calendarDateValue)) return true;\n    return (0, $f62d864046160412$export$eac50920cf2fd59a)(calendarDateValue, minValue, maxValue);\n  }, [calendarDateValue, isDateUnavailable, minValue, maxValue]);\n  let isValueInvalid = props.isInvalid || props.validationState === 'invalid' || isUnavailable;\n  let validationState = isValueInvalid ? 'invalid' : null;\n  let pageDuration = (0, $7G4ZY$useMemo)(() => {\n    if (pageBehavior === 'visible') return visibleDuration;\n    return $131cf43a05231e1e$var$unitDuration(visibleDuration);\n  }, [pageBehavior, visibleDuration]);\n  return {\n    isDisabled: props.isDisabled,\n    isReadOnly: props.isReadOnly,\n    value: calendarDateValue,\n    setValue: setValue,\n    visibleRange: {\n      start: startDate,\n      end: endDate\n    },\n    minValue: minValue,\n    maxValue: maxValue,\n    focusedDate: focusedDate,\n    timeZone: timeZone,\n    validationState: validationState,\n    isValueInvalid: isValueInvalid,\n    setFocusedDate(date) {\n      focusCell(date);\n      setFocused(true);\n    },\n    focusNextDay() {\n      focusCell(focusedDate.add({\n        days: 1\n      }));\n    },\n    focusPreviousDay() {\n      focusCell(focusedDate.subtract({\n        days: 1\n      }));\n    },\n    focusNextRow() {\n      if (visibleDuration.days) this.focusNextPage();else if (visibleDuration.weeks || visibleDuration.months || visibleDuration.years) focusCell(focusedDate.add({\n        weeks: 1\n      }));\n    },\n    focusPreviousRow() {\n      if (visibleDuration.days) this.focusPreviousPage();else if (visibleDuration.weeks || visibleDuration.months || visibleDuration.years) focusCell(focusedDate.subtract({\n        weeks: 1\n      }));\n    },\n    focusNextPage() {\n      let start = startDate.add(pageDuration);\n      setFocusedDate((0, $f62d864046160412$export$4f5203c0d889109e)(focusedDate.add(pageDuration), minValue, maxValue));\n      setStartDate((0, $f62d864046160412$export$144a00ba6044eb9)((0, $f62d864046160412$export$5bb865b12696a77d)(focusedDate, start, pageDuration, locale, minValue, maxValue), pageDuration, locale));\n    },\n    focusPreviousPage() {\n      let start = startDate.subtract(pageDuration);\n      setFocusedDate((0, $f62d864046160412$export$4f5203c0d889109e)(focusedDate.subtract(pageDuration), minValue, maxValue));\n      setStartDate((0, $f62d864046160412$export$144a00ba6044eb9)((0, $f62d864046160412$export$5bb865b12696a77d)(focusedDate, start, pageDuration, locale, minValue, maxValue), pageDuration, locale));\n    },\n    focusSectionStart() {\n      if (visibleDuration.days) focusCell(startDate);else if (visibleDuration.weeks) focusCell((0, $7G4ZY$startOfWeek)(focusedDate, locale));else if (visibleDuration.months || visibleDuration.years) focusCell((0, $7G4ZY$startOfMonth)(focusedDate));\n    },\n    focusSectionEnd() {\n      if (visibleDuration.days) focusCell(endDate);else if (visibleDuration.weeks) focusCell((0, $7G4ZY$endOfWeek)(focusedDate, locale));else if (visibleDuration.months || visibleDuration.years) focusCell((0, $7G4ZY$endOfMonth)(focusedDate));\n    },\n    focusNextSection(larger) {\n      if (!larger && !visibleDuration.days) {\n        focusCell(focusedDate.add($131cf43a05231e1e$var$unitDuration(visibleDuration)));\n        return;\n      }\n      if (visibleDuration.days) this.focusNextPage();else if (visibleDuration.weeks) focusCell(focusedDate.add({\n        months: 1\n      }));else if (visibleDuration.months || visibleDuration.years) focusCell(focusedDate.add({\n        years: 1\n      }));\n    },\n    focusPreviousSection(larger) {\n      if (!larger && !visibleDuration.days) {\n        focusCell(focusedDate.subtract($131cf43a05231e1e$var$unitDuration(visibleDuration)));\n        return;\n      }\n      if (visibleDuration.days) this.focusPreviousPage();else if (visibleDuration.weeks) focusCell(focusedDate.subtract({\n        months: 1\n      }));else if (visibleDuration.months || visibleDuration.years) focusCell(focusedDate.subtract({\n        years: 1\n      }));\n    },\n    selectFocusedDate() {\n      setValue(focusedDate);\n    },\n    selectDate(date) {\n      setValue(date);\n    },\n    isFocused: isFocused,\n    setFocused: setFocused,\n    isInvalid(date) {\n      return (0, $f62d864046160412$export$eac50920cf2fd59a)(date, minValue, maxValue);\n    },\n    isSelected(date) {\n      return calendarDateValue != null && (0, $7G4ZY$isSameDay)(date, calendarDateValue) && !this.isCellDisabled(date) && !this.isCellUnavailable(date);\n    },\n    isCellFocused(date) {\n      return isFocused && focusedDate && (0, $7G4ZY$isSameDay)(date, focusedDate);\n    },\n    isCellDisabled(date) {\n      return props.isDisabled || date.compare(startDate) < 0 || date.compare(endDate) > 0 || this.isInvalid(date, minValue, maxValue);\n    },\n    isCellUnavailable(date) {\n      return props.isDateUnavailable && props.isDateUnavailable(date);\n    },\n    isPreviousVisibleRangeInvalid() {\n      let prev = startDate.subtract({\n        days: 1\n      });\n      return (0, $7G4ZY$isSameDay)(prev, startDate) || this.isInvalid(prev, minValue, maxValue);\n    },\n    isNextVisibleRangeInvalid() {\n      // Adding may return the same date if we reached the end of time\n      // according to the calendar system (e.g. 9999-12-31).\n      let next = endDate.add({\n        days: 1\n      });\n      return (0, $7G4ZY$isSameDay)(next, endDate) || this.isInvalid(next, minValue, maxValue);\n    },\n    getDatesInWeek(weekIndex) {\n      let from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startDate;\n      // let date = startOfWeek(from, locale);\n      let date = from.add({\n        weeks: weekIndex\n      });\n      let dates = [];\n      date = (0, $7G4ZY$startOfWeek)(date, locale);\n      // startOfWeek will clamp dates within the calendar system's valid range, which may\n      // start in the middle of a week. In this case, add null placeholders.\n      let dayOfWeek = (0, $7G4ZY$getDayOfWeek)(date, locale);\n      for (let i = 0; i < dayOfWeek; i++) dates.push(null);\n      while (dates.length < 7) {\n        dates.push(date);\n        let nextDate = date.add({\n          days: 1\n        });\n        if ((0, $7G4ZY$isSameDay)(date, nextDate)) break;\n        date = nextDate;\n      }\n      // Add null placeholders if at the end of the calendar system.\n      while (dates.length < 7) dates.push(null);\n      return dates;\n    }\n  };\n}\nfunction $131cf43a05231e1e$var$unitDuration(duration) {\n  let unit = {\n    ...duration\n  };\n  for (let key in duration) unit[key] = 1;\n  return unit;\n}\nexport { $131cf43a05231e1e$export$6d095e787d2b5e1f as useCalendarState };","map":{"version":3,"mappings":"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","names":["$131cf43a05231e1e$export$6d095e787d2b5e1f","props","defaultFormatter","locale","resolvedOptions","createCalendar","visibleDuration","months","minValue","maxValue","selectionAlignment","isDateUnavailable","pageBehavior","calendar","value","setControlledValue","defaultValue","onChange","calendarDateValue","timeZone","focusedCalendarDate","focusedValue","undefined","defaultFocusedCalendarDate","defaultFocusedValue","focusedDate","setFocusedDate","onFocusChange","startDate","setStartDate","isFocused","setFocused","autoFocus","endDate","duration","days","add","lastCalendarIdentifier","setLastCalendarIdentifier","identifier","newFocusedDate","compare","focusCell","date","setValue","newValue","isDisabled","isReadOnly","set","isUnavailable","isValueInvalid","isInvalid","validationState","pageDuration","$131cf43a05231e1e$var$unitDuration","visibleRange","start","end","focusNextDay","focusPreviousDay","subtract","focusNextRow","focusNextPage","weeks","years","focusPreviousRow","focusPreviousPage","focusSectionStart","focusSectionEnd","focusNextSection","larger","focusPreviousSection","selectFocusedDate","selectDate","isSelected","isCellDisabled","isCellUnavailable","isCellFocused","isPreviousVisibleRangeInvalid","prev","isNextVisibleRangeInvalid","next","getDatesInWeek","weekIndex","from","dates","dayOfWeek","i","push","length","nextDate","unit","key"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-stately\\calendar\\dist\\packages\\@react-stately\\calendar\\src\\useCalendarState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {alignCenter, alignEnd, alignStart, constrainStart, constrainValue, isInvalid, previousAvailableDate} from './utils';\nimport {\n  Calendar,\n  CalendarDate,\n  DateDuration,\n  DateFormatter,\n  endOfMonth,\n  endOfWeek,\n  getDayOfWeek,\n  GregorianCalendar,\n  isSameDay,\n  startOfMonth,\n  startOfWeek,\n  toCalendar,\n  toCalendarDate,\n  today\n} from '@internationalized/date';\nimport {CalendarProps, DateValue} from '@react-types/calendar';\nimport {CalendarState} from './types';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo, useState} from 'react';\nimport {ValidationState} from '@react-types/shared';\n\nexport interface CalendarStateOptions<T extends DateValue = DateValue> extends CalendarProps<T> {\n  /** The locale to display and edit the value according to. */\n  locale: string,\n  /**\n   * A function that creates a [Calendar](../internationalized/date/Calendar.html)\n   * object for a given calendar identifier. Such a function may be imported from the\n   * `@internationalized/date` package, or manually implemented to include support for\n   * only certain calendars.\n   */\n  createCalendar: (name: string) => Calendar,\n  /**\n   * The amount of days that will be displayed at once. This affects how pagination works.\n   * @default {months: 1}\n   */\n  visibleDuration?: DateDuration,\n  /** Determines how to align the initial selection relative to the visible date range. */\n  selectionAlignment?: 'start' | 'center' | 'end'\n}\n\n/**\n * Provides state management for a calendar component.\n * A calendar displays one or more date grids and allows users to select a single date.\n */\nexport function useCalendarState<T extends DateValue = DateValue>(props: CalendarStateOptions<T>): CalendarState {\n  let defaultFormatter = useMemo(() => new DateFormatter(props.locale), [props.locale]);\n  let resolvedOptions = useMemo(() => defaultFormatter.resolvedOptions(), [defaultFormatter]);\n  let {\n    locale,\n    createCalendar,\n    visibleDuration = {months: 1},\n    minValue,\n    maxValue,\n    selectionAlignment,\n    isDateUnavailable,\n    pageBehavior = 'visible'\n  } = props;\n  let calendar = useMemo(() => createCalendar(resolvedOptions.calendar), [createCalendar, resolvedOptions.calendar]);\n\n  let [value, setControlledValue] = useControlledState<DateValue>(props.value, props.defaultValue, props.onChange);\n  let calendarDateValue = useMemo(() => value ? toCalendar(toCalendarDate(value), calendar) : null, [value, calendar]);\n  let timeZone = useMemo(() => value && 'timeZone' in value ? value.timeZone : resolvedOptions.timeZone, [value, resolvedOptions.timeZone]);\n  let focusedCalendarDate = useMemo(() => (\n    props.focusedValue\n      ? constrainValue(toCalendar(toCalendarDate(props.focusedValue), calendar), minValue, maxValue)\n      : undefined\n  ), [props.focusedValue, calendar, minValue, maxValue]);\n  let defaultFocusedCalendarDate = useMemo(() => (\n    constrainValue(\n      props.defaultFocusedValue\n        ? toCalendar(toCalendarDate(props.defaultFocusedValue), calendar)\n        : calendarDateValue || toCalendar(today(timeZone), calendar),\n      minValue,\n      maxValue\n    )\n  ), [props.defaultFocusedValue, calendarDateValue, timeZone, calendar, minValue, maxValue]);\n  let [focusedDate, setFocusedDate] = useControlledState(focusedCalendarDate, defaultFocusedCalendarDate, props.onFocusChange);\n  let [startDate, setStartDate] = useState(() => {\n    switch (selectionAlignment) {\n      case 'start':\n        return alignStart(focusedDate, visibleDuration, locale, minValue, maxValue);\n      case 'end':\n        return alignEnd(focusedDate, visibleDuration, locale, minValue, maxValue);\n      case 'center':\n      default:\n        return alignCenter(focusedDate, visibleDuration, locale, minValue, maxValue);\n    }\n  });\n  let [isFocused, setFocused] = useState(props.autoFocus || false);\n\n  let endDate = useMemo(() => {\n    let duration = {...visibleDuration};\n    if (duration.days) {\n      duration.days--;\n    } else {\n      duration.days = -1;\n    }\n    return startDate.add(duration);\n  }, [startDate, visibleDuration]);\n\n  // Reset focused date and visible range when calendar changes.\n  let [lastCalendarIdentifier, setLastCalendarIdentifier] = useState(calendar.identifier);\n  if (calendar.identifier !== lastCalendarIdentifier) {\n    let newFocusedDate = toCalendar(focusedDate, calendar);\n    setStartDate(alignCenter(newFocusedDate, visibleDuration, locale, minValue, maxValue));\n    setFocusedDate(newFocusedDate);\n    setLastCalendarIdentifier(calendar.identifier);\n  }\n\n  if (isInvalid(focusedDate, minValue, maxValue)) {\n    // If the focused date was moved to an invalid value, it can't be focused, so constrain it.\n    setFocusedDate(constrainValue(focusedDate, minValue, maxValue));\n  } else if (focusedDate.compare(startDate) < 0) {\n    setStartDate(alignEnd(focusedDate, visibleDuration, locale, minValue, maxValue));\n  } else if (focusedDate.compare(endDate) > 0) {\n    setStartDate(alignStart(focusedDate, visibleDuration, locale, minValue, maxValue));\n  }\n\n  // Sets focus to a specific cell date\n  function focusCell(date: CalendarDate) {\n    date = constrainValue(date, minValue, maxValue);\n    setFocusedDate(date);\n  }\n\n  function setValue(newValue: CalendarDate | null) {\n    if (!props.isDisabled && !props.isReadOnly) {\n      if (newValue === null) {\n        setControlledValue(null);\n        return;\n      }\n      newValue = constrainValue(newValue, minValue, maxValue);\n      newValue = previousAvailableDate(newValue, startDate, isDateUnavailable);\n      if (!newValue) {\n        return;\n      }\n\n      // The display calendar should not have any effect on the emitted value.\n      // Emit dates in the same calendar as the original value, if any, otherwise gregorian.\n      newValue = toCalendar(newValue, value?.calendar || new GregorianCalendar());\n\n      // Preserve time if the input value had one.\n      if (value && 'hour' in value) {\n        setControlledValue(value.set(newValue));\n      } else {\n        setControlledValue(newValue);\n      }\n    }\n  }\n\n  let isUnavailable = useMemo(() => {\n    if (!calendarDateValue) {\n      return false;\n    }\n\n    if (isDateUnavailable && isDateUnavailable(calendarDateValue)) {\n      return true;\n    }\n\n    return isInvalid(calendarDateValue, minValue, maxValue);\n  }, [calendarDateValue, isDateUnavailable, minValue, maxValue]);\n  let isValueInvalid = props.isInvalid || props.validationState === 'invalid' || isUnavailable;\n  let validationState: ValidationState = isValueInvalid ? 'invalid' : null;\n\n  let pageDuration = useMemo(() => {\n    if (pageBehavior === 'visible') {\n      return visibleDuration;\n    }\n\n    return unitDuration(visibleDuration);\n  }, [pageBehavior, visibleDuration]);\n\n  return {\n    isDisabled: props.isDisabled,\n    isReadOnly: props.isReadOnly,\n    value: calendarDateValue,\n    setValue,\n    visibleRange: {\n      start: startDate,\n      end: endDate\n    },\n    minValue,\n    maxValue,\n    focusedDate,\n    timeZone,\n    validationState,\n    isValueInvalid,\n    setFocusedDate(date) {\n      focusCell(date);\n      setFocused(true);\n    },\n    focusNextDay() {\n      focusCell(focusedDate.add({days: 1}));\n    },\n    focusPreviousDay() {\n      focusCell(focusedDate.subtract({days: 1}));\n    },\n    focusNextRow() {\n      if (visibleDuration.days) {\n        this.focusNextPage();\n      } else if (visibleDuration.weeks || visibleDuration.months || visibleDuration.years) {\n        focusCell(focusedDate.add({weeks: 1}));\n      }\n    },\n    focusPreviousRow() {\n      if (visibleDuration.days) {\n        this.focusPreviousPage();\n      } else if (visibleDuration.weeks || visibleDuration.months || visibleDuration.years) {\n        focusCell(focusedDate.subtract({weeks: 1}));\n      }\n    },\n    focusNextPage() {\n      let start = startDate.add(pageDuration);\n      setFocusedDate(constrainValue(focusedDate.add(pageDuration), minValue, maxValue));\n      setStartDate(\n        alignStart(\n          constrainStart(focusedDate, start, pageDuration, locale, minValue, maxValue),\n          pageDuration,\n          locale\n        )\n      );\n    },\n    focusPreviousPage() {\n      let start = startDate.subtract(pageDuration);\n      setFocusedDate(constrainValue(focusedDate.subtract(pageDuration), minValue, maxValue));\n      setStartDate(\n        alignStart(\n          constrainStart(focusedDate, start, pageDuration, locale, minValue, maxValue),\n          pageDuration,\n          locale\n        )\n      );\n    },\n    focusSectionStart() {\n      if (visibleDuration.days) {\n        focusCell(startDate);\n      } else if (visibleDuration.weeks) {\n        focusCell(startOfWeek(focusedDate, locale));\n      } else if (visibleDuration.months || visibleDuration.years) {\n        focusCell(startOfMonth(focusedDate));\n      }\n    },\n    focusSectionEnd() {\n      if (visibleDuration.days) {\n        focusCell(endDate);\n      } else if (visibleDuration.weeks) {\n        focusCell(endOfWeek(focusedDate, locale));\n      } else if (visibleDuration.months || visibleDuration.years) {\n        focusCell(endOfMonth(focusedDate));\n      }\n    },\n    focusNextSection(larger) {\n      if (!larger && !visibleDuration.days) {\n        focusCell(focusedDate.add(unitDuration(visibleDuration)));\n        return;\n      }\n\n      if (visibleDuration.days) {\n        this.focusNextPage();\n      } else if (visibleDuration.weeks) {\n        focusCell(focusedDate.add({months: 1}));\n      } else if (visibleDuration.months || visibleDuration.years) {\n        focusCell(focusedDate.add({years: 1}));\n      }\n    },\n    focusPreviousSection(larger) {\n      if (!larger && !visibleDuration.days) {\n        focusCell(focusedDate.subtract(unitDuration(visibleDuration)));\n        return;\n      }\n\n      if (visibleDuration.days) {\n        this.focusPreviousPage();\n      } else if (visibleDuration.weeks) {\n        focusCell(focusedDate.subtract({months: 1}));\n      } else if (visibleDuration.months || visibleDuration.years) {\n        focusCell(focusedDate.subtract({years: 1}));\n      }\n    },\n    selectFocusedDate() {\n      setValue(focusedDate);\n    },\n    selectDate(date) {\n      setValue(date);\n    },\n    isFocused,\n    setFocused,\n    isInvalid(date) {\n      return isInvalid(date, minValue, maxValue);\n    },\n    isSelected(date) {\n      return calendarDateValue != null && isSameDay(date, calendarDateValue) && !this.isCellDisabled(date) && !this.isCellUnavailable(date);\n    },\n    isCellFocused(date) {\n      return isFocused && focusedDate && isSameDay(date, focusedDate);\n    },\n    isCellDisabled(date) {\n      return props.isDisabled || date.compare(startDate) < 0 || date.compare(endDate) > 0 || this.isInvalid(date, minValue, maxValue);\n    },\n    isCellUnavailable(date) {\n      return props.isDateUnavailable && props.isDateUnavailable(date);\n    },\n    isPreviousVisibleRangeInvalid() {\n      let prev = startDate.subtract({days: 1});\n      return isSameDay(prev, startDate) || this.isInvalid(prev, minValue, maxValue);\n    },\n    isNextVisibleRangeInvalid() {\n      // Adding may return the same date if we reached the end of time\n      // according to the calendar system (e.g. 9999-12-31).\n      let next = endDate.add({days: 1});\n      return isSameDay(next, endDate) || this.isInvalid(next, minValue, maxValue);\n    },\n    getDatesInWeek(weekIndex, from = startDate) {\n      // let date = startOfWeek(from, locale);\n      let date = from.add({weeks: weekIndex});\n      let dates = [];\n\n      date = startOfWeek(date, locale);\n\n      // startOfWeek will clamp dates within the calendar system's valid range, which may\n      // start in the middle of a week. In this case, add null placeholders.\n      let dayOfWeek = getDayOfWeek(date, locale);\n      for (let i = 0; i < dayOfWeek; i++) {\n        dates.push(null);\n      }\n\n      while (dates.length < 7) {\n        dates.push(date);\n        let nextDate = date.add({days: 1});\n        if (isSameDay(date, nextDate)) {\n          // If the next day is the same, we have hit the end of the calendar system.\n          break;\n        }\n        date = nextDate;\n      }\n\n      // Add null placeholders if at the end of the calendar system.\n      while (dates.length < 7) {\n        dates.push(null);\n      }\n\n      return dates;\n    }\n  };\n}\n\nfunction unitDuration(duration: DateDuration) {\n  let unit = {...duration};\n  for (let key in duration) {\n    unit[key] = 1;\n  }\n  return unit;\n}\n"]},"metadata":{},"sourceType":"module"}