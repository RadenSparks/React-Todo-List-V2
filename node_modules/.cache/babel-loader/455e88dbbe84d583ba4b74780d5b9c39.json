{"ast":null,"code":"import { TableColumnLayout as $a9e7ae544a4e41dd$export$7ff77a162970b30e } from \"./TableColumnLayout.mjs\";\nimport { useState as $cPT3l$useState, useMemo as $cPT3l$useMemo, useCallback as $cPT3l$useCallback } from \"react\";\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $292bc4e09cd0eb62$export$cb895dcf85db1319(props, state) {\n  let {\n    getDefaultWidth: getDefaultWidth,\n    getDefaultMinWidth: getDefaultMinWidth,\n    tableWidth = 0\n  } = props;\n  let [resizingColumn, setResizingColumn] = (0, $cPT3l$useState)(null);\n  let columnLayout = (0, $cPT3l$useMemo)(() => new (0, $a9e7ae544a4e41dd$export$7ff77a162970b30e)({\n    getDefaultWidth: getDefaultWidth,\n    getDefaultMinWidth: getDefaultMinWidth\n  }), [getDefaultWidth, getDefaultMinWidth]);\n  let [controlledColumns, uncontrolledColumns] = (0, $cPT3l$useMemo)(() => columnLayout.splitColumnsIntoControlledAndUncontrolled(state.collection.columns), [state.collection.columns, columnLayout]);\n  // uncontrolled column widths\n  let [uncontrolledWidths, setUncontrolledWidths] = (0, $cPT3l$useState)(() => columnLayout.getInitialUncontrolledWidths(uncontrolledColumns));\n  // Update uncontrolled widths if the columns changed.\n  let [lastColumns, setLastColumns] = (0, $cPT3l$useState)(state.collection.columns);\n  if (state.collection.columns !== lastColumns) {\n    if (state.collection.columns.length !== lastColumns.length || state.collection.columns.some((c, i) => c.key !== lastColumns[i].key)) {\n      let newUncontrolledWidths = columnLayout.getInitialUncontrolledWidths(uncontrolledColumns);\n      setUncontrolledWidths(newUncontrolledWidths);\n    }\n    setLastColumns(state.collection.columns);\n  }\n  // combine columns back into one map that maintains same order as the columns\n  let colWidths = (0, $cPT3l$useMemo)(() => columnLayout.recombineColumns(state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns), [state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns, columnLayout]);\n  let startResize = (0, $cPT3l$useCallback)(key => {\n    setResizingColumn(key);\n  }, [setResizingColumn]);\n  let updateResizedColumns = (0, $cPT3l$useCallback)((key, width) => {\n    let newControlled = new Map(Array.from(controlledColumns).map(_ref => {\n      let [key, entry] = _ref;\n      return [key, entry.props.width];\n    }));\n    let newSizes = columnLayout.resizeColumnWidth(tableWidth, state.collection, newControlled, uncontrolledWidths, key, width);\n    let map = new Map(Array.from(uncontrolledColumns).map(_ref2 => {\n      let [key] = _ref2;\n      return [key, newSizes.get(key)];\n    }));\n    map.set(key, width);\n    setUncontrolledWidths(map);\n    return newSizes;\n  }, [controlledColumns, uncontrolledColumns, setUncontrolledWidths, tableWidth, columnLayout, state.collection, uncontrolledWidths]);\n  let endResize = (0, $cPT3l$useCallback)(() => {\n    setResizingColumn(null);\n  }, [setResizingColumn]);\n  (0, $cPT3l$useMemo)(() => columnLayout.buildColumnWidths(tableWidth, state.collection, colWidths), [tableWidth, state.collection, colWidths, columnLayout]);\n  return (0, $cPT3l$useMemo)(() => ({\n    resizingColumn: resizingColumn,\n    updateResizedColumns: updateResizedColumns,\n    startResize: startResize,\n    endResize: endResize,\n    getColumnWidth: key => columnLayout.getColumnWidth(key),\n    getColumnMinWidth: key => columnLayout.getColumnMinWidth(key),\n    getColumnMaxWidth: key => columnLayout.getColumnMaxWidth(key),\n    tableState: state\n  }), [columnLayout, resizingColumn, updateResizedColumns, startResize, endResize, state]);\n}\nexport { $292bc4e09cd0eb62$export$cb895dcf85db1319 as useTableColumnResizeState };","map":{"version":3,"mappings":"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","names":["$292bc4e09cd0eb62$export$cb895dcf85db1319","props","state","getDefaultWidth","getDefaultMinWidth","tableWidth","resizingColumn","setResizingColumn","columnLayout","controlledColumns","uncontrolledColumns","splitColumnsIntoControlledAndUncontrolled","collection","columns","uncontrolledWidths","setUncontrolledWidths","getInitialUncontrolledWidths","lastColumns","setLastColumns","length","some","c","i","key","newUncontrolledWidths","colWidths","recombineColumns","startResize","updateResizedColumns","width","newControlled","Map","Array","from","map","_ref","entry","newSizes","resizeColumnWidth","_ref2","get","set","endResize","buildColumnWidths","getColumnWidth","getColumnMinWidth","getColumnMaxWidth","tableState"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-stately\\table\\dist\\packages\\@react-stately\\table\\src\\useTableColumnResizeState.ts"],"sourcesContent":["/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {ColumnSize} from '@react-types/table';\nimport {GridNode} from '@react-types/grid';\nimport {Key} from '@react-types/shared';\nimport {TableColumnLayout} from './TableColumnLayout';\nimport {TableState} from './useTableState';\nimport {useCallback, useMemo, useState} from 'react';\n\nexport interface TableColumnResizeStateProps<T> {\n  /**\n   * Current width of the table or table viewport that the columns\n   * should be calculated against.\n   */\n  tableWidth: number,\n  /** A function that is called to find the default width for a given column. */\n  getDefaultWidth?: (node: GridNode<T>) => ColumnSize | null | undefined,\n  /** A function that is called to find the default minWidth for a given column. */\n  getDefaultMinWidth?: (node: GridNode<T>) => ColumnSize | null | undefined\n}\nexport interface TableColumnResizeState<T> {\n  /**\n   * Called to update the state that a resize event has occurred.\n   * Returns the new widths for all columns based on the resized column.\n   */\n  updateResizedColumns: (key: Key, width: number) => Map<Key, ColumnSize>,\n  /** Callback for when onColumnResize has started. */\n  startResize: (key: Key) => void,\n  /** Callback for when onColumnResize has ended. */\n  endResize: () => void,\n  /** Gets the current width for the specified column. */\n  getColumnWidth: (key: Key) => number,\n  /** Gets the current minWidth for the specified column. */\n  getColumnMinWidth: (key: Key) => number,\n  /** Gets the current maxWidth for the specified column. */\n  getColumnMaxWidth: (key: Key) => number,\n  /** Key of the currently resizing column. */\n  resizingColumn: Key | null,\n  /** A reference to the table state. */\n  tableState: TableState<T>\n}\n\n/**\n * Provides column width state management for a table component with column resizing support. Handles building\n * a map of column widths calculated from the table's width and any provided column width information from the collection.\n * In addition, it tracks the currently resizing column and provides callbacks for updating the widths upon resize operations.\n * @param props - Props for the table.\n * @param state - State for the table, as returned by `useTableState`.\n */\nexport function useTableColumnResizeState<T>(props: TableColumnResizeStateProps<T>, state: TableState<T>): TableColumnResizeState<T> {\n  let {\n    getDefaultWidth,\n    getDefaultMinWidth,\n    tableWidth = 0\n  } = props;\n\n  let [resizingColumn, setResizingColumn] = useState<Key | null>(null);\n  let columnLayout = useMemo(\n    () => new TableColumnLayout({\n      getDefaultWidth,\n      getDefaultMinWidth\n    }),\n    [getDefaultWidth, getDefaultMinWidth]\n  );\n\n  let [controlledColumns, uncontrolledColumns] = useMemo(() =>\n      columnLayout.splitColumnsIntoControlledAndUncontrolled(state.collection.columns)\n  , [state.collection.columns, columnLayout]);\n\n  // uncontrolled column widths\n  let [uncontrolledWidths, setUncontrolledWidths] = useState(() =>\n    columnLayout.getInitialUncontrolledWidths(uncontrolledColumns)\n  );\n\n  // Update uncontrolled widths if the columns changed.\n  let [lastColumns, setLastColumns] = useState(state.collection.columns);\n  if (state.collection.columns !== lastColumns) {\n    if (\n      state.collection.columns.length !== lastColumns.length ||\n      state.collection.columns.some((c, i) => c.key !== lastColumns[i].key)\n    ) {\n      let newUncontrolledWidths = columnLayout.getInitialUncontrolledWidths(uncontrolledColumns);\n      setUncontrolledWidths(newUncontrolledWidths);\n    }\n    setLastColumns(state.collection.columns);\n  }\n\n  // combine columns back into one map that maintains same order as the columns\n  let colWidths = useMemo(() =>\n      columnLayout.recombineColumns(state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns)\n  , [state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns, columnLayout]);\n\n  let startResize = useCallback((key: Key) => {\n    setResizingColumn(key);\n  }, [setResizingColumn]);\n\n  let updateResizedColumns = useCallback((key: Key, width: number): Map<Key, ColumnSize> => {\n    let newControlled = new Map(Array.from(controlledColumns).map(([key, entry]) => [key, entry.props.width]));\n    let newSizes = columnLayout.resizeColumnWidth(tableWidth, state.collection, newControlled, uncontrolledWidths, key, width);\n\n    let map = new Map(Array.from(uncontrolledColumns).map(([key]) => [key, newSizes.get(key)]));\n    map.set(key, width);\n    setUncontrolledWidths(map);\n    return newSizes;\n  }, [controlledColumns, uncontrolledColumns, setUncontrolledWidths, tableWidth, columnLayout, state.collection, uncontrolledWidths]);\n\n  let endResize = useCallback(() => {\n    setResizingColumn(null);\n  }, [setResizingColumn]);\n\n  useMemo(() =>\n    columnLayout.buildColumnWidths(tableWidth, state.collection, colWidths)\n  , [tableWidth, state.collection, colWidths, columnLayout]);\n\n  return useMemo(() => ({\n    resizingColumn,\n    updateResizedColumns,\n    startResize,\n    endResize,\n    getColumnWidth: (key: Key) =>\n      columnLayout.getColumnWidth(key),\n    getColumnMinWidth: (key: Key) =>\n      columnLayout.getColumnMinWidth(key),\n    getColumnMaxWidth: (key: Key) =>\n      columnLayout.getColumnMaxWidth(key),\n    tableState: state\n  }), [\n    columnLayout,\n    resizingColumn,\n    updateResizedColumns,\n    startResize,\n    endResize,\n    state\n  ]);\n}\n"]},"metadata":{},"sourceType":"module"}