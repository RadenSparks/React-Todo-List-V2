{"ast":null,"code":"import { TableCollection as $788781baa30117fa$export$596e1b2e2cf93690 } from \"./TableCollection.mjs\";\nimport { useTableState as $4a0dd036d492cee4$export$907bcc6c48325fd6 } from \"./useTableState.mjs\";\nimport { CollectionBuilder as $2Mvwf$CollectionBuilder } from \"@react-stately/collections\";\nimport { useMemo as $2Mvwf$useMemo } from \"react\";\nimport { tableNestedRows as $2Mvwf$tableNestedRows } from \"@react-stately/flags\";\nimport { useControlledState as $2Mvwf$useControlledState } from \"@react-stately/utils\";\n\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $ee65a0057fd99531$export$34dfa8a1622185a4(props) {\n  let {\n    selectionMode = 'none',\n    showSelectionCheckboxes: showSelectionCheckboxes,\n    showDragButtons: showDragButtons,\n    UNSTABLE_expandedKeys: propExpandedKeys,\n    UNSTABLE_defaultExpandedKeys: propDefaultExpandedKeys,\n    UNSTABLE_onExpandedChange: UNSTABLE_onExpandedChange,\n    children: children\n  } = props;\n  if (!(0, $2Mvwf$tableNestedRows)()) throw new Error('Feature flag for table nested rows must be enabled to use useTreeGridState.');\n  let [expandedKeys, setExpandedKeys] = (0, $2Mvwf$useControlledState)(propExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propExpandedKeys) : undefined, propDefaultExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propDefaultExpandedKeys) : new Set(), UNSTABLE_onExpandedChange);\n  let context = (0, $2Mvwf$useMemo)(() => ({\n    showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== 'none',\n    showDragButtons: showDragButtons,\n    selectionMode: selectionMode,\n    columns: []\n  }), [children, showSelectionCheckboxes, selectionMode, showDragButtons]);\n  let builder = (0, $2Mvwf$useMemo)(() => new (0, $2Mvwf$CollectionBuilder)(), []);\n  let nodes = (0, $2Mvwf$useMemo)(() => builder.build({\n    children: children\n  }, context), [builder, children, context]);\n  let treeGridCollection = (0, $2Mvwf$useMemo)(() => {\n    return $ee65a0057fd99531$var$generateTreeGridCollection(nodes, {\n      showSelectionCheckboxes: showSelectionCheckboxes,\n      showDragButtons: showDragButtons,\n      expandedKeys: expandedKeys\n    });\n  }, [nodes, showSelectionCheckboxes, showDragButtons, expandedKeys]);\n  let onToggle = key => {\n    setExpandedKeys($ee65a0057fd99531$var$toggleKey(expandedKeys, key, treeGridCollection));\n  };\n  let collection = (0, $2Mvwf$useMemo)(() => {\n    return new (0, $788781baa30117fa$export$596e1b2e2cf93690)(treeGridCollection.tableNodes, null, context);\n  }, [context, treeGridCollection.tableNodes]);\n  let tableState = (0, $4a0dd036d492cee4$export$907bcc6c48325fd6)({\n    ...props,\n    collection: collection\n  });\n  return {\n    ...tableState,\n    keyMap: treeGridCollection.keyMap,\n    userColumnCount: treeGridCollection.userColumnCount,\n    expandedKeys: expandedKeys,\n    toggleKey: onToggle\n  };\n}\nfunction $ee65a0057fd99531$var$toggleKey(currentExpandedKeys, key, collection) {\n  let updatedExpandedKeys;\n  if (currentExpandedKeys === 'all') {\n    updatedExpandedKeys = new Set(collection.flattenedRows.filter(row => row.props.UNSTABLE_childItems || row.props.children.length > collection.userColumnCount).map(row => row.key));\n    updatedExpandedKeys.delete(key);\n  } else {\n    updatedExpandedKeys = new Set(currentExpandedKeys);\n    if (updatedExpandedKeys.has(key)) updatedExpandedKeys.delete(key);else updatedExpandedKeys.add(key);\n  }\n  return updatedExpandedKeys;\n}\nfunction $ee65a0057fd99531$var$convertExpanded(expanded) {\n  if (!expanded) return new Set();\n  return expanded === 'all' ? 'all' : new Set(expanded);\n}\nfunction $ee65a0057fd99531$var$generateTreeGridCollection(nodes, opts) {\n  let {\n    expandedKeys = new Set()\n  } = opts;\n  let body;\n  let flattenedRows = [];\n  let columnCount = 0;\n  let userColumnCount = 0;\n  let originalColumns = [];\n  let keyMap = new Map();\n  if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) columnCount++;\n  if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) columnCount++;\n  let topLevelRows = [];\n  let visit = node => {\n    switch (node.type) {\n      case 'body':\n        body = node;\n        keyMap.set(body.key, body);\n        break;\n      case 'column':\n        if (!node.hasChildNodes) userColumnCount++;\n        break;\n      case 'item':\n        topLevelRows.push(node);\n        return;\n    }\n    for (let child of node.childNodes) visit(child);\n  };\n  for (let node of nodes) {\n    if (node.type === 'column') originalColumns.push(node);\n    visit(node);\n  }\n  columnCount += userColumnCount;\n  // Update each grid node in the treegrid table with values specific to a treegrid structure. Also store a set of flattened row nodes for TableCollection to consume\n  let globalRowCount = 0;\n  let visitNode = (node, i) => {\n    // Clone row node and its children so modifications to the node for treegrid specific values aren't applied on the nodes provided\n    // to TableCollection. Index, level, and parent keys are all changed to reflect a flattened row structure rather than the treegrid structure\n    // values automatically calculated via CollectionBuilder\n    if (node.type === 'item') {\n      let childNodes = [];\n      for (let child of node.childNodes) if (child.type === 'cell') {\n        let cellClone = {\n          ...child\n        };\n        if (cellClone.index + 1 === columnCount) cellClone.nextKey = null;\n        childNodes.push({\n          ...cellClone\n        });\n      }\n      let clone = {\n        ...node,\n        childNodes: childNodes,\n        parentKey: body.key,\n        level: 1,\n        index: globalRowCount++\n      };\n      flattenedRows.push(clone);\n    }\n    let newProps = {};\n    // Assign indexOfType to cells and rows for aria-posinset\n    if (node.type !== 'placeholder' && node.type !== 'column') newProps['indexOfType'] = i;\n    // Use Object.assign instead of spread to preserve object reference for keyMap. Also ensures retrieving nodes\n    // via .childNodes returns the same object as the one found via keyMap look up\n    Object.assign(node, newProps);\n    keyMap.set(node.key, node);\n    let lastNode;\n    let rowIndex = 0;\n    for (let child of node.childNodes) if (!(child.type === 'item' && expandedKeys !== 'all' && !expandedKeys.has(node.key))) {\n      if (child.parentKey == null)\n        // if child is a cell/expanded row/column and the parent key isn't already established by the collection, match child node to parent row\n        child.parentKey = node.key;\n      if (lastNode) {\n        lastNode.nextKey = child.key;\n        child.prevKey = lastNode.key;\n      } else child.prevKey = null;\n      if (child.type === 'item') visitNode(child, rowIndex++);else\n        // We enforce that the cells come before rows so can just reuse cell index\n        visitNode(child, child.index);\n      lastNode = child;\n    }\n    if (lastNode) lastNode.nextKey = null;\n  };\n  let last;\n  topLevelRows.forEach((node, i) => {\n    visitNode(node, i);\n    if (last) {\n      last.nextKey = node.key;\n      node.prevKey = last.key;\n    } else node.prevKey = null;\n    last = node;\n  });\n  if (last) last.nextKey = null;\n  return {\n    keyMap: keyMap,\n    userColumnCount: userColumnCount,\n    flattenedRows: flattenedRows,\n    tableNodes: [...originalColumns, {\n      ...body,\n      childNodes: flattenedRows\n    }]\n  };\n}\nexport { $ee65a0057fd99531$export$34dfa8a1622185a4 as UNSTABLE_useTreeGridState };","map":{"version":3,"mappings":"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","names":["$ee65a0057fd99531$export$34dfa8a1622185a4","props","selectionMode","showSelectionCheckboxes","showDragButtons","UNSTABLE_expandedKeys","propExpandedKeys","UNSTABLE_defaultExpandedKeys","propDefaultExpandedKeys","UNSTABLE_onExpandedChange","children","Error","expandedKeys","setExpandedKeys","$ee65a0057fd99531$var$convertExpanded","undefined","Set","context","columns","builder","nodes","build","treeGridCollection","$ee65a0057fd99531$var$generateTreeGridCollection","onToggle","key","$ee65a0057fd99531$var$toggleKey","collection","tableNodes","tableState","keyMap","userColumnCount","toggleKey","currentExpandedKeys","updatedExpandedKeys","flattenedRows","filter","row","UNSTABLE_childItems","length","map","delete","has","add","expanded","opts","body","columnCount","originalColumns","Map","topLevelRows","visit","node","type","set","hasChildNodes","push","child","childNodes","globalRowCount","visitNode","i","cellClone","index","nextKey","clone","parentKey","level","newProps","Object","assign","lastNode","rowIndex","prevKey","last","forEach"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-stately\\table\\dist\\packages\\@react-stately\\table\\src\\useTreeGridState.ts"],"sourcesContent":["/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBuilder} from '@react-stately/collections';\nimport {GridNode} from '@react-types/grid';\nimport {Key} from '@react-types/shared';\nimport {ReactElement, useMemo} from 'react';\nimport {TableCollection} from './TableCollection';\nimport {tableNestedRows} from '@react-stately/flags';\nimport {TableState, TableStateProps, useTableState} from './useTableState';\nimport {useControlledState} from '@react-stately/utils';\n\nexport interface TreeGridState<T> extends TableState<T> {\n  /** A set of keys for items that are expanded. */\n  expandedKeys: 'all' | Set<Key>,\n  /** Toggles the expanded state for a row by its key. */\n  toggleKey(key: Key): void,\n  /** The key map containing nodes representing the collection's tree grid structure. */\n  keyMap: Map<Key, GridNode<T>>,\n  /** The number of leaf columns provided by the user. */\n  userColumnCount: number\n}\n\nexport interface TreeGridStateProps<T> extends Omit<TableStateProps<T>, 'collection'> {\n  /** The currently expanded keys in the collection (controlled). */\n  UNSTABLE_expandedKeys?: 'all' | Iterable<Key>,\n  /** The initial expanded keys in the collection (uncontrolled). */\n  UNSTABLE_defaultExpandedKeys?: 'all' | Iterable<Key>,\n  /** Handler that is called when items are expanded or collapsed. */\n  UNSTABLE_onExpandedChange?: (keys: Set<Key>) => any\n}\n\n/**\n * Provides state management for a tree grid component. Handles building a collection\n * of columns and rows from props. In addition, it tracks and manages expanded rows, row selection, and sort order changes.\n */\nexport function UNSTABLE_useTreeGridState<T extends object>(props: TreeGridStateProps<T>): TreeGridState<T> {\n  let {\n    selectionMode = 'none',\n    showSelectionCheckboxes,\n    showDragButtons,\n    UNSTABLE_expandedKeys: propExpandedKeys,\n    UNSTABLE_defaultExpandedKeys: propDefaultExpandedKeys,\n    UNSTABLE_onExpandedChange,\n    children\n  } = props;\n\n  if (!tableNestedRows()) {\n    throw new Error('Feature flag for table nested rows must be enabled to use useTreeGridState.');\n  }\n\n  let [expandedKeys, setExpandedKeys] = useControlledState(\n    propExpandedKeys ? convertExpanded(propExpandedKeys) : undefined,\n    propDefaultExpandedKeys ? convertExpanded(propDefaultExpandedKeys) : new Set(),\n    UNSTABLE_onExpandedChange\n  );\n\n  let context = useMemo(() => ({\n    showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== 'none',\n    showDragButtons: showDragButtons,\n    selectionMode,\n    columns: []\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }), [children, showSelectionCheckboxes, selectionMode, showDragButtons]);\n\n  let builder = useMemo(() => new CollectionBuilder<T>(), []);\n  let nodes = useMemo(() => builder.build({children: children as ReactElement[]}, context), [builder, children, context]);\n  let treeGridCollection = useMemo(() => {\n    return generateTreeGridCollection<T>(nodes, {showSelectionCheckboxes, showDragButtons, expandedKeys});\n  }, [nodes, showSelectionCheckboxes, showDragButtons, expandedKeys]);\n\n  let onToggle = (key: Key) => {\n    setExpandedKeys(toggleKey(expandedKeys, key, treeGridCollection));\n  };\n\n  let collection = useMemo(() => {\n    return new TableCollection(treeGridCollection.tableNodes, null, context);\n  }, [context, treeGridCollection.tableNodes]);\n\n  let tableState = useTableState({...props, collection});\n  return {\n    ...tableState,\n    keyMap: treeGridCollection.keyMap,\n    userColumnCount: treeGridCollection.userColumnCount,\n    expandedKeys,\n    toggleKey: onToggle\n  };\n}\n\nfunction toggleKey<T>(currentExpandedKeys: 'all' | Set<Key>, key: Key, collection: TreeGridCollection<T>): Set<Key> {\n  let updatedExpandedKeys: Set<Key>;\n  if (currentExpandedKeys === 'all') {\n    updatedExpandedKeys = new Set(collection.flattenedRows.filter(row => row.props.UNSTABLE_childItems || row.props.children.length > collection.userColumnCount).map(row => row.key));\n    updatedExpandedKeys.delete(key);\n  } else {\n    updatedExpandedKeys = new Set(currentExpandedKeys);\n    if (updatedExpandedKeys.has(key)) {\n      updatedExpandedKeys.delete(key);\n    } else {\n      updatedExpandedKeys.add(key);\n    }\n  }\n\n  return updatedExpandedKeys;\n}\n\nfunction convertExpanded(expanded: 'all' | Iterable<Key>): 'all' | Set<Key> {\n  if (!expanded) {\n    return new Set<Key>();\n  }\n\n  return expanded === 'all'\n    ? 'all'\n    : new Set(expanded);\n}\n\ninterface TreeGridCollectionOptions {\n  showSelectionCheckboxes?: boolean,\n  showDragButtons?: boolean,\n  expandedKeys: 'all' | Set<Key>\n}\n\ninterface TreeGridCollection<T> {\n  keyMap: Map<Key, GridNode<T>>,\n  tableNodes: GridNode<T>[],\n  flattenedRows: GridNode<T>[],\n  userColumnCount: number\n}\nfunction generateTreeGridCollection<T>(nodes, opts: TreeGridCollectionOptions): TreeGridCollection<T> {\n  let {\n    expandedKeys = new Set()\n  } = opts;\n\n  let body: GridNode<T>;\n  let flattenedRows = [];\n  let columnCount = 0;\n  let userColumnCount = 0;\n  let originalColumns = [];\n  let keyMap = new Map();\n\n  if (opts?.showSelectionCheckboxes) {\n    columnCount++;\n  }\n\n  if (opts?.showDragButtons) {\n    columnCount++;\n  }\n\n  let topLevelRows = [];\n  let visit = (node: GridNode<T>) => {\n    switch (node.type) {\n      case 'body':\n        body = node;\n        keyMap.set(body.key, body);\n        break;\n      case 'column':\n        if (!node.hasChildNodes) {\n          userColumnCount++;\n        }\n        break;\n      case 'item':\n        topLevelRows.push(node);\n        return;\n    }\n\n    for (let child of node.childNodes) {\n      visit(child);\n    }\n  };\n\n  for (let node of nodes) {\n    if (node.type === 'column') {\n      originalColumns.push(node);\n    }\n    visit(node);\n  }\n  columnCount += userColumnCount;\n\n  // Update each grid node in the treegrid table with values specific to a treegrid structure. Also store a set of flattened row nodes for TableCollection to consume\n  let globalRowCount = 0;\n  let visitNode = (node: GridNode<T>, i?: number) => {\n    // Clone row node and its children so modifications to the node for treegrid specific values aren't applied on the nodes provided\n    // to TableCollection. Index, level, and parent keys are all changed to reflect a flattened row structure rather than the treegrid structure\n    // values automatically calculated via CollectionBuilder\n    if (node.type === 'item') {\n      let childNodes = [];\n      for (let child of node.childNodes) {\n        if (child.type === 'cell') {\n          let cellClone = {...child};\n          if (cellClone.index + 1 === columnCount) {\n            cellClone.nextKey = null;\n          }\n          childNodes.push({...cellClone});\n        }\n      }\n      let clone = {...node, childNodes: childNodes, parentKey: body.key, level: 1, index: globalRowCount++};\n      flattenedRows.push(clone);\n    }\n\n    let newProps = {};\n\n    // Assign indexOfType to cells and rows for aria-posinset\n    if (node.type !== 'placeholder' && node.type !== 'column') {\n      newProps['indexOfType'] = i;\n    }\n\n    // Use Object.assign instead of spread to preserve object reference for keyMap. Also ensures retrieving nodes\n    // via .childNodes returns the same object as the one found via keyMap look up\n    Object.assign(node, newProps);\n    keyMap.set(node.key, node);\n\n    let lastNode: GridNode<T>;\n    let rowIndex = 0;\n    for (let child of node.childNodes) {\n      if (!(child.type === 'item' && expandedKeys !== 'all' && !expandedKeys.has(node.key))) {\n        if (child.parentKey == null) {\n          // if child is a cell/expanded row/column and the parent key isn't already established by the collection, match child node to parent row\n          child.parentKey = node.key;\n        }\n\n        if (lastNode) {\n          lastNode.nextKey = child.key;\n          child.prevKey = lastNode.key;\n        } else {\n          child.prevKey = null;\n        }\n\n        if (child.type === 'item') {\n          visitNode(child, rowIndex++);\n        } else {\n          // We enforce that the cells come before rows so can just reuse cell index\n          visitNode(child, child.index);\n        }\n\n        lastNode = child;\n      }\n    }\n\n    if (lastNode) {\n      lastNode.nextKey = null;\n    }\n  };\n\n  let last: GridNode<T>;\n  topLevelRows.forEach((node: GridNode<T>, i) => {\n    visitNode(node as GridNode<T>, i);\n\n    if (last) {\n      last.nextKey = node.key;\n      node.prevKey = last.key;\n    } else {\n      node.prevKey = null;\n    }\n\n    last = node;\n  });\n\n  if (last) {\n    last.nextKey = null;\n  }\n\n  return {\n    keyMap,\n    userColumnCount,\n    flattenedRows,\n    tableNodes: [...originalColumns, {...body, childNodes: flattenedRows}]\n  };\n}\n"]},"metadata":{},"sourceType":"module"}