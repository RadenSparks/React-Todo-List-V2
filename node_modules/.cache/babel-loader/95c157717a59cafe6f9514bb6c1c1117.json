{"ast":null,"code":"import { isCtrlKeyPressed as $feb5ffebff200149$export$16792effe837dba3, isNonContiguousSelectionModifier as $feb5ffebff200149$export$d3e3bd3e26688c04 } from \"./utils.mjs\";\nimport { focusSafely as $581M0$focusSafely } from \"@react-aria/focus\";\nimport { useRouter as $581M0$useRouter, openLink as $581M0$openLink, mergeProps as $581M0$mergeProps } from \"@react-aria/utils\";\nimport { usePress as $581M0$usePress, useLongPress as $581M0$useLongPress } from \"@react-aria/interactions\";\nimport { useEffect as $581M0$useEffect, useRef as $581M0$useRef } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $880e95eb8b93ba9a$export$ecf600387e221c37(options) {\n  let {\n    selectionManager: manager,\n    key: key,\n    ref: ref,\n    shouldSelectOnPressUp: shouldSelectOnPressUp,\n    shouldUseVirtualFocus: shouldUseVirtualFocus,\n    focus: focus,\n    isDisabled: isDisabled,\n    onAction: onAction,\n    allowsDifferentPressOrigin: allowsDifferentPressOrigin,\n    linkBehavior = 'action'\n  } = options;\n  let router = (0, $581M0$useRouter)();\n  let onSelect = e => {\n    if (e.pointerType === 'keyboard' && (0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e)) manager.toggleSelection(key);else {\n      if (manager.selectionMode === 'none') return;\n      if (manager.isLink(key)) {\n        if (linkBehavior === 'selection') {\n          let itemProps = manager.getItemProps(key);\n          router.open(ref.current, e, itemProps.href, itemProps.routerOptions);\n          // Always set selected keys back to what they were so that select and combobox close.\n          manager.setSelectedKeys(manager.selectedKeys);\n          return;\n        } else if (linkBehavior === 'override' || linkBehavior === 'none') return;\n      }\n      if (manager.selectionMode === 'single') {\n        if (manager.isSelected(key) && !manager.disallowEmptySelection) manager.toggleSelection(key);else manager.replaceSelection(key);\n      } else if (e && e.shiftKey) manager.extendSelection(key);else if (manager.selectionBehavior === 'toggle' || e && ((0, $feb5ffebff200149$export$16792effe837dba3)(e) || e.pointerType === 'touch' || e.pointerType === 'virtual'))\n        // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n        manager.toggleSelection(key);else manager.replaceSelection(key);\n    }\n  };\n  // Focus the associated DOM node when this item becomes the focusedKey\n  (0, $581M0$useEffect)(() => {\n    let isFocused = key === manager.focusedKey;\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus) {\n      if (focus) focus();else if (document.activeElement !== ref.current) (0, $581M0$focusSafely)(ref.current);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [ref, key, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]);\n  isDisabled = isDisabled || manager.isDisabled(key);\n  // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused\n  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver\n  // on iOS 14 doesn't try to move real DOM focus to the item anyway.\n  let itemProps = {};\n  if (!shouldUseVirtualFocus && !isDisabled) itemProps = {\n    tabIndex: key === manager.focusedKey ? 0 : -1,\n    onFocus(e) {\n      if (e.target === ref.current) manager.setFocusedKey(key);\n    }\n  };else if (isDisabled) itemProps.onMouseDown = e => {\n    // Prevent focus going to the body when clicking on a disabled item.\n    e.preventDefault();\n  };\n  // With checkbox selection, onAction (i.e. navigation) becomes primary, and occurs on a single click of the row.\n  // Clicking the checkbox enters selection mode, after which clicking anywhere on any row toggles selection for that row.\n  // With highlight selection, onAction is secondary, and occurs on double click. Single click selects the row.\n  // With touch, onAction occurs on single tap, and long press enters selection mode.\n  let isLinkOverride = manager.isLink(key) && linkBehavior === 'override';\n  let hasLinkAction = manager.isLink(key) && linkBehavior !== 'selection' && linkBehavior !== 'none';\n  let allowsSelection = !isDisabled && manager.canSelectItem(key) && !isLinkOverride;\n  let allowsActions = (onAction || hasLinkAction) && !isDisabled;\n  let hasPrimaryAction = allowsActions && (manager.selectionBehavior === 'replace' ? !allowsSelection : !allowsSelection || manager.isEmpty);\n  let hasSecondaryAction = allowsActions && allowsSelection && manager.selectionBehavior === 'replace';\n  let hasAction = hasPrimaryAction || hasSecondaryAction;\n  let modality = (0, $581M0$useRef)(null);\n  let longPressEnabled = hasAction && allowsSelection;\n  let longPressEnabledOnPressStart = (0, $581M0$useRef)(false);\n  let hadPrimaryActionOnPressStart = (0, $581M0$useRef)(false);\n  let performAction = e => {\n    if (onAction) onAction();\n    if (hasLinkAction) {\n      let itemProps = manager.getItemProps(key);\n      router.open(ref.current, e, itemProps.href, itemProps.routerOptions);\n    }\n  };\n  // By default, selection occurs on pointer down. This can be strange if selecting an\n  // item causes the UI to disappear immediately (e.g. menus).\n  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.\n  // onPress requires a pointer down event on the same element as pointer up. For menus,\n  // we want to be able to have the pointer down on the trigger that opens the menu and\n  // the pointer up on the menu item rather than requiring a separate press.\n  // For keyboard events, selection still occurs on key down.\n  let itemPressProps = {};\n  if (shouldSelectOnPressUp) {\n    itemPressProps.onPressStart = e => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      if (e.pointerType === 'keyboard' && (!hasAction || $880e95eb8b93ba9a$var$isSelectionKey())) onSelect(e);\n    };\n    // If allowsDifferentPressOrigin, make selection happen on pressUp (e.g. open menu on press down, selection on menu item happens on press up.)\n    // Otherwise, have selection happen onPress (prevents listview row selection when clicking on interactable elements in the row)\n    if (!allowsDifferentPressOrigin) itemPressProps.onPress = e => {\n      if (hasPrimaryAction || hasSecondaryAction && e.pointerType !== 'mouse') {\n        if (e.pointerType === 'keyboard' && !$880e95eb8b93ba9a$var$isActionKey()) return;\n        performAction(e);\n      } else if (e.pointerType !== 'keyboard' && allowsSelection) onSelect(e);\n    };else {\n      itemPressProps.onPressUp = hasPrimaryAction ? null : e => {\n        if (e.pointerType !== 'keyboard' && allowsSelection) onSelect(e);\n      };\n      itemPressProps.onPress = hasPrimaryAction ? performAction : null;\n    }\n  } else {\n    itemPressProps.onPressStart = e => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      hadPrimaryActionOnPressStart.current = hasPrimaryAction;\n      // Select on mouse down unless there is a primary action which will occur on mouse up.\n      // For keyboard, select on key down. If there is an action, the Space key selects on key down,\n      // and the Enter key performs onAction on key up.\n      if (allowsSelection && (e.pointerType === 'mouse' && !hasPrimaryAction || e.pointerType === 'keyboard' && (!allowsActions || $880e95eb8b93ba9a$var$isSelectionKey()))) onSelect(e);\n    };\n    itemPressProps.onPress = e => {\n      // Selection occurs on touch up. Primary actions always occur on pointer up.\n      // Both primary and secondary actions occur on Enter key up. The only exception\n      // is secondary actions, which occur on double click with a mouse.\n      if (e.pointerType === 'touch' || e.pointerType === 'pen' || e.pointerType === 'virtual' || e.pointerType === 'keyboard' && hasAction && $880e95eb8b93ba9a$var$isActionKey() || e.pointerType === 'mouse' && hadPrimaryActionOnPressStart.current) {\n        if (hasAction) performAction(e);else if (allowsSelection) onSelect(e);\n      }\n    };\n  }\n  itemProps['data-key'] = key;\n  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;\n  let {\n    pressProps: pressProps,\n    isPressed: isPressed\n  } = (0, $581M0$usePress)(itemPressProps);\n  // Double clicking with a mouse with selectionBehavior = 'replace' performs an action.\n  let onDoubleClick = hasSecondaryAction ? e => {\n    if (modality.current === 'mouse') {\n      e.stopPropagation();\n      e.preventDefault();\n      performAction(e);\n    }\n  } : undefined;\n  // Long pressing an item with touch when selectionBehavior = 'replace' switches the selection behavior\n  // to 'toggle'. This changes the single tap behavior from performing an action (i.e. navigating) to\n  // selecting, and may toggle the appearance of a UI affordance like checkboxes on each item.\n  let {\n    longPressProps: longPressProps\n  } = (0, $581M0$useLongPress)({\n    isDisabled: !longPressEnabled,\n    onLongPress(e) {\n      if (e.pointerType === 'touch') {\n        onSelect(e);\n        manager.setSelectionBehavior('toggle');\n      }\n    }\n  });\n  // Prevent native drag and drop on long press if we also select on long press.\n  // Once the user is in selection mode, they can long press again to drag.\n  // Use a capturing listener to ensure this runs before useDrag, regardless of\n  // the order the props get merged.\n  let onDragStartCapture = e => {\n    if (modality.current === 'touch' && longPressEnabledOnPressStart.current) e.preventDefault();\n  };\n  // Prevent default on link clicks so that we control exactly\n  // when they open (to match selection behavior).\n  let onClick = manager.isLink(key) ? e => {\n    if (!(0, $581M0$openLink).isOpening) e.preventDefault();\n  } : undefined;\n  return {\n    itemProps: (0, $581M0$mergeProps)(itemProps, allowsSelection || hasPrimaryAction ? pressProps : {}, longPressEnabled ? longPressProps : {}, {\n      onDoubleClick: onDoubleClick,\n      onDragStartCapture: onDragStartCapture,\n      onClick: onClick\n    }),\n    isPressed: isPressed,\n    isSelected: manager.isSelected(key),\n    isFocused: manager.isFocused && manager.focusedKey === key,\n    isDisabled: isDisabled,\n    allowsSelection: allowsSelection,\n    hasAction: hasAction\n  };\n}\nfunction $880e95eb8b93ba9a$var$isActionKey() {\n  let event = window.event;\n  return (event === null || event === void 0 ? void 0 : event.key) === 'Enter';\n}\nfunction $880e95eb8b93ba9a$var$isSelectionKey() {\n  let event = window.event;\n  return (event === null || event === void 0 ? void 0 : event.key) === ' ' || (event === null || event === void 0 ? void 0 : event.code) === 'Space';\n}\nexport { $880e95eb8b93ba9a$export$ecf600387e221c37 as useSelectableItem };","map":{"version":3,"mappings":"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","names":["$880e95eb8b93ba9a$export$ecf600387e221c37","options","selectionManager","manager","key","ref","shouldSelectOnPressUp","shouldUseVirtualFocus","focus","isDisabled","onAction","allowsDifferentPressOrigin","linkBehavior","router","onSelect","e","pointerType","toggleSelection","selectionMode","isLink","itemProps","getItemProps","open","current","href","routerOptions","setSelectedKeys","selectedKeys","isSelected","disallowEmptySelection","replaceSelection","shiftKey","extendSelection","selectionBehavior","isFocused","focusedKey","document","activeElement","childFocusStrategy","tabIndex","onFocus","target","setFocusedKey","onMouseDown","preventDefault","isLinkOverride","hasLinkAction","allowsSelection","canSelectItem","allowsActions","hasPrimaryAction","isEmpty","hasSecondaryAction","hasAction","modality","longPressEnabled","longPressEnabledOnPressStart","hadPrimaryActionOnPressStart","performAction","itemPressProps","onPressStart","$880e95eb8b93ba9a$var$isSelectionKey","onPress","$880e95eb8b93ba9a$var$isActionKey","onPressUp","preventFocusOnPress","pressProps","isPressed","onDoubleClick","stopPropagation","undefined","longPressProps","onLongPress","setSelectionBehavior","onDragStartCapture","onClick","isOpening","event","window","code"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-aria\\grid\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\useSelectableItem.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, FocusableElement, Key, LongPressEvent, PressEvent, RefObject} from '@react-types/shared';\nimport {focusSafely} from '@react-aria/focus';\nimport {isCtrlKeyPressed, isNonContiguousSelectionModifier} from './utils';\nimport {mergeProps, openLink, useRouter} from '@react-aria/utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {PressProps, useLongPress, usePress} from '@react-aria/interactions';\nimport {useEffect, useRef} from 'react';\n\nexport interface SelectableItemOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A unique key for the item.\n   */\n  key: Key,\n  /**\n   * Ref to the item.\n   */\n  ref: RefObject<FocusableElement | null>,\n  /**\n   * By default, selection occurs on pointer down. This can be strange if selecting an\n   * item causes the UI to disappear immediately (e.g. menus).\n   */\n  shouldSelectOnPressUp?: boolean,\n  /**\n   * Whether selection requires the pointer/mouse down and up events to occur on the same target or triggers selection on\n   * the target of the pointer/mouse up event.\n   */\n  allowsDifferentPressOrigin?: boolean,\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * Function to focus the item.\n   */\n  focus?: () => void,\n  /**\n   * Whether the option should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /** Whether the item is disabled. */\n  isDisabled?: boolean,\n  /**\n   * Handler that is called when a user performs an action on the item. The exact user event depends on\n   * the collection's `selectionBehavior` prop and the interaction modality.\n   */\n  onAction?: () => void,\n  /**\n   * The behavior of links in the collection.\n   * - 'action': link behaves like onAction.\n   * - 'selection': link follows selection interactions (e.g. if URL drives selection).\n   * - 'override': links override all other interactions (link items are not selectable).\n   * - 'none': links are disabled for both selection and actions (e.g. handled elsewhere).\n   * @default 'action'\n   */\n  linkBehavior?: 'action' | 'selection' | 'override' | 'none'\n}\n\nexport interface SelectableItemStates {\n  /** Whether the item is currently in a pressed state. */\n  isPressed: boolean,\n  /** Whether the item is currently selected. */\n  isSelected: boolean,\n  /** Whether the item is currently focused. */\n  isFocused: boolean,\n  /**\n   * Whether the item is non-interactive, i.e. both selection and actions are disabled and the item may\n   * not be focused. Dependent on `disabledKeys` and `disabledBehavior`.\n   */\n  isDisabled: boolean,\n  /**\n   * Whether the item may be selected, dependent on `selectionMode`, `disabledKeys`, and `disabledBehavior`.\n   */\n  allowsSelection: boolean,\n  /**\n   * Whether the item has an action, dependent on `onAction`, `disabledKeys`,\n   * and `disabledBehavior`. It may also change depending on the current selection state\n   * of the list (e.g. when selection is primary). This can be used to enable or disable hover\n   * styles or other visual indications of interactivity.\n   */\n  hasAction: boolean\n}\n\nexport interface SelectableItemAria extends SelectableItemStates {\n  /**\n   * Props to be spread on the item root node.\n   */\n  itemProps: DOMAttributes\n}\n\n/**\n * Handles interactions with an item in a selectable collection.\n */\nexport function useSelectableItem(options: SelectableItemOptions): SelectableItemAria {\n  let {\n    selectionManager: manager,\n    key,\n    ref,\n    shouldSelectOnPressUp,\n    shouldUseVirtualFocus,\n    focus,\n    isDisabled,\n    onAction,\n    allowsDifferentPressOrigin,\n    linkBehavior = 'action'\n  } = options;\n  let router = useRouter();\n\n  let onSelect = (e: PressEvent | LongPressEvent | PointerEvent) => {\n    if (e.pointerType === 'keyboard' && isNonContiguousSelectionModifier(e)) {\n      manager.toggleSelection(key);\n    } else {\n      if (manager.selectionMode === 'none') {\n        return;\n      }\n\n      if (manager.isLink(key)) {\n        if (linkBehavior === 'selection') {\n          let itemProps = manager.getItemProps(key);\n          router.open(ref.current, e, itemProps.href, itemProps.routerOptions);\n          // Always set selected keys back to what they were so that select and combobox close.\n          manager.setSelectedKeys(manager.selectedKeys);\n          return;\n        } else if (linkBehavior === 'override' || linkBehavior === 'none') {\n          return;\n        }\n      }\n\n      if (manager.selectionMode === 'single') {\n        if (manager.isSelected(key) && !manager.disallowEmptySelection) {\n          manager.toggleSelection(key);\n        } else {\n          manager.replaceSelection(key);\n        }\n      } else if (e && e.shiftKey) {\n        manager.extendSelection(key);\n      } else if (manager.selectionBehavior === 'toggle' || (e && (isCtrlKeyPressed(e) || e.pointerType === 'touch' || e.pointerType === 'virtual'))) {\n        // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n        manager.toggleSelection(key);\n      } else {\n        manager.replaceSelection(key);\n      }\n    }\n  };\n\n  // Focus the associated DOM node when this item becomes the focusedKey\n  useEffect(() => {\n    let isFocused = key === manager.focusedKey;\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus) {\n      if (focus) {\n        focus();\n      } else if (document.activeElement !== ref.current) {\n        focusSafely(ref.current);\n      }\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [ref, key, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]);\n\n  isDisabled = isDisabled || manager.isDisabled(key);\n  // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused\n  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver\n  // on iOS 14 doesn't try to move real DOM focus to the item anyway.\n  let itemProps: SelectableItemAria['itemProps'] = {};\n  if (!shouldUseVirtualFocus && !isDisabled) {\n    itemProps = {\n      tabIndex: key === manager.focusedKey ? 0 : -1,\n      onFocus(e) {\n        if (e.target === ref.current) {\n          manager.setFocusedKey(key);\n        }\n      }\n    };\n  } else if (isDisabled) {\n    itemProps.onMouseDown = (e) => {\n      // Prevent focus going to the body when clicking on a disabled item.\n      e.preventDefault();\n    };\n  }\n\n  // With checkbox selection, onAction (i.e. navigation) becomes primary, and occurs on a single click of the row.\n  // Clicking the checkbox enters selection mode, after which clicking anywhere on any row toggles selection for that row.\n  // With highlight selection, onAction is secondary, and occurs on double click. Single click selects the row.\n  // With touch, onAction occurs on single tap, and long press enters selection mode.\n  let isLinkOverride = manager.isLink(key) && linkBehavior === 'override';\n  let hasLinkAction = manager.isLink(key) && linkBehavior !== 'selection' && linkBehavior !== 'none';\n  let allowsSelection = !isDisabled && manager.canSelectItem(key) && !isLinkOverride;\n  let allowsActions = (onAction || hasLinkAction) && !isDisabled;\n  let hasPrimaryAction = allowsActions && (\n    manager.selectionBehavior === 'replace'\n      ? !allowsSelection\n      : !allowsSelection || manager.isEmpty\n  );\n  let hasSecondaryAction = allowsActions && allowsSelection && manager.selectionBehavior === 'replace';\n  let hasAction = hasPrimaryAction || hasSecondaryAction;\n  let modality = useRef(null);\n\n  let longPressEnabled = hasAction && allowsSelection;\n  let longPressEnabledOnPressStart = useRef(false);\n  let hadPrimaryActionOnPressStart = useRef(false);\n\n  let performAction = (e) => {\n    if (onAction) {\n      onAction();\n    }\n\n    if (hasLinkAction) {\n      let itemProps = manager.getItemProps(key);\n      router.open(ref.current, e, itemProps.href, itemProps.routerOptions);\n    }\n  };\n\n  // By default, selection occurs on pointer down. This can be strange if selecting an\n  // item causes the UI to disappear immediately (e.g. menus).\n  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.\n  // onPress requires a pointer down event on the same element as pointer up. For menus,\n  // we want to be able to have the pointer down on the trigger that opens the menu and\n  // the pointer up on the menu item rather than requiring a separate press.\n  // For keyboard events, selection still occurs on key down.\n  let itemPressProps: PressProps = {};\n  if (shouldSelectOnPressUp) {\n    itemPressProps.onPressStart = (e) => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      if (e.pointerType === 'keyboard' && (!hasAction || isSelectionKey())) {\n        onSelect(e);\n      }\n    };\n\n    // If allowsDifferentPressOrigin, make selection happen on pressUp (e.g. open menu on press down, selection on menu item happens on press up.)\n    // Otherwise, have selection happen onPress (prevents listview row selection when clicking on interactable elements in the row)\n    if (!allowsDifferentPressOrigin) {\n      itemPressProps.onPress = (e) => {\n        if (hasPrimaryAction || (hasSecondaryAction && e.pointerType !== 'mouse')) {\n          if (e.pointerType === 'keyboard' && !isActionKey()) {\n            return;\n          }\n\n          performAction(e);\n        } else if (e.pointerType !== 'keyboard' && allowsSelection) {\n          onSelect(e);\n        }\n      };\n    } else {\n      itemPressProps.onPressUp = hasPrimaryAction ? null : (e) => {\n        if (e.pointerType !== 'keyboard' && allowsSelection) {\n          onSelect(e);\n        }\n      };\n\n      itemPressProps.onPress = hasPrimaryAction ? performAction : null;\n    }\n  } else {\n    itemPressProps.onPressStart = (e) => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      hadPrimaryActionOnPressStart.current = hasPrimaryAction;\n\n      // Select on mouse down unless there is a primary action which will occur on mouse up.\n      // For keyboard, select on key down. If there is an action, the Space key selects on key down,\n      // and the Enter key performs onAction on key up.\n      if (\n        allowsSelection && (\n          (e.pointerType === 'mouse' && !hasPrimaryAction) ||\n          (e.pointerType === 'keyboard' && (!allowsActions || isSelectionKey()))\n        )\n      ) {\n        onSelect(e);\n      }\n    };\n\n    itemPressProps.onPress = (e) => {\n      // Selection occurs on touch up. Primary actions always occur on pointer up.\n      // Both primary and secondary actions occur on Enter key up. The only exception\n      // is secondary actions, which occur on double click with a mouse.\n      if (\n        e.pointerType === 'touch' ||\n        e.pointerType === 'pen' ||\n        e.pointerType === 'virtual' ||\n        (e.pointerType === 'keyboard' && hasAction && isActionKey()) ||\n        (e.pointerType === 'mouse' && hadPrimaryActionOnPressStart.current)\n      ) {\n        if (hasAction) {\n          performAction(e);\n        } else if (allowsSelection) {\n          onSelect(e);\n        }\n      }\n    };\n  }\n\n  itemProps['data-key'] = key;\n  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;\n  let {pressProps, isPressed} = usePress(itemPressProps);\n\n  // Double clicking with a mouse with selectionBehavior = 'replace' performs an action.\n  let onDoubleClick = hasSecondaryAction ? (e) => {\n    if (modality.current === 'mouse') {\n      e.stopPropagation();\n      e.preventDefault();\n      performAction(e);\n    }\n  } : undefined;\n\n  // Long pressing an item with touch when selectionBehavior = 'replace' switches the selection behavior\n  // to 'toggle'. This changes the single tap behavior from performing an action (i.e. navigating) to\n  // selecting, and may toggle the appearance of a UI affordance like checkboxes on each item.\n  let {longPressProps} = useLongPress({\n    isDisabled: !longPressEnabled,\n    onLongPress(e) {\n      if (e.pointerType === 'touch') {\n        onSelect(e);\n        manager.setSelectionBehavior('toggle');\n      }\n    }\n  });\n\n  // Prevent native drag and drop on long press if we also select on long press.\n  // Once the user is in selection mode, they can long press again to drag.\n  // Use a capturing listener to ensure this runs before useDrag, regardless of\n  // the order the props get merged.\n  let onDragStartCapture = e => {\n    if (modality.current === 'touch' && longPressEnabledOnPressStart.current) {\n      e.preventDefault();\n    }\n  };\n\n  // Prevent default on link clicks so that we control exactly\n  // when they open (to match selection behavior).\n  let onClick = manager.isLink(key) ? e => {\n    if (!(openLink as any).isOpening) {\n      e.preventDefault();\n    }\n  } : undefined;\n\n  return {\n    itemProps: mergeProps(\n      itemProps,\n      allowsSelection || hasPrimaryAction ? pressProps : {},\n      longPressEnabled ? longPressProps : {},\n      {onDoubleClick, onDragStartCapture, onClick}\n    ),\n    isPressed,\n    isSelected: manager.isSelected(key),\n    isFocused: manager.isFocused && manager.focusedKey === key,\n    isDisabled,\n    allowsSelection,\n    hasAction\n  };\n}\n\nfunction isActionKey() {\n  let event = window.event as KeyboardEvent;\n  return event?.key === 'Enter';\n}\n\nfunction isSelectionKey() {\n  let event = window.event as KeyboardEvent;\n  return event?.key === ' ' || event?.code === 'Space';\n}\n"]},"metadata":{},"sourceType":"module"}