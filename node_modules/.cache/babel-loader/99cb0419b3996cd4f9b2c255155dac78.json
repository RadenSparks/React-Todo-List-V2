{"ast":null,"code":"import { isCtrlKeyPressed as $feb5ffebff200149$export$16792effe837dba3, isNonContiguousSelectionModifier as $feb5ffebff200149$export$d3e3bd3e26688c04 } from \"./utils.mjs\";\nimport { useTypeSelect as $fb3050f43d946246$export$e32c88dfddc6e1d8 } from \"./useTypeSelect.mjs\";\nimport { flushSync as $3H3GQ$flushSync } from \"react-dom\";\nimport { useRef as $3H3GQ$useRef, useEffect as $3H3GQ$useEffect } from \"react\";\nimport { getFocusableTreeWalker as $3H3GQ$getFocusableTreeWalker, focusSafely as $3H3GQ$focusSafely } from \"@react-aria/focus\";\nimport { useRouter as $3H3GQ$useRouter, focusWithoutScrolling as $3H3GQ$focusWithoutScrolling, useEvent as $3H3GQ$useEvent, scrollIntoViewport as $3H3GQ$scrollIntoViewport, scrollIntoView as $3H3GQ$scrollIntoView, mergeProps as $3H3GQ$mergeProps } from \"@react-aria/utils\";\nimport { getInteractionModality as $3H3GQ$getInteractionModality } from \"@react-aria/interactions\";\nimport { useLocale as $3H3GQ$useLocale } from \"@react-aria/i18n\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $ae20dd8cbca75726$export$d6daf82dcd84e87c(options) {\n  let {\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    ref: ref,\n    autoFocus = false,\n    shouldFocusWrap = false,\n    disallowEmptySelection = false,\n    disallowSelectAll = false,\n    selectOnFocus = manager.selectionBehavior === 'replace',\n    disallowTypeAhead = false,\n    shouldUseVirtualFocus: shouldUseVirtualFocus,\n    allowsTabNavigation = false,\n    isVirtualized: isVirtualized,\n    // If no scrollRef is provided, assume the collection ref is the scrollable region\n    scrollRef = ref,\n    linkBehavior = 'action'\n  } = options;\n  let {\n    direction: direction\n  } = (0, $3H3GQ$useLocale)();\n  let router = (0, $3H3GQ$useRouter)();\n  let onKeyDown = e => {\n    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes\n    if (e.altKey && e.key === 'Tab') e.preventDefault();\n    // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n    if (!ref.current.contains(e.target)) return;\n    const navigateToKey = (key, childFocus) => {\n      if (key != null) {\n        if (manager.isLink(key) && linkBehavior === 'selection' && selectOnFocus && !(0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e)) {\n          // Set focused key and re-render synchronously to bring item into view if needed.\n          (0, $3H3GQ$flushSync)(() => {\n            manager.setFocusedKey(key, childFocus);\n          });\n          let item = scrollRef.current.querySelector(`[data-key=\"${CSS.escape(key.toString())}\"]`);\n          let itemProps = manager.getItemProps(key);\n          router.open(item, e, itemProps.href, itemProps.routerOptions);\n          return;\n        }\n        manager.setFocusedKey(key, childFocus);\n        if (manager.isLink(key) && linkBehavior === 'override') return;\n        if (e.shiftKey && manager.selectionMode === 'multiple') manager.extendSelection(key);else if (selectOnFocus && !(0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e)) manager.replaceSelection(key);\n      }\n    };\n    switch (e.key) {\n      case 'ArrowDown':\n        if (delegate.getKeyBelow) {\n          var _delegate_getFirstKey, _delegate_getFirstKey1;\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : (_delegate_getFirstKey = delegate.getFirstKey) === null || _delegate_getFirstKey === void 0 ? void 0 : _delegate_getFirstKey.call(delegate);\n          if (nextKey == null && shouldFocusWrap) nextKey = (_delegate_getFirstKey1 = delegate.getFirstKey) === null || _delegate_getFirstKey1 === void 0 ? void 0 : _delegate_getFirstKey1.call(delegate, manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'ArrowUp':\n        if (delegate.getKeyAbove) {\n          var _delegate_getLastKey, _delegate_getLastKey1;\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : (_delegate_getLastKey = delegate.getLastKey) === null || _delegate_getLastKey === void 0 ? void 0 : _delegate_getLastKey.call(delegate);\n          if (nextKey == null && shouldFocusWrap) nextKey = (_delegate_getLastKey1 = delegate.getLastKey) === null || _delegate_getLastKey1 === void 0 ? void 0 : _delegate_getLastKey1.call(delegate, manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'ArrowLeft':\n        if (delegate.getKeyLeftOf) {\n          var _delegate_getFirstKey2, _delegate_getLastKey2;\n          e.preventDefault();\n          let nextKey = delegate.getKeyLeftOf(manager.focusedKey);\n          if (nextKey == null && shouldFocusWrap) nextKey = direction === 'rtl' ? (_delegate_getFirstKey2 = delegate.getFirstKey) === null || _delegate_getFirstKey2 === void 0 ? void 0 : _delegate_getFirstKey2.call(delegate, manager.focusedKey) : (_delegate_getLastKey2 = delegate.getLastKey) === null || _delegate_getLastKey2 === void 0 ? void 0 : _delegate_getLastKey2.call(delegate, manager.focusedKey);\n          navigateToKey(nextKey, direction === 'rtl' ? 'first' : 'last');\n        }\n        break;\n      case 'ArrowRight':\n        if (delegate.getKeyRightOf) {\n          var _delegate_getLastKey3, _delegate_getFirstKey3;\n          e.preventDefault();\n          let nextKey = delegate.getKeyRightOf(manager.focusedKey);\n          if (nextKey == null && shouldFocusWrap) nextKey = direction === 'rtl' ? (_delegate_getLastKey3 = delegate.getLastKey) === null || _delegate_getLastKey3 === void 0 ? void 0 : _delegate_getLastKey3.call(delegate, manager.focusedKey) : (_delegate_getFirstKey3 = delegate.getFirstKey) === null || _delegate_getFirstKey3 === void 0 ? void 0 : _delegate_getFirstKey3.call(delegate, manager.focusedKey);\n          navigateToKey(nextKey, direction === 'rtl' ? 'last' : 'first');\n        }\n        break;\n      case 'Home':\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          let firstKey = delegate.getFirstKey(manager.focusedKey, (0, $feb5ffebff200149$export$16792effe837dba3)(e));\n          manager.setFocusedKey(firstKey);\n          if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && e.shiftKey && manager.selectionMode === 'multiple') manager.extendSelection(firstKey);else if (selectOnFocus) manager.replaceSelection(firstKey);\n        }\n        break;\n      case 'End':\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          let lastKey = delegate.getLastKey(manager.focusedKey, (0, $feb5ffebff200149$export$16792effe837dba3)(e));\n          manager.setFocusedKey(lastKey);\n          if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && e.shiftKey && manager.selectionMode === 'multiple') manager.extendSelection(lastKey);else if (selectOnFocus) manager.replaceSelection(lastKey);\n        }\n        break;\n      case 'PageDown':\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'PageUp':\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'a':\n        if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case 'Escape':\n        if (!disallowEmptySelection && manager.selectedKeys.size !== 0) {\n          e.stopPropagation();\n          e.preventDefault();\n          manager.clearSelection();\n        }\n        break;\n      case 'Tab':\n        if (!allowsTabNavigation) {\n          // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n          // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n          // in the collection, so that the browser default behavior will apply starting from that element\n          // rather than the currently focused one.\n          if (e.shiftKey) ref.current.focus();else {\n            let walker = (0, $3H3GQ$getFocusableTreeWalker)(ref.current, {\n              tabbable: true\n            });\n            let next;\n            let last;\n            do {\n              last = walker.lastChild();\n              if (last) next = last;\n            } while (last);\n            if (next && !next.contains(document.activeElement)) (0, $3H3GQ$focusWithoutScrolling)(next);\n          }\n          break;\n        }\n    }\n  };\n  // Store the scroll position so we can restore it later.\n  let scrollPos = (0, $3H3GQ$useRef)({\n    top: 0,\n    left: 0\n  });\n  (0, $3H3GQ$useEvent)(scrollRef, 'scroll', isVirtualized ? null : () => {\n    scrollPos.current = {\n      top: scrollRef.current.scrollTop,\n      left: scrollRef.current.scrollLeft\n    };\n  });\n  let onFocus = e => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) manager.setFocused(false);\n      return;\n    }\n    // Focus events can bubble through portals. Ignore these events.\n    if (!e.currentTarget.contains(e.target)) return;\n    manager.setFocused(true);\n    if (manager.focusedKey == null) {\n      let navigateToFirstKey = key => {\n        if (key != null) {\n          manager.setFocusedKey(key);\n          if (selectOnFocus) manager.replaceSelection(key);\n        }\n      };\n      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n      let relatedTarget = e.relatedTarget;\n      var _manager_lastSelectedKey, _manager_firstSelectedKey;\n      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) navigateToFirstKey((_manager_lastSelectedKey = manager.lastSelectedKey) !== null && _manager_lastSelectedKey !== void 0 ? _manager_lastSelectedKey : delegate.getLastKey());else navigateToFirstKey((_manager_firstSelectedKey = manager.firstSelectedKey) !== null && _manager_firstSelectedKey !== void 0 ? _manager_firstSelectedKey : delegate.getFirstKey());\n    } else if (!isVirtualized) {\n      // Restore the scroll position to what it was before.\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left;\n    }\n    if (!isVirtualized && manager.focusedKey != null) {\n      // Refocus and scroll the focused item into view if it exists within the scrollable region.\n      let element = scrollRef.current.querySelector(`[data-key=\"${CSS.escape(manager.focusedKey.toString())}\"]`);\n      if (element) {\n        // This prevents a flash of focus on the first/last element in the collection, or the collection itself.\n        if (!element.contains(document.activeElement)) (0, $3H3GQ$focusWithoutScrolling)(element);\n        let modality = (0, $3H3GQ$getInteractionModality)();\n        if (modality === 'keyboard') (0, $3H3GQ$scrollIntoViewport)(element, {\n          containingElement: ref.current\n        });\n      }\n    }\n  };\n  let onBlur = e => {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget)) manager.setFocused(false);\n  };\n  const autoFocusRef = (0, $3H3GQ$useRef)(autoFocus);\n  (0, $3H3GQ$useEffect)(() => {\n    if (autoFocusRef.current) {\n      let focusedKey = null;\n      // Check focus strategy to determine which item to focus\n      if (autoFocus === 'first') focusedKey = delegate.getFirstKey();\n      if (autoFocus === 'last') focusedKey = delegate.getLastKey();\n      // If there are any selected keys, make the first one the new focus target\n      let selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) {\n        for (let key of selectedKeys) if (manager.canSelectItem(key)) {\n          focusedKey = key;\n          break;\n        }\n      }\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n      // If no default focus key is selected, focus the collection itself.\n      if (focusedKey == null && !shouldUseVirtualFocus) (0, $3H3GQ$focusSafely)(ref.current);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  // If not virtualized, scroll the focused element into view when the focusedKey changes.\n  // When virtualized, Virtualizer handles this internally.\n  let lastFocusedKey = (0, $3H3GQ$useRef)(manager.focusedKey);\n  (0, $3H3GQ$useEffect)(() => {\n    let modality = (0, $3H3GQ$getInteractionModality)();\n    if (manager.isFocused && manager.focusedKey != null && (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current)) {\n      let element = scrollRef.current.querySelector(`[data-key=\"${CSS.escape(manager.focusedKey.toString())}\"]`);\n      if (element && (modality === 'keyboard' || autoFocusRef.current)) {\n        if (!isVirtualized) (0, $3H3GQ$scrollIntoView)(scrollRef.current, element);\n        // Avoid scroll in iOS VO, since it may cause overlay to close (i.e. RAC submenu)\n        if (modality !== 'virtual') (0, $3H3GQ$scrollIntoViewport)(element, {\n          containingElement: ref.current\n        });\n      }\n    }\n    // If the focused key becomes null (e.g. the last item is deleted), focus the whole collection.\n    if (manager.isFocused && manager.focusedKey == null && lastFocusedKey.current != null) (0, $3H3GQ$focusSafely)(ref.current);\n    lastFocusedKey.current = manager.focusedKey;\n    autoFocusRef.current = false;\n  }, [isVirtualized, scrollRef, manager.focusedKey, manager.isFocused, ref]);\n  let handlers = {\n    onKeyDown: onKeyDown,\n    onFocus: onFocus,\n    onBlur: onBlur,\n    onMouseDown(e) {\n      // Ignore events that bubbled through portals.\n      if (scrollRef.current === e.target)\n        // Prevent focus going to the collection when clicking on the scrollbar.\n        e.preventDefault();\n    }\n  };\n  let {\n    typeSelectProps: typeSelectProps\n  } = (0, $fb3050f43d946246$export$e32c88dfddc6e1d8)({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  });\n  if (!disallowTypeAhead) handlers = (0, $3H3GQ$mergeProps)(typeSelectProps, handlers);\n  // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n  // to move real DOM focus to the element anyway.\n  let tabIndex;\n  if (!shouldUseVirtualFocus) tabIndex = manager.focusedKey == null ? 0 : -1;\n  return {\n    collectionProps: {\n      ...handlers,\n      tabIndex: tabIndex\n    }\n  };\n}\nexport { $ae20dd8cbca75726$export$d6daf82dcd84e87c as useSelectableCollection };","map":{"version":3,"mappings":"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","names":["$ae20dd8cbca75726$export$d6daf82dcd84e87c","options","selectionManager","manager","keyboardDelegate","delegate","ref","autoFocus","shouldFocusWrap","disallowEmptySelection","disallowSelectAll","selectOnFocus","selectionBehavior","disallowTypeAhead","shouldUseVirtualFocus","allowsTabNavigation","isVirtualized","scrollRef","linkBehavior","direction","router","onKeyDown","e","altKey","key","preventDefault","current","contains","target","navigateToKey","childFocus","isLink","setFocusedKey","item","querySelector","CSS","escape","toString","itemProps","getItemProps","open","href","routerOptions","shiftKey","selectionMode","extendSelection","replaceSelection","getKeyBelow","_delegate_getFirstKey","_delegate_getFirstKey1","nextKey","focusedKey","getFirstKey","getKeyAbove","_delegate_getLastKey","_delegate_getLastKey1","getLastKey","getKeyLeftOf","_delegate_getFirstKey2","_delegate_getLastKey2","getKeyRightOf","_delegate_getLastKey3","_delegate_getFirstKey3","firstKey","lastKey","getKeyPageBelow","getKeyPageAbove","selectAll","selectedKeys","size","stopPropagation","clearSelection","focus","walker","tabbable","next","last","lastChild","document","activeElement","scrollPos","top","left","scrollTop","scrollLeft","onFocus","isFocused","currentTarget","setFocused","navigateToFirstKey","relatedTarget","_manager_lastSelectedKey","_manager_firstSelectedKey","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","lastSelectedKey","firstSelectedKey","element","modality","containingElement","onBlur","autoFocusRef","canSelectItem","lastFocusedKey","handlers","onMouseDown","typeSelectProps","tabIndex","collectionProps"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\useSelectableCollection.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, FocusableElement, FocusStrategy, Key, KeyboardDelegate} from '@react-types/shared';\nimport {flushSync} from 'react-dom';\nimport {FocusEvent, KeyboardEvent, RefObject, useEffect, useRef} from 'react';\nimport {focusSafely, getFocusableTreeWalker} from '@react-aria/focus';\nimport {focusWithoutScrolling, mergeProps, scrollIntoView, scrollIntoViewport, useEvent, useRouter} from '@react-aria/utils';\nimport {getInteractionModality} from '@react-aria/interactions';\nimport {isCtrlKeyPressed, isNonContiguousSelectionModifier} from './utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useLocale} from '@react-aria/i18n';\nimport {useTypeSelect} from './useTypeSelect';\n\nexport interface AriaSelectableCollectionOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A delegate object that implements behavior for keyboard focus movement.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * The ref attached to the element representing the collection.\n   */\n  ref: RefObject<HTMLElement>,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether the collection allows the user to select all items via keyboard shortcut.\n   * @default false\n   */\n  disallowSelectAll?: boolean,\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean,\n  /**\n   * Whether the collection items are contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * The ref attached to the scrollable body. Used to provide automatic scrolling on item focus for non-virtualized collections.\n   * If not provided, defaults to the collection ref.\n   */\n  scrollRef?: RefObject<HTMLElement>,\n  /**\n   * The behavior of links in the collection.\n   * - 'action': link behaves like onAction.\n   * - 'selection': link follows selection interactions (e.g. if URL drives selection).\n   * - 'override': links override all other interactions (link items are not selectable).\n   * @default 'action'\n   */\n  linkBehavior?: 'action' | 'selection' | 'override'\n}\n\nexport interface SelectableCollectionAria {\n  /** Props for the collection element. */\n  collectionProps: DOMAttributes\n}\n\n/**\n * Handles interactions with selectable collections.\n */\nexport function useSelectableCollection(options: AriaSelectableCollectionOptions): SelectableCollectionAria {\n  let {\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    ref,\n    autoFocus = false,\n    shouldFocusWrap = false,\n    disallowEmptySelection = false,\n    disallowSelectAll = false,\n    selectOnFocus = manager.selectionBehavior === 'replace',\n    disallowTypeAhead = false,\n    shouldUseVirtualFocus,\n    allowsTabNavigation = false,\n    isVirtualized,\n    // If no scrollRef is provided, assume the collection ref is the scrollable region\n    scrollRef = ref,\n    linkBehavior = 'action'\n  } = options;\n  let {direction} = useLocale();\n  let router = useRouter();\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes\n    if (e.altKey && e.key === 'Tab') {\n      e.preventDefault();\n    }\n\n    // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n    if (!ref.current.contains(e.target as Element)) {\n      return;\n    }\n\n    const navigateToKey = (key: Key | undefined, childFocus?: FocusStrategy) => {\n      if (key != null) {\n        if (manager.isLink(key) && linkBehavior === 'selection' && selectOnFocus && !isNonContiguousSelectionModifier(e)) {\n          // Set focused key and re-render synchronously to bring item into view if needed.\n          flushSync(() => {\n            manager.setFocusedKey(key, childFocus);\n          });\n\n          let item = scrollRef.current.querySelector(`[data-key=\"${CSS.escape(key.toString())}\"]`);\n          let itemProps = manager.getItemProps(key);\n          router.open(item, e, itemProps.href, itemProps.routerOptions);\n\n          return;\n        }\n\n        manager.setFocusedKey(key, childFocus);\n\n        if (manager.isLink(key) && linkBehavior === 'override') {\n          return;\n        }\n\n        if (e.shiftKey && manager.selectionMode === 'multiple') {\n          manager.extendSelection(key);\n        } else if (selectOnFocus && !isNonContiguousSelectionModifier(e)) {\n          manager.replaceSelection(key);\n        }\n      }\n    };\n\n    switch (e.key) {\n      case 'ArrowDown': {\n        if (delegate.getKeyBelow) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyBelow(manager.focusedKey)\n              : delegate.getFirstKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getFirstKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case 'ArrowUp': {\n        if (delegate.getKeyAbove) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyAbove(manager.focusedKey)\n              : delegate.getLastKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getLastKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case 'ArrowLeft': {\n        if (delegate.getKeyLeftOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyLeftOf(manager.focusedKey);\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = direction === 'rtl' ? delegate.getFirstKey?.(manager.focusedKey) : delegate.getLastKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey, direction === 'rtl' ? 'first' : 'last');\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        if (delegate.getKeyRightOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyRightOf(manager.focusedKey);\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = direction === 'rtl' ? delegate.getLastKey?.(manager.focusedKey) : delegate.getFirstKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey, direction === 'rtl' ? 'last' : 'first');\n        }\n        break;\n      }\n      case 'Home':\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          let firstKey = delegate.getFirstKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(firstKey);\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(firstKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(firstKey);\n          }\n        }\n        break;\n      case 'End':\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          let lastKey = delegate.getLastKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(lastKey);\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(lastKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(lastKey);\n          }\n        }\n        break;\n      case 'PageDown':\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'PageUp':\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'a':\n        if (isCtrlKeyPressed(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case 'Escape':\n        if (!disallowEmptySelection && manager.selectedKeys.size !== 0) {\n          e.stopPropagation();\n          e.preventDefault();\n          manager.clearSelection();\n        }\n        break;\n      case 'Tab': {\n        if (!allowsTabNavigation) {\n          // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n          // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n          // in the collection, so that the browser default behavior will apply starting from that element\n          // rather than the currently focused one.\n          if (e.shiftKey) {\n            ref.current.focus();\n          } else {\n            let walker = getFocusableTreeWalker(ref.current, {tabbable: true});\n            let next: FocusableElement;\n            let last: FocusableElement;\n            do {\n              last = walker.lastChild() as FocusableElement;\n              if (last) {\n                next = last;\n              }\n            } while (last);\n\n            if (next && !next.contains(document.activeElement)) {\n              focusWithoutScrolling(next);\n            }\n          }\n          break;\n        }\n      }\n    }\n  };\n\n  // Store the scroll position so we can restore it later.\n  let scrollPos = useRef({top: 0, left: 0});\n  useEvent(scrollRef, 'scroll', isVirtualized ? null : () => {\n    scrollPos.current = {\n      top: scrollRef.current.scrollTop,\n      left: scrollRef.current.scrollLeft\n    };\n  });\n\n  let onFocus = (e: FocusEvent) => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) {\n        manager.setFocused(false);\n      }\n\n      return;\n    }\n\n    // Focus events can bubble through portals. Ignore these events.\n    if (!e.currentTarget.contains(e.target)) {\n      return;\n    }\n\n    manager.setFocused(true);\n\n    if (manager.focusedKey == null) {\n      let navigateToFirstKey = (key: Key | undefined) => {\n        if (key != null) {\n          manager.setFocusedKey(key);\n          if (selectOnFocus) {\n            manager.replaceSelection(key);\n          }\n        }\n      };\n      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n      let relatedTarget = e.relatedTarget as Element;\n      if (relatedTarget && (e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING)) {\n        navigateToFirstKey(manager.lastSelectedKey ?? delegate.getLastKey());\n      } else {\n        navigateToFirstKey(manager.firstSelectedKey ?? delegate.getFirstKey());\n      }\n    } else if (!isVirtualized) {\n      // Restore the scroll position to what it was before.\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left;\n    }\n\n    if (!isVirtualized && manager.focusedKey != null) {\n      // Refocus and scroll the focused item into view if it exists within the scrollable region.\n      let element = scrollRef.current.querySelector(`[data-key=\"${CSS.escape(manager.focusedKey.toString())}\"]`) as HTMLElement;\n      if (element) {\n        // This prevents a flash of focus on the first/last element in the collection, or the collection itself.\n        if (!element.contains(document.activeElement)) {\n          focusWithoutScrolling(element);\n        }\n\n        let modality = getInteractionModality();\n        if (modality === 'keyboard') {\n          scrollIntoViewport(element, {containingElement: ref.current});\n        }\n      }\n    }\n  };\n\n  let onBlur = (e) => {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget as HTMLElement)) {\n      manager.setFocused(false);\n    }\n  };\n\n  const autoFocusRef = useRef(autoFocus);\n  useEffect(() => {\n    if (autoFocusRef.current) {\n      let focusedKey = null;\n\n      // Check focus strategy to determine which item to focus\n      if (autoFocus === 'first') {\n        focusedKey = delegate.getFirstKey();\n      } if (autoFocus === 'last') {\n        focusedKey = delegate.getLastKey();\n      }\n\n      // If there are any selected keys, make the first one the new focus target\n      let selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) {\n        for (let key of selectedKeys) {\n          if (manager.canSelectItem(key)) {\n            focusedKey = key;\n            break;\n          }\n        }\n      }\n\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n\n      // If no default focus key is selected, focus the collection itself.\n      if (focusedKey == null && !shouldUseVirtualFocus) {\n        focusSafely(ref.current);\n      }\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // If not virtualized, scroll the focused element into view when the focusedKey changes.\n  // When virtualized, Virtualizer handles this internally.\n  let lastFocusedKey = useRef(manager.focusedKey);\n  useEffect(() => {\n    let modality = getInteractionModality();\n    if (manager.isFocused && manager.focusedKey != null && scrollRef?.current) {\n      let element = scrollRef.current.querySelector(`[data-key=\"${CSS.escape(manager.focusedKey.toString())}\"]`) as HTMLElement;\n      if (element && (modality === 'keyboard' || autoFocusRef.current)) {\n        if (!isVirtualized) {\n          scrollIntoView(scrollRef.current, element);\n        }\n        // Avoid scroll in iOS VO, since it may cause overlay to close (i.e. RAC submenu)\n        if (modality !== 'virtual') {\n          scrollIntoViewport(element, {containingElement: ref.current});\n        }\n      }\n    }\n\n    // If the focused key becomes null (e.g. the last item is deleted), focus the whole collection.\n    if (manager.isFocused && manager.focusedKey == null && lastFocusedKey.current != null) {\n      focusSafely(ref.current);\n    }\n\n    lastFocusedKey.current = manager.focusedKey;\n    autoFocusRef.current = false;\n  }, [isVirtualized, scrollRef, manager.focusedKey, manager.isFocused, ref]);\n\n  let handlers = {\n    onKeyDown,\n    onFocus,\n    onBlur,\n    onMouseDown(e) {\n      // Ignore events that bubbled through portals.\n      if (scrollRef.current === e.target) {\n        // Prevent focus going to the collection when clicking on the scrollbar.\n        e.preventDefault();\n      }\n    }\n  };\n\n  let {typeSelectProps} = useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  });\n\n  if (!disallowTypeAhead) {\n    handlers = mergeProps(typeSelectProps, handlers);\n  }\n\n  // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n  // to move real DOM focus to the element anyway.\n  let tabIndex: number;\n  if (!shouldUseVirtualFocus) {\n    tabIndex = manager.focusedKey == null ? 0 : -1;\n  }\n\n  return {\n    collectionProps: {\n      ...handlers,\n      tabIndex\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}