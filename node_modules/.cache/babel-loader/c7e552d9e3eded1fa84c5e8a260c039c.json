{"ast":null,"code":"import { disableTextSelection as $14c0b72509d70225$export$16a4697467175487, restoreTextSelection as $14c0b72509d70225$export$b0d6fa1ab32e3295 } from \"./textSelection.mjs\";\nimport { PressResponderContext as $ae1eeba8b9eafd08$export$5165eccb35aaadb5 } from \"./context.mjs\";\nimport { _ as $7mdmh$_ } from \"@swc/helpers/_/_class_private_field_get\";\nimport { _ as $7mdmh$_1 } from \"@swc/helpers/_/_class_private_field_init\";\nimport { _ as $7mdmh$_2 } from \"@swc/helpers/_/_class_private_field_set\";\nimport { mergeProps as $7mdmh$mergeProps, useSyncRef as $7mdmh$useSyncRef, useGlobalListeners as $7mdmh$useGlobalListeners, useEffectEvent as $7mdmh$useEffectEvent, getOwnerDocument as $7mdmh$getOwnerDocument, chain as $7mdmh$chain, isMac as $7mdmh$isMac, openLink as $7mdmh$openLink, isVirtualClick as $7mdmh$isVirtualClick, focusWithoutScrolling as $7mdmh$focusWithoutScrolling, isVirtualPointerEvent as $7mdmh$isVirtualPointerEvent, getOwnerWindow as $7mdmh$getOwnerWindow } from \"@react-aria/utils\";\nimport { useContext as $7mdmh$useContext, useState as $7mdmh$useState, useRef as $7mdmh$useRef, useMemo as $7mdmh$useMemo, useEffect as $7mdmh$useEffect } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nfunction $f6c31cce2adf654f$var$usePressResponderContext(props) {\n  // Consume context from <PressResponder> and merge with props.\n  let context = (0, $7mdmh$useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));\n  if (context) {\n    let {\n      register: register,\n      ...contextProps\n    } = context;\n    props = (0, $7mdmh$mergeProps)(contextProps, props);\n    register();\n  }\n  (0, $7mdmh$useSyncRef)(context, props.ref);\n  return props;\n}\nvar $f6c31cce2adf654f$var$_shouldStopPropagation = /*#__PURE__*/new WeakMap();\nclass $f6c31cce2adf654f$var$PressEvent {\n  continuePropagation() {\n    (0, $7mdmh$_2)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, false);\n  }\n  get shouldStopPropagation() {\n    return (0, $7mdmh$_)(this, $f6c31cce2adf654f$var$_shouldStopPropagation);\n  }\n  constructor(type, pointerType, originalEvent) {\n    (0, $7mdmh$_1)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, {\n      writable: true,\n      value: void 0\n    });\n    (0, $7mdmh$_2)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, true);\n    this.type = type;\n    this.pointerType = pointerType;\n    this.target = originalEvent.currentTarget;\n    this.shiftKey = originalEvent.shiftKey;\n    this.metaKey = originalEvent.metaKey;\n    this.ctrlKey = originalEvent.ctrlKey;\n    this.altKey = originalEvent.altKey;\n  }\n}\nconst $f6c31cce2adf654f$var$LINK_CLICKED = Symbol('linkClicked');\nfunction $f6c31cce2adf654f$export$45712eceda6fad21(props) {\n  let {\n    onPress: onPress,\n    onPressChange: onPressChange,\n    onPressStart: onPressStart,\n    onPressEnd: onPressEnd,\n    onPressUp: onPressUp,\n    isDisabled: isDisabled,\n    isPressed: isPressedProp,\n    preventFocusOnPress: preventFocusOnPress,\n    shouldCancelOnPointerExit: shouldCancelOnPointerExit,\n    allowTextSelectionOnPress: allowTextSelectionOnPress,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ref: _,\n    ...domProps\n  } = $f6c31cce2adf654f$var$usePressResponderContext(props);\n  let [isPressed, setPressed] = (0, $7mdmh$useState)(false);\n  let ref = (0, $7mdmh$useRef)({\n    isPressed: false,\n    ignoreEmulatedMouseEvents: false,\n    ignoreClickAfterPress: false,\n    didFirePressStart: false,\n    isTriggeringEvent: false,\n    activePointerId: null,\n    target: null,\n    isOverTarget: false,\n    pointerType: null\n  });\n  let {\n    addGlobalListener: addGlobalListener,\n    removeAllGlobalListeners: removeAllGlobalListeners\n  } = (0, $7mdmh$useGlobalListeners)();\n  let triggerPressStart = (0, $7mdmh$useEffectEvent)((originalEvent, pointerType) => {\n    let state = ref.current;\n    if (isDisabled || state.didFirePressStart) return false;\n    let shouldStopPropagation = true;\n    state.isTriggeringEvent = true;\n    if (onPressStart) {\n      let event = new $f6c31cce2adf654f$var$PressEvent('pressstart', pointerType, originalEvent);\n      onPressStart(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n    if (onPressChange) onPressChange(true);\n    state.isTriggeringEvent = false;\n    state.didFirePressStart = true;\n    setPressed(true);\n    return shouldStopPropagation;\n  });\n  let triggerPressEnd = (0, $7mdmh$useEffectEvent)(function (originalEvent, pointerType) {\n    let wasPressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let state = ref.current;\n    if (!state.didFirePressStart) return false;\n    state.ignoreClickAfterPress = true;\n    state.didFirePressStart = false;\n    state.isTriggeringEvent = true;\n    let shouldStopPropagation = true;\n    if (onPressEnd) {\n      let event = new $f6c31cce2adf654f$var$PressEvent('pressend', pointerType, originalEvent);\n      onPressEnd(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n    if (onPressChange) onPressChange(false);\n    setPressed(false);\n    if (onPress && wasPressed && !isDisabled) {\n      let event = new $f6c31cce2adf654f$var$PressEvent('press', pointerType, originalEvent);\n      onPress(event);\n      shouldStopPropagation && (shouldStopPropagation = event.shouldStopPropagation);\n    }\n    state.isTriggeringEvent = false;\n    return shouldStopPropagation;\n  });\n  let triggerPressUp = (0, $7mdmh$useEffectEvent)((originalEvent, pointerType) => {\n    let state = ref.current;\n    if (isDisabled) return false;\n    if (onPressUp) {\n      state.isTriggeringEvent = true;\n      let event = new $f6c31cce2adf654f$var$PressEvent('pressup', pointerType, originalEvent);\n      onPressUp(event);\n      state.isTriggeringEvent = false;\n      return event.shouldStopPropagation;\n    }\n    return true;\n  });\n  let cancel = (0, $7mdmh$useEffectEvent)(e => {\n    let state = ref.current;\n    if (state.isPressed && state.target) {\n      if (state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n      state.isPressed = false;\n      state.isOverTarget = false;\n      state.activePointerId = null;\n      state.pointerType = null;\n      removeAllGlobalListeners();\n      if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);\n    }\n  });\n  let cancelOnPointerExit = (0, $7mdmh$useEffectEvent)(e => {\n    if (shouldCancelOnPointerExit) cancel(e);\n  });\n  let pressProps = (0, $7mdmh$useMemo)(() => {\n    let state = ref.current;\n    let pressProps = {\n      onKeyDown(e) {\n        if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {\n          var _state_metaKeyEvents;\n          if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();\n          // If the event is repeating, it may have started on a different element\n          // after which focus moved to the current element. Ignore these events and\n          // only handle the first key down event.\n          let shouldStopPropagation = true;\n          if (!state.isPressed && !e.repeat) {\n            state.target = e.currentTarget;\n            state.isPressed = true;\n            shouldStopPropagation = triggerPressStart(e, 'keyboard');\n            // Focus may move before the key up event, so register the event on the document\n            // instead of the same element where the key down event occurred. Make it capturing so that it will trigger\n            // before stopPropagation from useKeyboard on a child element may happen and thus we can still call triggerPress for the parent element.\n            let originalTarget = e.currentTarget;\n            let pressUp = e => {\n              if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e, originalTarget) && !e.repeat && originalTarget.contains(e.target) && state.target) triggerPressUp($f6c31cce2adf654f$var$createEvent(state.target, e), 'keyboard');\n            };\n            addGlobalListener((0, $7mdmh$getOwnerDocument)(e.currentTarget), 'keyup', (0, $7mdmh$chain)(pressUp, onKeyUp), true);\n          }\n          if (shouldStopPropagation) e.stopPropagation();\n          // Keep track of the keydown events that occur while the Meta (e.g. Command) key is held.\n          // macOS has a bug where keyup events are not fired while the Meta key is down.\n          // When the Meta key itself is released we will get an event for that, and we'll act as if\n          // all of these other keys were released as well.\n          // https://bugs.chromium.org/p/chromium/issues/detail?id=1393524\n          // https://bugs.webkit.org/show_bug.cgi?id=55291\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=1299553\n          if (e.metaKey && (0, $7mdmh$isMac)()) (_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.set(e.key, e.nativeEvent);\n        } else if (e.key === 'Meta') state.metaKeyEvents = new Map();\n      },\n      onClick(e) {\n        if (e && !e.currentTarget.contains(e.target)) return;\n        if (e && e.button === 0 && !state.isTriggeringEvent && !(0, $7mdmh$openLink).isOpening) {\n          let shouldStopPropagation = true;\n          if (isDisabled) e.preventDefault();\n          // If triggered from a screen reader or by using element.click(),\n          // trigger as if it were a keyboard click.\n          if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === 'virtual' || (0, $7mdmh$isVirtualClick)(e.nativeEvent))) {\n            // Ensure the element receives focus (VoiceOver on iOS does not do this)\n            if (!isDisabled && !preventFocusOnPress) (0, $7mdmh$focusWithoutScrolling)(e.currentTarget);\n            let stopPressStart = triggerPressStart(e, 'virtual');\n            let stopPressUp = triggerPressUp(e, 'virtual');\n            let stopPressEnd = triggerPressEnd(e, 'virtual');\n            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;\n          }\n          state.ignoreEmulatedMouseEvents = false;\n          state.ignoreClickAfterPress = false;\n          if (shouldStopPropagation) e.stopPropagation();\n        }\n      }\n    };\n    let onKeyUp = e => {\n      var _state_metaKeyEvents;\n      if (state.isPressed && state.target && $f6c31cce2adf654f$var$isValidKeyboardEvent(e, state.target)) {\n        var _state_metaKeyEvents1;\n        if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();\n        let target = e.target;\n        triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), 'keyboard', state.target.contains(target));\n        removeAllGlobalListeners();\n        // If a link was triggered with a key other than Enter, open the URL ourselves.\n        // This means the link has a role override, and the default browser behavior\n        // only applies when using the Enter key.\n        if (e.key !== 'Enter' && $f6c31cce2adf654f$var$isHTMLAnchorLink(state.target) && state.target.contains(target) && !e[$f6c31cce2adf654f$var$LINK_CLICKED]) {\n          // Store a hidden property on the event so we only trigger link click once,\n          // even if there are multiple usePress instances attached to the element.\n          e[$f6c31cce2adf654f$var$LINK_CLICKED] = true;\n          (0, $7mdmh$openLink)(state.target, e, false);\n        }\n        state.isPressed = false;\n        (_state_metaKeyEvents1 = state.metaKeyEvents) === null || _state_metaKeyEvents1 === void 0 ? void 0 : _state_metaKeyEvents1.delete(e.key);\n      } else if (e.key === 'Meta' && ((_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.size)) {\n        var _state_target;\n        // If we recorded keydown events that occurred while the Meta key was pressed,\n        // and those haven't received keyup events already, fire keyup events ourselves.\n        // See comment above for more info about the macOS bug causing this.\n        let events = state.metaKeyEvents;\n        state.metaKeyEvents = undefined;\n        for (let event of events.values()) (_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.dispatchEvent(new KeyboardEvent('keyup', event));\n      }\n    };\n    if (typeof PointerEvent !== 'undefined') {\n      pressProps.onPointerDown = e => {\n        // Only handle left clicks, and ignore events that bubbled through portals.\n        if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;\n        // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.\n        // Ignore and let the onClick handler take care of it instead.\n        // https://bugs.webkit.org/show_bug.cgi?id=222627\n        // https://bugs.webkit.org/show_bug.cgi?id=223202\n        if ((0, $7mdmh$isVirtualPointerEvent)(e.nativeEvent)) {\n          state.pointerType = 'virtual';\n          return;\n        }\n        // Due to browser inconsistencies, especially on mobile browsers, we prevent\n        // default on pointer down and handle focusing the pressable element ourselves.\n        if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n        state.pointerType = e.pointerType;\n        let shouldStopPropagation = true;\n        if (!state.isPressed) {\n          state.isPressed = true;\n          state.isOverTarget = true;\n          state.activePointerId = e.pointerId;\n          state.target = e.currentTarget;\n          if (!isDisabled && !preventFocusOnPress) (0, $7mdmh$focusWithoutScrolling)(e.currentTarget);\n          if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$16a4697467175487)(state.target);\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n          addGlobalListener((0, $7mdmh$getOwnerDocument)(e.currentTarget), 'pointermove', onPointerMove, false);\n          addGlobalListener((0, $7mdmh$getOwnerDocument)(e.currentTarget), 'pointerup', onPointerUp, false);\n          addGlobalListener((0, $7mdmh$getOwnerDocument)(e.currentTarget), 'pointercancel', onPointerCancel, false);\n        }\n        if (shouldStopPropagation) e.stopPropagation();\n      };\n      pressProps.onMouseDown = e => {\n        if (!e.currentTarget.contains(e.target)) return;\n        if (e.button === 0) {\n          // Chrome and Firefox on touch Windows devices require mouse down events\n          // to be canceled in addition to pointer events, or an extra asynchronous\n          // focus event will be fired.\n          if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n          e.stopPropagation();\n        }\n      };\n      pressProps.onPointerUp = e => {\n        // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.\n        if (!e.currentTarget.contains(e.target) || state.pointerType === 'virtual') return;\n        // Only handle left clicks\n        // Safari on iOS sometimes fires pointerup events, even\n        // when the touch isn't over the target, so double check.\n        if (e.button === 0 && $f6c31cce2adf654f$var$isOverTarget(e, e.currentTarget)) triggerPressUp(e, state.pointerType || e.pointerType);\n      };\n      // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.\n      // Use pointer move events instead to implement our own hit testing.\n      // See https://bugs.webkit.org/show_bug.cgi?id=199803\n      let onPointerMove = e => {\n        if (e.pointerId !== state.activePointerId) return;\n        if (state.target && $f6c31cce2adf654f$var$isOverTarget(e, state.target)) {\n          if (!state.isOverTarget && state.pointerType != null) {\n            state.isOverTarget = true;\n            triggerPressStart($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);\n          }\n        } else if (state.target && state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = false;\n          triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n      };\n      let onPointerUp = e => {\n        if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0 && state.target) {\n          if ($f6c31cce2adf654f$var$isOverTarget(e, state.target) && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);else if (state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n          state.isPressed = false;\n          state.isOverTarget = false;\n          state.activePointerId = null;\n          state.pointerType = null;\n          removeAllGlobalListeners();\n          if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);\n        }\n      };\n      let onPointerCancel = e => {\n        cancel(e);\n      };\n      pressProps.onDragStart = e => {\n        if (!e.currentTarget.contains(e.target)) return;\n        // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.\n        cancel(e);\n      };\n    } else {\n      pressProps.onMouseDown = e => {\n        // Only handle left clicks\n        if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;\n        // Due to browser inconsistencies, especially on mobile browsers, we prevent\n        // default on mouse down and handle focusing the pressable element ourselves.\n        if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n        if (state.ignoreEmulatedMouseEvents) {\n          e.stopPropagation();\n          return;\n        }\n        state.isPressed = true;\n        state.isOverTarget = true;\n        state.target = e.currentTarget;\n        state.pointerType = (0, $7mdmh$isVirtualClick)(e.nativeEvent) ? 'virtual' : 'mouse';\n        if (!isDisabled && !preventFocusOnPress) (0, $7mdmh$focusWithoutScrolling)(e.currentTarget);\n        let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        if (shouldStopPropagation) e.stopPropagation();\n        addGlobalListener((0, $7mdmh$getOwnerDocument)(e.currentTarget), 'mouseup', onMouseUp, false);\n      };\n      pressProps.onMouseEnter = e => {\n        if (!e.currentTarget.contains(e.target)) return;\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n          state.isOverTarget = true;\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        }\n        if (shouldStopPropagation) e.stopPropagation();\n      };\n      pressProps.onMouseLeave = e => {\n        if (!e.currentTarget.contains(e.target)) return;\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n        if (shouldStopPropagation) e.stopPropagation();\n      };\n      pressProps.onMouseUp = e => {\n        if (!e.currentTarget.contains(e.target)) return;\n        if (!state.ignoreEmulatedMouseEvents && e.button === 0) triggerPressUp(e, state.pointerType || 'mouse');\n      };\n      let onMouseUp = e => {\n        // Only handle left clicks\n        if (e.button !== 0) return;\n        state.isPressed = false;\n        removeAllGlobalListeners();\n        if (state.ignoreEmulatedMouseEvents) {\n          state.ignoreEmulatedMouseEvents = false;\n          return;\n        }\n        if (state.target && $f6c31cce2adf654f$var$isOverTarget(e, state.target) && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);else if (state.target && state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n        state.isOverTarget = false;\n      };\n      pressProps.onTouchStart = e => {\n        if (!e.currentTarget.contains(e.target)) return;\n        let touch = $f6c31cce2adf654f$var$getTouchFromEvent(e.nativeEvent);\n        if (!touch) return;\n        state.activePointerId = touch.identifier;\n        state.ignoreEmulatedMouseEvents = true;\n        state.isOverTarget = true;\n        state.isPressed = true;\n        state.target = e.currentTarget;\n        state.pointerType = 'touch';\n        // Due to browser inconsistencies, especially on mobile browsers, we prevent default\n        // on the emulated mouse event and handle focusing the pressable element ourselves.\n        if (!isDisabled && !preventFocusOnPress) (0, $7mdmh$focusWithoutScrolling)(e.currentTarget);\n        if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$16a4697467175487)(state.target);\n        let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        if (shouldStopPropagation) e.stopPropagation();\n        addGlobalListener((0, $7mdmh$getOwnerWindow)(e.currentTarget), 'scroll', onScroll, true);\n      };\n      pressProps.onTouchMove = e => {\n        if (!e.currentTarget.contains(e.target)) return;\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n        let touch = $f6c31cce2adf654f$var$getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e.currentTarget)) {\n          if (!state.isOverTarget && state.pointerType != null) {\n            state.isOverTarget = true;\n            shouldStopPropagation = triggerPressStart(e, state.pointerType);\n          }\n        } else if (state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n        if (shouldStopPropagation) e.stopPropagation();\n      };\n      pressProps.onTouchEnd = e => {\n        if (!e.currentTarget.contains(e.target)) return;\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n        let touch = $f6c31cce2adf654f$var$getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e.currentTarget) && state.pointerType != null) {\n          triggerPressUp(e, state.pointerType);\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType);\n        } else if (state.isOverTarget && state.pointerType != null) shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n        if (shouldStopPropagation) e.stopPropagation();\n        state.isPressed = false;\n        state.activePointerId = null;\n        state.isOverTarget = false;\n        state.ignoreEmulatedMouseEvents = true;\n        if (state.target && !allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);\n        removeAllGlobalListeners();\n      };\n      pressProps.onTouchCancel = e => {\n        if (!e.currentTarget.contains(e.target)) return;\n        e.stopPropagation();\n        if (state.isPressed) cancel(e);\n      };\n      let onScroll = e => {\n        if (state.isPressed && e.target.contains(state.target)) cancel({\n          currentTarget: state.target,\n          shiftKey: false,\n          ctrlKey: false,\n          metaKey: false,\n          altKey: false\n        });\n      };\n      pressProps.onDragStart = e => {\n        if (!e.currentTarget.contains(e.target)) return;\n        cancel(e);\n      };\n    }\n    return pressProps;\n  }, [addGlobalListener, isDisabled, preventFocusOnPress, removeAllGlobalListeners, allowTextSelectionOnPress, cancel, cancelOnPointerExit, triggerPressEnd, triggerPressStart, triggerPressUp]);\n  // Remove user-select: none in case component unmounts immediately after pressStart\n  // eslint-disable-next-line arrow-body-style\n  (0, $7mdmh$useEffect)(() => {\n    return () => {\n      var _ref_current_target;\n      if (!allowTextSelectionOnPress)\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)((_ref_current_target = ref.current.target) !== null && _ref_current_target !== void 0 ? _ref_current_target : undefined);\n    };\n  }, [allowTextSelectionOnPress]);\n  return {\n    isPressed: isPressedProp || isPressed,\n    pressProps: (0, $7mdmh$mergeProps)(domProps, pressProps)\n  };\n}\nfunction $f6c31cce2adf654f$var$isHTMLAnchorLink(target) {\n  return target.tagName === 'A' && target.hasAttribute('href');\n}\nfunction $f6c31cce2adf654f$var$isValidKeyboardEvent(event, currentTarget) {\n  const {\n    key: key,\n    code: code\n  } = event;\n  const element = currentTarget;\n  const role = element.getAttribute('role');\n  // Accessibility for keyboards. Space and Enter only.\n  // \"Spacebar\" is for IE 11\n  return (key === 'Enter' || key === ' ' || key === 'Spacebar' || code === 'Space') && !(element instanceof (0, $7mdmh$getOwnerWindow)(element).HTMLInputElement && !$f6c31cce2adf654f$var$isValidInputKey(element, key) || element instanceof (0, $7mdmh$getOwnerWindow)(element).HTMLTextAreaElement || element.isContentEditable) &&\n  // Links should only trigger with Enter key\n  !((role === 'link' || !role && $f6c31cce2adf654f$var$isHTMLAnchorLink(element)) && key !== 'Enter');\n}\nfunction $f6c31cce2adf654f$var$getTouchFromEvent(event) {\n  const {\n    targetTouches: targetTouches\n  } = event;\n  if (targetTouches.length > 0) return targetTouches[0];\n  return null;\n}\nfunction $f6c31cce2adf654f$var$getTouchById(event, pointerId) {\n  const changedTouches = event.changedTouches;\n  for (let i = 0; i < changedTouches.length; i++) {\n    const touch = changedTouches[i];\n    if (touch.identifier === pointerId) return touch;\n  }\n  return null;\n}\nfunction $f6c31cce2adf654f$var$createEvent(target, e) {\n  return {\n    currentTarget: target,\n    shiftKey: e.shiftKey,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey\n  };\n}\nfunction $f6c31cce2adf654f$var$getPointClientRect(point) {\n  let offsetX = 0;\n  let offsetY = 0;\n  if (point.width !== undefined) offsetX = point.width / 2;else if (point.radiusX !== undefined) offsetX = point.radiusX;\n  if (point.height !== undefined) offsetY = point.height / 2;else if (point.radiusY !== undefined) offsetY = point.radiusY;\n  return {\n    top: point.clientY - offsetY,\n    right: point.clientX + offsetX,\n    bottom: point.clientY + offsetY,\n    left: point.clientX - offsetX\n  };\n}\nfunction $f6c31cce2adf654f$var$areRectanglesOverlapping(a, b) {\n  // check if they cannot overlap on x axis\n  if (a.left > b.right || b.left > a.right) return false;\n  // check if they cannot overlap on y axis\n  if (a.top > b.bottom || b.top > a.bottom) return false;\n  return true;\n}\nfunction $f6c31cce2adf654f$var$isOverTarget(point, target) {\n  let rect = target.getBoundingClientRect();\n  let pointRect = $f6c31cce2adf654f$var$getPointClientRect(point);\n  return $f6c31cce2adf654f$var$areRectanglesOverlapping(rect, pointRect);\n}\nfunction $f6c31cce2adf654f$var$shouldPreventDefault(target) {\n  // We cannot prevent default if the target is a draggable element.\n  return !(target instanceof HTMLElement) || !target.hasAttribute('draggable');\n}\nfunction $f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(target, key) {\n  if (target instanceof HTMLInputElement) return !$f6c31cce2adf654f$var$isValidInputKey(target, key);\n  if (target instanceof HTMLButtonElement) return target.type !== 'submit' && target.type !== 'reset';\n  if ($f6c31cce2adf654f$var$isHTMLAnchorLink(target)) return false;\n  return true;\n}\nconst $f6c31cce2adf654f$var$nonTextInputTypes = new Set(['checkbox', 'radio', 'range', 'color', 'file', 'image', 'button', 'submit', 'reset']);\nfunction $f6c31cce2adf654f$var$isValidInputKey(target, key) {\n  // Only space should toggle checkboxes and radios, not enter.\n  return target.type === 'checkbox' || target.type === 'radio' ? key === ' ' : $f6c31cce2adf654f$var$nonTextInputTypes.has(target.type);\n}\nexport { $f6c31cce2adf654f$export$45712eceda6fad21 as usePress };","map":{"version":3,"mappings":"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","names":["$f6c31cce2adf654f$var$usePressResponderContext","props","context","register","contextProps","ref","$f6c31cce2adf654f$var$_shouldStopPropagation","$f6c31cce2adf654f$var$PressEvent","continuePropagation","shouldStopPropagation","constructor","type","pointerType","originalEvent","target","currentTarget","shiftKey","metaKey","ctrlKey","altKey","$f6c31cce2adf654f$var$LINK_CLICKED","Symbol","$f6c31cce2adf654f$export$45712eceda6fad21","onPress","onPressChange","onPressStart","onPressEnd","onPressUp","isDisabled","isPressed","isPressedProp","preventFocusOnPress","shouldCancelOnPointerExit","allowTextSelectionOnPress","_","domProps","setPressed","ignoreEmulatedMouseEvents","ignoreClickAfterPress","didFirePressStart","isTriggeringEvent","activePointerId","isOverTarget","addGlobalListener","removeAllGlobalListeners","triggerPressStart","state","current","event","triggerPressEnd","wasPressed","triggerPressUp","cancel","e","$f6c31cce2adf654f$var$createEvent","cancelOnPointerExit","pressProps","onKeyDown","$f6c31cce2adf654f$var$isValidKeyboardEvent","nativeEvent","contains","_state_metaKeyEvents","$f6c31cce2adf654f$var$shouldPreventDefaultKeyboard","key","preventDefault","repeat","originalTarget","pressUp","onKeyUp","stopPropagation","metaKeyEvents","set","Map","onClick","button","isOpening","stopPressStart","stopPressUp","stopPressEnd","_state_metaKeyEvents1","$f6c31cce2adf654f$var$isHTMLAnchorLink","delete","size","_state_target","events","undefined","values","dispatchEvent","KeyboardEvent","PointerEvent","onPointerDown","$f6c31cce2adf654f$var$shouldPreventDefault","pointerId","onPointerMove","onPointerUp","onPointerCancel","onMouseDown","$f6c31cce2adf654f$var$isOverTarget","onDragStart","onMouseUp","onMouseEnter","onMouseLeave","onTouchStart","touch","$f6c31cce2adf654f$var$getTouchFromEvent","identifier","onScroll","onTouchMove","$f6c31cce2adf654f$var$getTouchById","onTouchEnd","onTouchCancel","_ref_current_target","tagName","hasAttribute","code","element","role","getAttribute","HTMLInputElement","$f6c31cce2adf654f$var$isValidInputKey","HTMLTextAreaElement","isContentEditable","targetTouches","length","changedTouches","i","$f6c31cce2adf654f$var$getPointClientRect","point","offsetX","offsetY","width","radiusX","height","radiusY","top","clientY","right","clientX","bottom","left","$f6c31cce2adf654f$var$areRectanglesOverlapping","a","b","rect","getBoundingClientRect","pointRect","HTMLElement","HTMLButtonElement","$f6c31cce2adf654f$var$nonTextInputTypes","Set","has"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-aria\\interactions\\dist\\packages\\@react-aria\\interactions\\src\\usePress.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {chain, focusWithoutScrolling, getOwnerDocument, getOwnerWindow, isMac, isVirtualClick, isVirtualPointerEvent, mergeProps, openLink, useEffectEvent, useGlobalListeners, useSyncRef} from '@react-aria/utils';\nimport {disableTextSelection, restoreTextSelection} from './textSelection';\nimport {DOMAttributes, FocusableElement, PressEvent as IPressEvent, PointerType, PressEvents} from '@react-types/shared';\nimport {PressResponderContext} from './context';\nimport {RefObject, useContext, useEffect, useMemo, useRef, useState} from 'react';\n\nexport interface PressProps extends PressEvents {\n  /** Whether the target is in a controlled press state (e.g. an overlay it triggers is open). */\n  isPressed?: boolean,\n  /** Whether the press events should be disabled. */\n  isDisabled?: boolean,\n  /** Whether the target should not receive focus on press. */\n  preventFocusOnPress?: boolean,\n  /**\n   * Whether press events should be canceled when the pointer leaves the target while pressed.\n   * By default, this is `false`, which means if the pointer returns back over the target while\n   * still pressed, onPressStart will be fired again. If set to `true`, the press is canceled\n   * when the pointer leaves the target and onPressStart will not be fired if the pointer returns.\n   */\n  shouldCancelOnPointerExit?: boolean,\n  /** Whether text selection should be enabled on the pressable element. */\n  allowTextSelectionOnPress?: boolean\n}\n\nexport interface PressHookProps extends PressProps {\n  /** A ref to the target element. */\n  ref?: RefObject<Element>\n}\n\ninterface PressState {\n  isPressed: boolean,\n  ignoreEmulatedMouseEvents: boolean,\n  ignoreClickAfterPress: boolean,\n  didFirePressStart: boolean,\n  isTriggeringEvent: boolean,\n  activePointerId: any,\n  target: FocusableElement | null,\n  isOverTarget: boolean,\n  pointerType: PointerType | null,\n  userSelect?: string,\n  metaKeyEvents?: Map<string, KeyboardEvent>\n}\n\ninterface EventBase {\n  currentTarget: EventTarget | null,\n  shiftKey: boolean,\n  ctrlKey: boolean,\n  metaKey: boolean,\n  altKey: boolean\n}\n\nexport interface PressResult {\n  /** Whether the target is currently pressed. */\n  isPressed: boolean,\n  /** Props to spread on the target element. */\n  pressProps: DOMAttributes\n}\n\nfunction usePressResponderContext(props: PressHookProps): PressHookProps {\n  // Consume context from <PressResponder> and merge with props.\n  let context = useContext(PressResponderContext);\n  if (context) {\n    let {register, ...contextProps} = context;\n    props = mergeProps(contextProps, props) as PressHookProps;\n    register();\n  }\n  useSyncRef(context, props.ref);\n\n  return props;\n}\n\nclass PressEvent implements IPressEvent {\n  type: IPressEvent['type'];\n  pointerType: PointerType;\n  target: Element;\n  shiftKey: boolean;\n  ctrlKey: boolean;\n  metaKey: boolean;\n  altKey: boolean;\n  #shouldStopPropagation = true;\n\n  constructor(type: IPressEvent['type'], pointerType: PointerType, originalEvent: EventBase) {\n    this.type = type;\n    this.pointerType = pointerType;\n    this.target = originalEvent.currentTarget as Element;\n    this.shiftKey = originalEvent.shiftKey;\n    this.metaKey = originalEvent.metaKey;\n    this.ctrlKey = originalEvent.ctrlKey;\n    this.altKey = originalEvent.altKey;\n  }\n\n  continuePropagation() {\n    this.#shouldStopPropagation = false;\n  }\n\n  get shouldStopPropagation() {\n    return this.#shouldStopPropagation;\n  }\n}\n\nconst LINK_CLICKED = Symbol('linkClicked');\n\n/**\n * Handles press interactions across mouse, touch, keyboard, and screen readers.\n * It normalizes behavior across browsers and platforms, and handles many nuances\n * of dealing with pointer and keyboard events.\n */\nexport function usePress(props: PressHookProps): PressResult {\n  let {\n    onPress,\n    onPressChange,\n    onPressStart,\n    onPressEnd,\n    onPressUp,\n    isDisabled,\n    isPressed: isPressedProp,\n    preventFocusOnPress,\n    shouldCancelOnPointerExit,\n    allowTextSelectionOnPress,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ref: _, // Removing `ref` from `domProps` because TypeScript is dumb\n    ...domProps\n  } = usePressResponderContext(props);\n\n  let [isPressed, setPressed] = useState(false);\n  let ref = useRef<PressState>({\n    isPressed: false,\n    ignoreEmulatedMouseEvents: false,\n    ignoreClickAfterPress: false,\n    didFirePressStart: false,\n    isTriggeringEvent: false,\n    activePointerId: null,\n    target: null,\n    isOverTarget: false,\n    pointerType: null\n  });\n\n  let {addGlobalListener, removeAllGlobalListeners} = useGlobalListeners();\n\n  let triggerPressStart = useEffectEvent((originalEvent: EventBase, pointerType: PointerType) => {\n    let state = ref.current;\n    if (isDisabled || state.didFirePressStart) {\n      return false;\n    }\n\n    let shouldStopPropagation = true;\n    state.isTriggeringEvent = true;\n    if (onPressStart) {\n      let event = new PressEvent('pressstart', pointerType, originalEvent);\n      onPressStart(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n\n    if (onPressChange) {\n      onPressChange(true);\n    }\n\n    state.isTriggeringEvent = false;\n    state.didFirePressStart = true;\n    setPressed(true);\n    return shouldStopPropagation;\n  });\n\n  let triggerPressEnd = useEffectEvent((originalEvent: EventBase, pointerType: PointerType, wasPressed = true) => {\n    let state = ref.current;\n    if (!state.didFirePressStart) {\n      return false;\n    }\n\n    state.ignoreClickAfterPress = true;\n    state.didFirePressStart = false;\n    state.isTriggeringEvent = true;\n\n    let shouldStopPropagation = true;\n    if (onPressEnd) {\n      let event = new PressEvent('pressend', pointerType, originalEvent);\n      onPressEnd(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n\n    if (onPressChange) {\n      onPressChange(false);\n    }\n\n    setPressed(false);\n\n    if (onPress && wasPressed && !isDisabled) {\n      let event = new PressEvent('press', pointerType, originalEvent);\n      onPress(event);\n      shouldStopPropagation &&= event.shouldStopPropagation;\n    }\n\n    state.isTriggeringEvent = false;\n    return shouldStopPropagation;\n  });\n\n  let triggerPressUp = useEffectEvent((originalEvent: EventBase, pointerType: PointerType) => {\n    let state = ref.current;\n    if (isDisabled) {\n      return false;\n    }\n\n    if (onPressUp) {\n      state.isTriggeringEvent = true;\n      let event = new PressEvent('pressup', pointerType, originalEvent);\n      onPressUp(event);\n      state.isTriggeringEvent = false;\n      return event.shouldStopPropagation;\n    }\n\n    return true;\n  });\n\n  let cancel = useEffectEvent((e: EventBase) => {\n    let state = ref.current;\n    if (state.isPressed && state.target) {\n      if (state.isOverTarget && state.pointerType != null) {\n        triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n      }\n      state.isPressed = false;\n      state.isOverTarget = false;\n      state.activePointerId = null;\n      state.pointerType = null;\n      removeAllGlobalListeners();\n      if (!allowTextSelectionOnPress) {\n        restoreTextSelection(state.target);\n      }\n    }\n  });\n\n  let cancelOnPointerExit = useEffectEvent((e: EventBase) => {\n    if (shouldCancelOnPointerExit) {\n      cancel(e);\n    }\n  });\n\n  let pressProps = useMemo(() => {\n    let state = ref.current;\n    let pressProps: DOMAttributes = {\n      onKeyDown(e) {\n        if (isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target as Element)) {\n          if (shouldPreventDefaultKeyboard(e.target as Element, e.key)) {\n            e.preventDefault();\n          }\n\n          // If the event is repeating, it may have started on a different element\n          // after which focus moved to the current element. Ignore these events and\n          // only handle the first key down event.\n          let shouldStopPropagation = true;\n          if (!state.isPressed && !e.repeat) {\n            state.target = e.currentTarget;\n            state.isPressed = true;\n            shouldStopPropagation = triggerPressStart(e, 'keyboard');\n\n            // Focus may move before the key up event, so register the event on the document\n            // instead of the same element where the key down event occurred. Make it capturing so that it will trigger\n            // before stopPropagation from useKeyboard on a child element may happen and thus we can still call triggerPress for the parent element.\n            let originalTarget = e.currentTarget;\n            let pressUp = (e) => {\n              if (isValidKeyboardEvent(e, originalTarget) && !e.repeat && originalTarget.contains(e.target as Element) && state.target) {\n                triggerPressUp(createEvent(state.target, e), 'keyboard');\n              }\n            };\n\n            addGlobalListener(getOwnerDocument(e.currentTarget), 'keyup', chain(pressUp, onKeyUp), true);\n          }\n\n          if (shouldStopPropagation) {\n            e.stopPropagation();\n          }\n\n          // Keep track of the keydown events that occur while the Meta (e.g. Command) key is held.\n          // macOS has a bug where keyup events are not fired while the Meta key is down.\n          // When the Meta key itself is released we will get an event for that, and we'll act as if\n          // all of these other keys were released as well.\n          // https://bugs.chromium.org/p/chromium/issues/detail?id=1393524\n          // https://bugs.webkit.org/show_bug.cgi?id=55291\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=1299553\n          if (e.metaKey && isMac()) {\n            state.metaKeyEvents?.set(e.key, e.nativeEvent);\n          }\n        } else if (e.key === 'Meta') {\n          state.metaKeyEvents = new Map();\n        }\n      },\n      onClick(e) {\n        if (e && !e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        if (e && e.button === 0 && !state.isTriggeringEvent && !(openLink as any).isOpening) {\n          let shouldStopPropagation = true;\n          if (isDisabled) {\n            e.preventDefault();\n          }\n\n          // If triggered from a screen reader or by using element.click(),\n          // trigger as if it were a keyboard click.\n          if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === 'virtual' || isVirtualClick(e.nativeEvent))) {\n            // Ensure the element receives focus (VoiceOver on iOS does not do this)\n            if (!isDisabled && !preventFocusOnPress) {\n              focusWithoutScrolling(e.currentTarget);\n            }\n\n            let stopPressStart = triggerPressStart(e, 'virtual');\n            let stopPressUp = triggerPressUp(e, 'virtual');\n            let stopPressEnd = triggerPressEnd(e, 'virtual');\n            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;\n          }\n\n          state.ignoreEmulatedMouseEvents = false;\n          state.ignoreClickAfterPress = false;\n          if (shouldStopPropagation) {\n            e.stopPropagation();\n          }\n        }\n      }\n    };\n\n    let onKeyUp = (e: KeyboardEvent) => {\n      if (state.isPressed && state.target && isValidKeyboardEvent(e, state.target)) {\n        if (shouldPreventDefaultKeyboard(e.target as Element, e.key)) {\n          e.preventDefault();\n        }\n\n        let target = e.target as Element;\n        triggerPressEnd(createEvent(state.target, e), 'keyboard', state.target.contains(target));\n        removeAllGlobalListeners();\n\n        // If a link was triggered with a key other than Enter, open the URL ourselves.\n        // This means the link has a role override, and the default browser behavior\n        // only applies when using the Enter key.\n        if (e.key !== 'Enter' && isHTMLAnchorLink(state.target) && state.target.contains(target) && !e[LINK_CLICKED]) {\n          // Store a hidden property on the event so we only trigger link click once,\n          // even if there are multiple usePress instances attached to the element.\n          e[LINK_CLICKED] = true;\n          openLink(state.target, e, false);\n        }\n\n        state.isPressed = false;\n        state.metaKeyEvents?.delete(e.key);\n      } else if (e.key === 'Meta' && state.metaKeyEvents?.size) {\n        // If we recorded keydown events that occurred while the Meta key was pressed,\n        // and those haven't received keyup events already, fire keyup events ourselves.\n        // See comment above for more info about the macOS bug causing this.\n        let events = state.metaKeyEvents;\n        state.metaKeyEvents = undefined;\n        for (let event of events.values()) {\n          state.target?.dispatchEvent(new KeyboardEvent('keyup', event));\n        }\n      }\n    };\n\n    if (typeof PointerEvent !== 'undefined') {\n      pressProps.onPointerDown = (e) => {\n        // Only handle left clicks, and ignore events that bubbled through portals.\n        if (e.button !== 0 || !e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.\n        // Ignore and let the onClick handler take care of it instead.\n        // https://bugs.webkit.org/show_bug.cgi?id=222627\n        // https://bugs.webkit.org/show_bug.cgi?id=223202\n        if (isVirtualPointerEvent(e.nativeEvent)) {\n          state.pointerType = 'virtual';\n          return;\n        }\n\n        // Due to browser inconsistencies, especially on mobile browsers, we prevent\n        // default on pointer down and handle focusing the pressable element ourselves.\n        if (shouldPreventDefault(e.currentTarget as Element)) {\n          e.preventDefault();\n        }\n\n        state.pointerType = e.pointerType;\n\n        let shouldStopPropagation = true;\n        if (!state.isPressed) {\n          state.isPressed = true;\n          state.isOverTarget = true;\n          state.activePointerId = e.pointerId;\n          state.target = e.currentTarget;\n\n          if (!isDisabled && !preventFocusOnPress) {\n            focusWithoutScrolling(e.currentTarget);\n          }\n\n          if (!allowTextSelectionOnPress) {\n            disableTextSelection(state.target);\n          }\n\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n\n          addGlobalListener(getOwnerDocument(e.currentTarget), 'pointermove', onPointerMove, false);\n          addGlobalListener(getOwnerDocument(e.currentTarget), 'pointerup', onPointerUp, false);\n          addGlobalListener(getOwnerDocument(e.currentTarget), 'pointercancel', onPointerCancel, false);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onMouseDown = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        if (e.button === 0) {\n          // Chrome and Firefox on touch Windows devices require mouse down events\n          // to be canceled in addition to pointer events, or an extra asynchronous\n          // focus event will be fired.\n          if (shouldPreventDefault(e.currentTarget as Element)) {\n            e.preventDefault();\n          }\n\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onPointerUp = (e) => {\n        // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.\n        if (!e.currentTarget.contains(e.target as Element) || state.pointerType === 'virtual') {\n          return;\n        }\n\n        // Only handle left clicks\n        // Safari on iOS sometimes fires pointerup events, even\n        // when the touch isn't over the target, so double check.\n        if (e.button === 0 && isOverTarget(e, e.currentTarget)) {\n          triggerPressUp(e, state.pointerType || e.pointerType);\n        }\n      };\n\n      // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.\n      // Use pointer move events instead to implement our own hit testing.\n      // See https://bugs.webkit.org/show_bug.cgi?id=199803\n      let onPointerMove = (e: PointerEvent) => {\n        if (e.pointerId !== state.activePointerId) {\n          return;\n        }\n\n        if (state.target && isOverTarget(e, state.target)) {\n          if (!state.isOverTarget && state.pointerType != null) {\n            state.isOverTarget = true;\n            triggerPressStart(createEvent(state.target, e), state.pointerType);\n          }\n        } else if (state.target && state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = false;\n          triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n      };\n\n      let onPointerUp = (e: PointerEvent) => {\n        if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0 && state.target) {\n          if (isOverTarget(e, state.target) && state.pointerType != null) {\n            triggerPressEnd(createEvent(state.target, e), state.pointerType);\n          } else if (state.isOverTarget && state.pointerType != null) {\n            triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n          }\n\n          state.isPressed = false;\n          state.isOverTarget = false;\n          state.activePointerId = null;\n          state.pointerType = null;\n          removeAllGlobalListeners();\n          if (!allowTextSelectionOnPress) {\n            restoreTextSelection(state.target);\n          }\n        }\n      };\n\n      let onPointerCancel = (e: PointerEvent) => {\n        cancel(e);\n      };\n\n      pressProps.onDragStart = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.\n        cancel(e);\n      };\n    } else {\n      pressProps.onMouseDown = (e) => {\n        // Only handle left clicks\n        if (e.button !== 0 || !e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        // Due to browser inconsistencies, especially on mobile browsers, we prevent\n        // default on mouse down and handle focusing the pressable element ourselves.\n        if (shouldPreventDefault(e.currentTarget)) {\n          e.preventDefault();\n        }\n\n        if (state.ignoreEmulatedMouseEvents) {\n          e.stopPropagation();\n          return;\n        }\n\n        state.isPressed = true;\n        state.isOverTarget = true;\n        state.target = e.currentTarget;\n        state.pointerType = isVirtualClick(e.nativeEvent) ? 'virtual' : 'mouse';\n\n        if (!isDisabled && !preventFocusOnPress) {\n          focusWithoutScrolling(e.currentTarget);\n        }\n\n        let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n\n        addGlobalListener(getOwnerDocument(e.currentTarget), 'mouseup', onMouseUp, false);\n      };\n\n      pressProps.onMouseEnter = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n          state.isOverTarget = true;\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onMouseLeave = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onMouseUp = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        if (!state.ignoreEmulatedMouseEvents && e.button === 0) {\n          triggerPressUp(e, state.pointerType || 'mouse');\n        }\n      };\n\n      let onMouseUp = (e: MouseEvent) => {\n        // Only handle left clicks\n        if (e.button !== 0) {\n          return;\n        }\n\n        state.isPressed = false;\n        removeAllGlobalListeners();\n\n        if (state.ignoreEmulatedMouseEvents) {\n          state.ignoreEmulatedMouseEvents = false;\n          return;\n        }\n\n        if (state.target && isOverTarget(e, state.target) && state.pointerType != null) {\n          triggerPressEnd(createEvent(state.target, e), state.pointerType);\n        } else if (state.target && state.isOverTarget && state.pointerType != null) {\n          triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n        }\n\n        state.isOverTarget = false;\n      };\n\n      pressProps.onTouchStart = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        let touch = getTouchFromEvent(e.nativeEvent);\n        if (!touch) {\n          return;\n        }\n        state.activePointerId = touch.identifier;\n        state.ignoreEmulatedMouseEvents = true;\n        state.isOverTarget = true;\n        state.isPressed = true;\n        state.target = e.currentTarget;\n        state.pointerType = 'touch';\n\n        // Due to browser inconsistencies, especially on mobile browsers, we prevent default\n        // on the emulated mouse event and handle focusing the pressable element ourselves.\n        if (!isDisabled && !preventFocusOnPress) {\n          focusWithoutScrolling(e.currentTarget);\n        }\n\n        if (!allowTextSelectionOnPress) {\n          disableTextSelection(state.target);\n        }\n\n        let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n\n        addGlobalListener(getOwnerWindow(e.currentTarget), 'scroll', onScroll, true);\n      };\n\n      pressProps.onTouchMove = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n\n        let touch = getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && isOverTarget(touch, e.currentTarget)) {\n          if (!state.isOverTarget && state.pointerType != null) {\n            state.isOverTarget = true;\n            shouldStopPropagation = triggerPressStart(e, state.pointerType);\n          }\n        } else if (state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onTouchEnd = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n\n        let touch = getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && isOverTarget(touch, e.currentTarget) && state.pointerType != null) {\n          triggerPressUp(e, state.pointerType);\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType);\n        } else if (state.isOverTarget && state.pointerType != null) {\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n\n        state.isPressed = false;\n        state.activePointerId = null;\n        state.isOverTarget = false;\n        state.ignoreEmulatedMouseEvents = true;\n        if (state.target && !allowTextSelectionOnPress) {\n          restoreTextSelection(state.target);\n        }\n        removeAllGlobalListeners();\n      };\n\n      pressProps.onTouchCancel = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        e.stopPropagation();\n        if (state.isPressed) {\n          cancel(e);\n        }\n      };\n\n      let onScroll = (e: Event) => {\n        if (state.isPressed && (e.target as Element).contains(state.target)) {\n          cancel({\n            currentTarget: state.target,\n            shiftKey: false,\n            ctrlKey: false,\n            metaKey: false,\n            altKey: false\n          });\n        }\n      };\n\n      pressProps.onDragStart = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        cancel(e);\n      };\n    }\n\n    return pressProps;\n  }, [\n    addGlobalListener,\n    isDisabled,\n    preventFocusOnPress,\n    removeAllGlobalListeners,\n    allowTextSelectionOnPress,\n    cancel,\n    cancelOnPointerExit,\n    triggerPressEnd,\n    triggerPressStart,\n    triggerPressUp\n  ]);\n\n  // Remove user-select: none in case component unmounts immediately after pressStart\n  // eslint-disable-next-line arrow-body-style\n  useEffect(() => {\n    return () => {\n      if (!allowTextSelectionOnPress) {\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        restoreTextSelection(ref.current.target ?? undefined);\n      }\n    };\n  }, [allowTextSelectionOnPress]);\n\n  return {\n    isPressed: isPressedProp || isPressed,\n    pressProps: mergeProps(domProps, pressProps)\n  };\n}\n\nfunction isHTMLAnchorLink(target: Element): target is HTMLAnchorElement {\n  return target.tagName === 'A' && target.hasAttribute('href');\n}\n\nfunction isValidKeyboardEvent(event: KeyboardEvent, currentTarget: Element): boolean {\n  const {key, code} = event;\n  const element = currentTarget as HTMLElement;\n  const role = element.getAttribute('role');\n  // Accessibility for keyboards. Space and Enter only.\n  // \"Spacebar\" is for IE 11\n  return (\n    (key === 'Enter' || key === ' ' || key === 'Spacebar' || code === 'Space') &&\n    !((element instanceof getOwnerWindow(element).HTMLInputElement && !isValidInputKey(element, key)) ||\n      element instanceof getOwnerWindow(element).HTMLTextAreaElement ||\n      element.isContentEditable) &&\n    // Links should only trigger with Enter key\n    !((role === 'link' || (!role && isHTMLAnchorLink(element))) && key !== 'Enter')\n  );\n}\n\nfunction getTouchFromEvent(event: TouchEvent): Touch | null {\n  const {targetTouches} = event;\n  if (targetTouches.length > 0) {\n    return targetTouches[0];\n  }\n  return null;\n}\n\nfunction getTouchById(\n  event: TouchEvent,\n  pointerId: null | number\n): null | Touch {\n  const changedTouches = event.changedTouches;\n  for (let i = 0; i < changedTouches.length; i++) {\n    const touch = changedTouches[i];\n    if (touch.identifier === pointerId) {\n      return touch;\n    }\n  }\n  return null;\n}\n\nfunction createEvent(target: FocusableElement, e: EventBase): EventBase {\n  return {\n    currentTarget: target,\n    shiftKey: e.shiftKey,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey\n  };\n}\n\ninterface Rect {\n  top: number,\n  right: number,\n  bottom: number,\n  left: number\n}\n\ninterface EventPoint {\n  clientX: number,\n  clientY: number,\n  width?: number,\n  height?: number,\n  radiusX?: number,\n  radiusY?: number\n}\n\nfunction getPointClientRect(point: EventPoint): Rect {\n  let offsetX = 0;\n  let offsetY = 0;\n  if (point.width !== undefined) {\n    offsetX = (point.width / 2);\n  } else if (point.radiusX !== undefined) {\n    offsetX = point.radiusX;\n  }\n  if (point.height !== undefined) {\n    offsetY = (point.height / 2);\n  } else if (point.radiusY !== undefined) {\n    offsetY = point.radiusY;\n  }\n\n  return {\n    top: point.clientY - offsetY,\n    right: point.clientX + offsetX,\n    bottom: point.clientY + offsetY,\n    left: point.clientX - offsetX\n  };\n}\n\nfunction areRectanglesOverlapping(a: Rect, b: Rect) {\n  // check if they cannot overlap on x axis\n  if (a.left > b.right || b.left > a.right) {\n    return false;\n  }\n  // check if they cannot overlap on y axis\n  if (a.top > b.bottom || b.top > a.bottom) {\n    return false;\n  }\n  return true;\n}\n\nfunction isOverTarget(point: EventPoint, target: Element) {\n  let rect = target.getBoundingClientRect();\n  let pointRect = getPointClientRect(point);\n  return areRectanglesOverlapping(rect, pointRect);\n}\n\nfunction shouldPreventDefault(target: Element) {\n  // We cannot prevent default if the target is a draggable element.\n  return !(target instanceof HTMLElement) || !target.hasAttribute('draggable');\n}\n\nfunction shouldPreventDefaultKeyboard(target: Element, key: string) {\n  if (target instanceof HTMLInputElement) {\n    return !isValidInputKey(target, key);\n  }\n\n  if (target instanceof HTMLButtonElement) {\n    return target.type !== 'submit' && target.type !== 'reset';\n  }\n\n  if (isHTMLAnchorLink(target)) {\n    return false;\n  }\n\n  return true;\n}\n\nconst nonTextInputTypes = new Set([\n  'checkbox',\n  'radio',\n  'range',\n  'color',\n  'file',\n  'image',\n  'button',\n  'submit',\n  'reset'\n]);\n\nfunction isValidInputKey(target: HTMLInputElement, key: string) {\n  // Only space should toggle checkboxes and radios, not enter.\n  return target.type === 'checkbox' || target.type === 'radio'\n    ? key === ' '\n    : nonTextInputTypes.has(target.type);\n}\n"]},"metadata":{},"sourceType":"module"}