{"ast":null,"code":"import { snapValueToStep as $BT4Uh$snapValueToStep, useControlledState as $BT4Uh$useControlledState, clamp as $BT4Uh$clamp } from \"@react-stately/utils\";\nimport { useMemo as $BT4Uh$useMemo, useCallback as $BT4Uh$useCallback, useState as $BT4Uh$useState, useRef as $BT4Uh$useRef } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $28f99e3e86e6ec45$var$DEFAULT_MIN_VALUE = 0;\nconst $28f99e3e86e6ec45$var$DEFAULT_MAX_VALUE = 100;\nconst $28f99e3e86e6ec45$var$DEFAULT_STEP_VALUE = 1;\nfunction $28f99e3e86e6ec45$export$e5fda3247f5d67f9(props) {\n  const {\n    isDisabled = false,\n    minValue = $28f99e3e86e6ec45$var$DEFAULT_MIN_VALUE,\n    maxValue = $28f99e3e86e6ec45$var$DEFAULT_MAX_VALUE,\n    numberFormatter: formatter,\n    step = $28f99e3e86e6ec45$var$DEFAULT_STEP_VALUE,\n    orientation = 'horizontal'\n  } = props;\n  // Page step should be at least equal to step and always a multiple of the step.\n  let pageSize = (0, $BT4Uh$useMemo)(() => {\n    let calcPageSize = (maxValue - minValue) / 10;\n    calcPageSize = (0, $BT4Uh$snapValueToStep)(calcPageSize, 0, calcPageSize + step, step);\n    return Math.max(calcPageSize, step);\n  }, [step, maxValue, minValue]);\n  let restrictValues = (0, $BT4Uh$useCallback)(values => values === null || values === void 0 ? void 0 : values.map((val, idx) => {\n    let min = idx === 0 ? minValue : val[idx - 1];\n    let max = idx === values.length - 1 ? maxValue : val[idx + 1];\n    return (0, $BT4Uh$snapValueToStep)(val, min, max, step);\n  }), [minValue, maxValue, step]);\n  let value = (0, $BT4Uh$useMemo)(() => restrictValues($28f99e3e86e6ec45$var$convertValue(props.value)), [props.value]);\n  let defaultValue = (0, $BT4Uh$useMemo)(() => {\n    var _convertValue;\n    return restrictValues((_convertValue = $28f99e3e86e6ec45$var$convertValue(props.defaultValue)) !== null && _convertValue !== void 0 ? _convertValue : [minValue]);\n  }, [props.defaultValue, minValue]);\n  let onChange = $28f99e3e86e6ec45$var$createOnChange(props.value, props.defaultValue, props.onChange);\n  let onChangeEnd = $28f99e3e86e6ec45$var$createOnChange(props.value, props.defaultValue, props.onChangeEnd);\n  const [values, setValuesState] = (0, $BT4Uh$useControlledState)(value, defaultValue, onChange);\n  const [isDraggings, setDraggingsState] = (0, $BT4Uh$useState)(new Array(values.length).fill(false));\n  const isEditablesRef = (0, $BT4Uh$useRef)(new Array(values.length).fill(true));\n  const [focusedIndex, setFocusedIndex] = (0, $BT4Uh$useState)(undefined);\n  const valuesRef = (0, $BT4Uh$useRef)(values);\n  const isDraggingsRef = (0, $BT4Uh$useRef)(isDraggings);\n  let setValues = values => {\n    valuesRef.current = values;\n    setValuesState(values);\n  };\n  let setDraggings = draggings => {\n    isDraggingsRef.current = draggings;\n    setDraggingsState(draggings);\n  };\n  function getValuePercent(value) {\n    return (value - minValue) / (maxValue - minValue);\n  }\n  function getThumbMinValue(index) {\n    return index === 0 ? minValue : values[index - 1];\n  }\n  function getThumbMaxValue(index) {\n    return index === values.length - 1 ? maxValue : values[index + 1];\n  }\n  function isThumbEditable(index) {\n    return isEditablesRef.current[index];\n  }\n  function setThumbEditable(index, editable) {\n    isEditablesRef.current[index] = editable;\n  }\n  function updateValue(index, value) {\n    if (isDisabled || !isThumbEditable(index)) return;\n    const thisMin = getThumbMinValue(index);\n    const thisMax = getThumbMaxValue(index);\n    // Round value to multiple of step, clamp value between min and max\n    value = (0, $BT4Uh$snapValueToStep)(value, thisMin, thisMax, step);\n    let newValues = $28f99e3e86e6ec45$var$replaceIndex(valuesRef.current, index, value);\n    setValues(newValues);\n  }\n  function updateDragging(index, dragging) {\n    if (isDisabled || !isThumbEditable(index)) return;\n    if (dragging) valuesRef.current = values;\n    const wasDragging = isDraggingsRef.current[index];\n    isDraggingsRef.current = $28f99e3e86e6ec45$var$replaceIndex(isDraggingsRef.current, index, dragging);\n    setDraggings(isDraggingsRef.current);\n    // Call onChangeEnd if no handles are dragging.\n    if (onChangeEnd && wasDragging && !isDraggingsRef.current.some(Boolean)) onChangeEnd(valuesRef.current);\n  }\n  function getFormattedValue(value) {\n    return formatter.format(value);\n  }\n  function setThumbPercent(index, percent) {\n    updateValue(index, getPercentValue(percent));\n  }\n  function getRoundedValue(value) {\n    return Math.round((value - minValue) / step) * step + minValue;\n  }\n  function getPercentValue(percent) {\n    const val = percent * (maxValue - minValue) + minValue;\n    return (0, $BT4Uh$clamp)(getRoundedValue(val), minValue, maxValue);\n  }\n  function incrementThumb(index) {\n    let stepSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let s = Math.max(stepSize, step);\n    updateValue(index, (0, $BT4Uh$snapValueToStep)(values[index] + s, minValue, maxValue, step));\n  }\n  function decrementThumb(index) {\n    let stepSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let s = Math.max(stepSize, step);\n    updateValue(index, (0, $BT4Uh$snapValueToStep)(values[index] - s, minValue, maxValue, step));\n  }\n  return {\n    values: values,\n    getThumbValue: index => values[index],\n    setThumbValue: updateValue,\n    setThumbPercent: setThumbPercent,\n    isThumbDragging: index => isDraggings[index],\n    setThumbDragging: updateDragging,\n    focusedThumb: focusedIndex,\n    setFocusedThumb: setFocusedIndex,\n    getThumbPercent: index => getValuePercent(values[index]),\n    getValuePercent: getValuePercent,\n    getThumbValueLabel: index => getFormattedValue(values[index]),\n    getFormattedValue: getFormattedValue,\n    getThumbMinValue: getThumbMinValue,\n    getThumbMaxValue: getThumbMaxValue,\n    getPercentValue: getPercentValue,\n    isThumbEditable: isThumbEditable,\n    setThumbEditable: setThumbEditable,\n    incrementThumb: incrementThumb,\n    decrementThumb: decrementThumb,\n    step: step,\n    pageSize: pageSize,\n    orientation: orientation,\n    isDisabled: isDisabled\n  };\n}\nfunction $28f99e3e86e6ec45$var$replaceIndex(array, index, value) {\n  if (array[index] === value) return array;\n  return [...array.slice(0, index), value, ...array.slice(index + 1)];\n}\nfunction $28f99e3e86e6ec45$var$convertValue(value) {\n  if (value == null) return undefined;\n  return Array.isArray(value) ? value : [value];\n}\nfunction $28f99e3e86e6ec45$var$createOnChange(value, defaultValue, onChange) {\n  return newValue => {\n    if (typeof value === 'number' || typeof defaultValue === 'number') onChange === null || onChange === void 0 ? void 0 : onChange(newValue[0]);else onChange === null || onChange === void 0 ? void 0 : onChange(newValue);\n  };\n}\nexport { $28f99e3e86e6ec45$export$e5fda3247f5d67f9 as useSliderState };","map":{"version":3,"mappings":"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","names":["$28f99e3e86e6ec45$var$DEFAULT_MIN_VALUE","$28f99e3e86e6ec45$var$DEFAULT_MAX_VALUE","$28f99e3e86e6ec45$var$DEFAULT_STEP_VALUE","$28f99e3e86e6ec45$export$e5fda3247f5d67f9","props","isDisabled","minValue","maxValue","numberFormatter","formatter","step","orientation","pageSize","calcPageSize","Math","max","restrictValues","values","map","val","idx","min","length","value","$28f99e3e86e6ec45$var$convertValue","defaultValue","_convertValue","onChange","$28f99e3e86e6ec45$var$createOnChange","onChangeEnd","setValuesState","isDraggings","setDraggingsState","Array","fill","isEditablesRef","focusedIndex","setFocusedIndex","undefined","valuesRef","isDraggingsRef","setValues","current","setDraggings","draggings","getValuePercent","getThumbMinValue","index","getThumbMaxValue","isThumbEditable","setThumbEditable","editable","updateValue","thisMin","thisMax","newValues","$28f99e3e86e6ec45$var$replaceIndex","updateDragging","dragging","wasDragging","some","Boolean","getFormattedValue","format","setThumbPercent","percent","getPercentValue","getRoundedValue","round","incrementThumb","stepSize","s","decrementThumb","getThumbValue","setThumbValue","isThumbDragging","setThumbDragging","focusedThumb","setFocusedThumb","getThumbPercent","getThumbValueLabel","array","slice","isArray","newValue"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-stately\\slider\\dist\\packages\\@react-stately\\slider\\src\\useSliderState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {clamp, snapValueToStep, useControlledState} from '@react-stately/utils';\nimport {Orientation} from '@react-types/shared';\nimport {SliderProps} from '@react-types/slider';\nimport {useCallback, useMemo, useRef, useState} from 'react';\n\nexport interface SliderState {\n  /**\n   * Values managed by the slider by thumb index.\n   */\n  readonly values: number[],\n  /**\n   * Get the value for the specified thumb.\n   * @param index\n   */\n  getThumbValue(index: number): number,\n\n  /**\n   * Sets the value for the specified thumb.\n   * The actual value set will be clamped and rounded according to min/max/step.\n   * @param index\n   * @param value\n   */\n  setThumbValue(index: number, value: number): void,\n\n  /**\n   * Sets value for the specified thumb by percent offset (between 0 and 1).\n   * @param index\n   * @param percent\n   */\n  setThumbPercent(index: number, percent: number): void,\n\n  /**\n   * Whether the specific thumb is being dragged.\n   * @param index\n   */\n  isThumbDragging(index: number): boolean,\n  /**\n   * Set is dragging on the specified thumb.\n   * @param index\n   * @param dragging\n   */\n  setThumbDragging(index: number, dragging: boolean): void,\n\n  /**\n   * Currently-focused thumb index.\n   */\n  readonly focusedThumb: number | undefined,\n  /**\n   * Set focused true on specified thumb. This will remove focus from\n   * any thumb that had it before.\n   * @param index\n   */\n  setFocusedThumb(index: number | undefined): void,\n\n  /**\n   * Returns the specified thumb's value as a percentage from 0 to 1.\n   * @param index\n   */\n  getThumbPercent(index: number): number,\n\n  /**\n   * Returns the value as a percent between the min and max of the slider.\n   * @param index\n   */\n  getValuePercent(value: number): number,\n\n  /**\n   * Returns the string label for the specified thumb's value, per props.formatOptions.\n   * @param index\n   */\n  getThumbValueLabel(index: number): string,\n\n  /**\n   * Returns the string label for the value, per props.formatOptions.\n   * @param index\n   */\n  getFormattedValue(value: number): string,\n\n  /**\n   * Returns the min allowed value for the specified thumb.\n   * @param index\n   */\n  getThumbMinValue(index: number): number,\n\n  /**\n   * Returns the max allowed value for the specified thumb.\n   * @param index\n   */\n  getThumbMaxValue(index: number): number,\n\n  /**\n   * Converts a percent along track (between 0 and 1) to the corresponding value.\n   * @param percent\n   */\n  getPercentValue(percent: number): number,\n\n  /**\n   * Returns if the specified thumb is editable.\n   * @param index\n   */\n  isThumbEditable(index: number): boolean,\n\n  /**\n   * Set the specified thumb's editable state.\n   * @param index\n   * @param editable\n   */\n  setThumbEditable(index: number, editable: boolean): void,\n\n  /**\n   * Increments the value of the thumb by the step or page amount.\n   */\n  incrementThumb(index: number, stepSize?: number): void,\n  /**\n   * Decrements the value of the thumb by the step or page amount.\n   */\n  decrementThumb(index: number, stepSize?: number): void,\n\n  /**\n   * The step amount for the slider.\n   */\n  readonly step: number,\n\n  /**\n   * The page size for the slider, used to do a bigger step.\n   */\n  readonly pageSize: number,\n\n  /** The orientation of the slider. */\n  readonly orientation: Orientation,\n\n  /** Whether the slider is disabled. */\n  readonly isDisabled: boolean\n}\n\nconst DEFAULT_MIN_VALUE = 0;\nconst DEFAULT_MAX_VALUE = 100;\nconst DEFAULT_STEP_VALUE = 1;\n\nexport interface SliderStateOptions<T> extends SliderProps<T> {\n  numberFormatter: Intl.NumberFormat\n}\n\n/**\n * Provides state management for a slider component. Stores values for all thumbs,\n * formats values for localization, and provides methods to update the position\n * of any thumbs.\n * @param props\n */\nexport function useSliderState<T extends number | number[]>(props: SliderStateOptions<T>): SliderState {\n  const {\n    isDisabled = false,\n    minValue = DEFAULT_MIN_VALUE,\n    maxValue = DEFAULT_MAX_VALUE,\n    numberFormatter: formatter,\n    step = DEFAULT_STEP_VALUE,\n    orientation = 'horizontal'\n  } = props;\n\n  // Page step should be at least equal to step and always a multiple of the step.\n  let pageSize = useMemo(() => {\n    let calcPageSize = (maxValue - minValue) / 10;\n    calcPageSize = snapValueToStep(calcPageSize, 0, calcPageSize + step, step);\n    return Math.max(calcPageSize, step);\n  }, [step, maxValue, minValue]);\n\n  let restrictValues = useCallback((values: number[]) => values?.map((val, idx) => {\n    let min = idx === 0 ? minValue : val[idx - 1];\n    let max = idx === values.length - 1 ? maxValue : val[idx + 1];\n    return snapValueToStep(val, min, max, step);\n  }), [minValue, maxValue, step]);\n\n  let value = useMemo(() => restrictValues(convertValue(props.value)), [props.value]);\n  let defaultValue = useMemo(() => restrictValues(convertValue(props.defaultValue) ?? [minValue]), [props.defaultValue, minValue]);\n  let onChange = createOnChange(props.value, props.defaultValue, props.onChange);\n  let onChangeEnd = createOnChange(props.value, props.defaultValue, props.onChangeEnd);\n\n  const [values, setValuesState] = useControlledState<number[]>(\n    value,\n    defaultValue,\n    onChange\n  );\n  const [isDraggings, setDraggingsState] = useState<boolean[]>(new Array(values.length).fill(false));\n  const isEditablesRef = useRef<boolean[]>(new Array(values.length).fill(true));\n  const [focusedIndex, setFocusedIndex] = useState<number | undefined>(undefined);\n\n  const valuesRef = useRef<number[]>(values);\n  const isDraggingsRef = useRef<boolean[]>(isDraggings);\n\n  let setValues = (values: number[]) => {\n    valuesRef.current = values;\n    setValuesState(values);\n  };\n\n  let setDraggings = (draggings: boolean[]) => {\n    isDraggingsRef.current = draggings;\n    setDraggingsState(draggings);\n  };\n\n  function getValuePercent(value: number) {\n    return (value - minValue) / (maxValue - minValue);\n  }\n\n  function getThumbMinValue(index: number) {\n    return index === 0 ? minValue : values[index - 1];\n  }\n  function getThumbMaxValue(index: number) {\n    return index === values.length - 1 ? maxValue : values[index + 1];\n  }\n\n  function isThumbEditable(index: number) {\n    return isEditablesRef.current[index];\n  }\n\n  function setThumbEditable(index: number, editable: boolean) {\n    isEditablesRef.current[index] = editable;\n  }\n\n  function updateValue(index: number, value: number) {\n    if (isDisabled || !isThumbEditable(index)) {\n      return;\n    }\n    const thisMin = getThumbMinValue(index);\n    const thisMax = getThumbMaxValue(index);\n\n    // Round value to multiple of step, clamp value between min and max\n    value = snapValueToStep(value, thisMin, thisMax, step);\n    let newValues = replaceIndex(valuesRef.current, index, value);\n    setValues(newValues);\n  }\n\n  function updateDragging(index: number, dragging: boolean) {\n    if (isDisabled || !isThumbEditable(index)) {\n      return;\n    }\n    if (dragging) {\n      valuesRef.current = values;\n    }\n\n    const wasDragging = isDraggingsRef.current[index];\n    isDraggingsRef.current = replaceIndex(isDraggingsRef.current, index, dragging);\n    setDraggings(isDraggingsRef.current);\n\n    // Call onChangeEnd if no handles are dragging.\n    if (onChangeEnd && wasDragging && !isDraggingsRef.current.some(Boolean)) {\n      onChangeEnd(valuesRef.current);\n    }\n  }\n\n  function getFormattedValue(value: number) {\n    return formatter.format(value);\n  }\n\n  function setThumbPercent(index: number, percent: number) {\n    updateValue(index, getPercentValue(percent));\n  }\n\n  function getRoundedValue(value: number) {\n    return Math.round((value - minValue) / step) * step + minValue;\n  }\n\n  function getPercentValue(percent: number) {\n    const val = percent * (maxValue - minValue) + minValue;\n    return clamp(getRoundedValue(val), minValue, maxValue);\n  }\n\n  function incrementThumb(index: number, stepSize: number = 1) {\n    let s = Math.max(stepSize, step);\n    updateValue(index, snapValueToStep(values[index] + s, minValue, maxValue, step));\n  }\n\n  function decrementThumb(index: number, stepSize: number = 1) {\n    let s = Math.max(stepSize, step);\n    updateValue(index, snapValueToStep(values[index] - s, minValue, maxValue, step));\n  }\n\n  return {\n    values: values,\n    getThumbValue: (index: number) => values[index],\n    setThumbValue: updateValue,\n    setThumbPercent,\n    isThumbDragging: (index: number) => isDraggings[index],\n    setThumbDragging: updateDragging,\n    focusedThumb: focusedIndex,\n    setFocusedThumb: setFocusedIndex,\n    getThumbPercent: (index: number) => getValuePercent(values[index]),\n    getValuePercent,\n    getThumbValueLabel: (index: number) => getFormattedValue(values[index]),\n    getFormattedValue,\n    getThumbMinValue,\n    getThumbMaxValue,\n    getPercentValue,\n    isThumbEditable,\n    setThumbEditable,\n    incrementThumb,\n    decrementThumb,\n    step,\n    pageSize,\n    orientation,\n    isDisabled\n  };\n}\n\nfunction replaceIndex<T>(array: T[], index: number, value: T) {\n  if (array[index] === value) {\n    return array;\n  }\n\n  return [...array.slice(0, index), value, ...array.slice(index + 1)];\n}\n\nfunction convertValue(value: number | number[]) {\n  if (value == null) {\n    return undefined;\n  }\n\n  return Array.isArray(value) ? value : [value];\n}\n\nfunction createOnChange(value, defaultValue, onChange) {\n  return (newValue: number[]) => {\n    if (typeof value === 'number' || typeof defaultValue === 'number') {\n      onChange?.(newValue[0]);\n    } else {\n      onChange?.(newValue);\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}