{"ast":null,"code":"import { getSliderThumbId as $aa519ee6cf463259$export$68e648cbec363a18, sliderData as $aa519ee6cf463259$export$d6c8d9636a3dc49c } from \"./utils.mjs\";\nimport { useGlobalListeners as $lSlq7$useGlobalListeners, focusWithoutScrolling as $lSlq7$focusWithoutScrolling, clamp as $lSlq7$clamp, mergeProps as $lSlq7$mergeProps, useFormReset as $lSlq7$useFormReset } from \"@react-aria/utils\";\nimport { useCallback as $lSlq7$useCallback, useEffect as $lSlq7$useEffect, useRef as $lSlq7$useRef } from \"react\";\nimport { useFocusable as $lSlq7$useFocusable } from \"@react-aria/focus\";\nimport { useKeyboard as $lSlq7$useKeyboard, useMove as $lSlq7$useMove } from \"@react-aria/interactions\";\nimport { useLabel as $lSlq7$useLabel } from \"@react-aria/label\";\nimport { useLocale as $lSlq7$useLocale } from \"@react-aria/i18n\";\nfunction $47b897dc8cdb026b$export$8d15029008292ae(opts, state) {\n  let {\n    index = 0,\n    isRequired: isRequired,\n    validationState: validationState,\n    isInvalid: isInvalid,\n    trackRef: trackRef,\n    inputRef: inputRef,\n    orientation = state.orientation,\n    name: name\n  } = opts;\n  let isDisabled = opts.isDisabled || state.isDisabled;\n  let isVertical = orientation === 'vertical';\n  let {\n    direction: direction\n  } = (0, $lSlq7$useLocale)();\n  let {\n    addGlobalListener: addGlobalListener,\n    removeGlobalListener: removeGlobalListener\n  } = (0, $lSlq7$useGlobalListeners)();\n  let data = (0, $aa519ee6cf463259$export$d6c8d9636a3dc49c).get(state);\n  var _opts_arialabelledby;\n  const {\n    labelProps: labelProps,\n    fieldProps: fieldProps\n  } = (0, $lSlq7$useLabel)({\n    ...opts,\n    id: (0, $aa519ee6cf463259$export$68e648cbec363a18)(state, index),\n    'aria-labelledby': `${data.id} ${(_opts_arialabelledby = opts['aria-labelledby']) !== null && _opts_arialabelledby !== void 0 ? _opts_arialabelledby : ''}`.trim()\n  });\n  const value = state.values[index];\n  const focusInput = (0, $lSlq7$useCallback)(() => {\n    if (inputRef.current) (0, $lSlq7$focusWithoutScrolling)(inputRef.current);\n  }, [inputRef]);\n  const isFocused = state.focusedThumb === index;\n  (0, $lSlq7$useEffect)(() => {\n    if (isFocused) focusInput();\n  }, [isFocused, focusInput]);\n  let reverseX = direction === 'rtl';\n  let currentPosition = (0, $lSlq7$useRef)(null);\n  let {\n    keyboardProps: keyboardProps\n  } = (0, $lSlq7$useKeyboard)({\n    onKeyDown(e) {\n      let {\n        getThumbMaxValue: getThumbMaxValue,\n        getThumbMinValue: getThumbMinValue,\n        decrementThumb: decrementThumb,\n        incrementThumb: incrementThumb,\n        setThumbValue: setThumbValue,\n        setThumbDragging: setThumbDragging,\n        pageSize: pageSize\n      } = state;\n      // these are the cases that useMove or useSlider don't handle\n      if (!/^(PageUp|PageDown|Home|End)$/.test(e.key)) {\n        e.continuePropagation();\n        return;\n      }\n      // same handling as useMove, stopPropagation to prevent useSlider from handling the event as well.\n      e.preventDefault();\n      // remember to set this so that onChangeEnd is fired\n      setThumbDragging(index, true);\n      switch (e.key) {\n        case 'PageUp':\n          incrementThumb(index, pageSize);\n          break;\n        case 'PageDown':\n          decrementThumb(index, pageSize);\n          break;\n        case 'Home':\n          setThumbValue(index, getThumbMinValue(index));\n          break;\n        case 'End':\n          setThumbValue(index, getThumbMaxValue(index));\n          break;\n      }\n      setThumbDragging(index, false);\n    }\n  });\n  let {\n    moveProps: moveProps\n  } = (0, $lSlq7$useMove)({\n    onMoveStart() {\n      currentPosition.current = null;\n      state.setThumbDragging(index, true);\n    },\n    onMove(_ref) {\n      let {\n        deltaX: deltaX,\n        deltaY: deltaY,\n        pointerType: pointerType,\n        shiftKey: shiftKey\n      } = _ref;\n      const {\n        getThumbPercent: getThumbPercent,\n        setThumbPercent: setThumbPercent,\n        decrementThumb: decrementThumb,\n        incrementThumb: incrementThumb,\n        step: step,\n        pageSize: pageSize\n      } = state;\n      let {\n        width: width,\n        height: height\n      } = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n      if (currentPosition.current == null) currentPosition.current = getThumbPercent(index) * size;\n      if (pointerType === 'keyboard') {\n        if (deltaX > 0 && reverseX || deltaX < 0 && !reverseX || deltaY > 0) decrementThumb(index, shiftKey ? pageSize : step);else incrementThumb(index, shiftKey ? pageSize : step);\n      } else {\n        let delta = isVertical ? deltaY : deltaX;\n        if (isVertical || reverseX) delta = -delta;\n        currentPosition.current += delta;\n        setThumbPercent(index, (0, $lSlq7$clamp)(currentPosition.current / size, 0, 1));\n      }\n    },\n    onMoveEnd() {\n      state.setThumbDragging(index, false);\n    }\n  });\n  // Immediately register editability with the state\n  state.setThumbEditable(index, !isDisabled);\n  const {\n    focusableProps: focusableProps\n  } = (0, $lSlq7$useFocusable)((0, $lSlq7$mergeProps)(opts, {\n    onFocus: () => state.setFocusedThumb(index),\n    onBlur: () => state.setFocusedThumb(undefined)\n  }), inputRef);\n  let currentPointer = (0, $lSlq7$useRef)(undefined);\n  let onDown = id => {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n    addGlobalListener(window, 'mouseup', onUp, false);\n    addGlobalListener(window, 'touchend', onUp, false);\n    addGlobalListener(window, 'pointerup', onUp, false);\n  };\n  let onUp = e => {\n    var _e_changedTouches;\n    var _e_pointerId;\n    let id = (_e_pointerId = e.pointerId) !== null && _e_pointerId !== void 0 ? _e_pointerId : (_e_changedTouches = e.changedTouches) === null || _e_changedTouches === void 0 ? void 0 : _e_changedTouches[0].identifier;\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, 'mouseup', onUp, false);\n      removeGlobalListener(window, 'touchend', onUp, false);\n      removeGlobalListener(window, 'pointerup', onUp, false);\n    }\n  };\n  let thumbPosition = state.getThumbPercent(index);\n  if (isVertical || direction === 'rtl') thumbPosition = 1 - thumbPosition;\n  let interactions = !isDisabled ? (0, $lSlq7$mergeProps)(keyboardProps, moveProps, {\n    onMouseDown: e => {\n      if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;\n      onDown();\n    },\n    onPointerDown: e => {\n      if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;\n      onDown(e.pointerId);\n    },\n    onTouchStart: e => {\n      onDown(e.changedTouches[0].identifier);\n    }\n  }) : {};\n  (0, $lSlq7$useFormReset)(inputRef, value, v => {\n    state.setThumbValue(index, v);\n  });\n  // We install mouse handlers for the drag motion on the thumb div, but\n  // not the key handler for moving the thumb with the slider.  Instead,\n  // we focus the range input, and let the browser handle the keyboard\n  // interactions; we then listen to input's onChange to update state.\n  return {\n    inputProps: (0, $lSlq7$mergeProps)(focusableProps, fieldProps, {\n      type: 'range',\n      tabIndex: !isDisabled ? 0 : undefined,\n      min: state.getThumbMinValue(index),\n      max: state.getThumbMaxValue(index),\n      step: state.step,\n      value: value,\n      name: name,\n      disabled: isDisabled,\n      'aria-orientation': orientation,\n      'aria-valuetext': state.getThumbValueLabel(index),\n      'aria-required': isRequired || undefined,\n      'aria-invalid': isInvalid || validationState === 'invalid' || undefined,\n      'aria-errormessage': opts['aria-errormessage'],\n      'aria-describedby': [data['aria-describedby'], opts['aria-describedby']].filter(Boolean).join(' '),\n      'aria-details': [data['aria-details'], opts['aria-details']].filter(Boolean).join(' '),\n      onChange: e => {\n        state.setThumbValue(index, parseFloat(e.target.value));\n      }\n    }),\n    thumbProps: {\n      ...interactions,\n      style: {\n        position: 'absolute',\n        [isVertical ? 'top' : 'left']: `${thumbPosition * 100}%`,\n        transform: 'translate(-50%, -50%)',\n        touchAction: 'none'\n      }\n    },\n    labelProps: labelProps,\n    isDragging: state.isThumbDragging(index),\n    isDisabled: isDisabled,\n    isFocused: isFocused\n  };\n}\nexport { $47b897dc8cdb026b$export$8d15029008292ae as useSliderThumb };","map":{"version":3,"mappings":"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","names":["$47b897dc8cdb026b$export$8d15029008292ae","opts","state","index","isRequired","validationState","isInvalid","trackRef","inputRef","orientation","name","isDisabled","isVertical","direction","addGlobalListener","removeGlobalListener","data","get","_opts_arialabelledby","labelProps","fieldProps","id","trim","value","values","focusInput","current","isFocused","focusedThumb","reverseX","currentPosition","keyboardProps","onKeyDown","e","getThumbMaxValue","getThumbMinValue","decrementThumb","incrementThumb","setThumbValue","setThumbDragging","pageSize","test","key","continuePropagation","preventDefault","moveProps","onMoveStart","onMove","deltaX","deltaY","pointerType","shiftKey","getThumbPercent","setThumbPercent","step","width","height","getBoundingClientRect","size","delta","onMoveEnd","setThumbEditable","focusableProps","onFocus","setFocusedThumb","onBlur","undefined","currentPointer","onDown","window","onUp","_e_changedTouches","_e_pointerId","pointerId","changedTouches","identifier","thumbPosition","interactions","onMouseDown","button","altKey","ctrlKey","metaKey","onPointerDown","onTouchStart","v","inputProps","type","tabIndex","min","max","disabled","getThumbValueLabel","filter","Boolean","join","onChange","parseFloat","target","thumbProps","style","position","transform","touchAction","isDragging","isThumbDragging"],"sources":["D:\\Like, for real projects\\React-Todo-List-V2\\node_modules\\@react-aria\\slider\\dist\\packages\\@react-aria\\slider\\src\\useSliderThumb.ts"],"sourcesContent":["import {AriaSliderThumbProps} from '@react-types/slider';\nimport {clamp, focusWithoutScrolling, mergeProps, useFormReset, useGlobalListeners} from '@react-aria/utils';\nimport {DOMAttributes} from '@react-types/shared';\nimport {getSliderThumbId, sliderData} from './utils';\nimport React, {ChangeEvent, InputHTMLAttributes, LabelHTMLAttributes, RefObject, useCallback, useEffect, useRef} from 'react';\nimport {SliderState} from '@react-stately/slider';\nimport {useFocusable} from '@react-aria/focus';\nimport {useKeyboard, useMove} from '@react-aria/interactions';\nimport {useLabel} from '@react-aria/label';\nimport {useLocale} from '@react-aria/i18n';\n\nexport interface SliderThumbAria {\n  /** Props for the root thumb element; handles the dragging motion. */\n  thumbProps: DOMAttributes,\n\n  /** Props for the visually hidden range input element. */\n  inputProps: InputHTMLAttributes<HTMLInputElement>,\n\n  /** Props for the label element for this thumb (optional). */\n  labelProps: LabelHTMLAttributes<HTMLLabelElement>,\n\n  /** Whether this thumb is currently being dragged. */\n  isDragging: boolean,\n  /** Whether the thumb is currently focused. */\n  isFocused: boolean,\n  /** Whether the thumb is disabled. */\n  isDisabled: boolean\n}\n\nexport interface AriaSliderThumbOptions extends AriaSliderThumbProps {\n  /** A ref to the track element. */\n  trackRef: RefObject<Element>,\n  /** A ref to the thumb input element. */\n  inputRef: RefObject<HTMLInputElement>\n}\n\n/**\n * Provides behavior and accessibility for a thumb of a slider component.\n *\n * @param opts Options for this Slider thumb.\n * @param state Slider state, created via `useSliderState`.\n */\nexport function useSliderThumb(\n  opts: AriaSliderThumbOptions,\n  state: SliderState\n): SliderThumbAria {\n  let {\n    index = 0,\n    isRequired,\n    validationState,\n    isInvalid,\n    trackRef,\n    inputRef,\n    orientation = state.orientation,\n    name\n  } = opts;\n\n  let isDisabled = opts.isDisabled || state.isDisabled;\n  let isVertical = orientation === 'vertical';\n\n  let {direction} = useLocale();\n  let {addGlobalListener, removeGlobalListener} = useGlobalListeners();\n\n  let data = sliderData.get(state);\n  const {labelProps, fieldProps} = useLabel({\n    ...opts,\n    id: getSliderThumbId(state, index),\n    'aria-labelledby': `${data.id} ${opts['aria-labelledby'] ?? ''}`.trim()\n  });\n\n  const value = state.values[index];\n\n  const focusInput = useCallback(() => {\n    if (inputRef.current) {\n      focusWithoutScrolling(inputRef.current);\n    }\n  }, [inputRef]);\n\n  const isFocused = state.focusedThumb === index;\n\n  useEffect(() => {\n    if (isFocused) {\n      focusInput();\n    }\n  }, [isFocused, focusInput]);\n\n  let reverseX = direction === 'rtl';\n  let currentPosition = useRef<number>(null);\n\n  let {keyboardProps} = useKeyboard({\n    onKeyDown(e) {\n      let {\n        getThumbMaxValue,\n        getThumbMinValue,\n        decrementThumb,\n        incrementThumb,\n        setThumbValue,\n        setThumbDragging,\n        pageSize\n      } = state;\n      // these are the cases that useMove or useSlider don't handle\n      if (!/^(PageUp|PageDown|Home|End)$/.test(e.key)) {\n        e.continuePropagation();\n        return;\n      }\n      // same handling as useMove, stopPropagation to prevent useSlider from handling the event as well.\n      e.preventDefault();\n      // remember to set this so that onChangeEnd is fired\n      setThumbDragging(index, true);\n      switch (e.key) {\n        case 'PageUp':\n          incrementThumb(index, pageSize);\n          break;\n        case 'PageDown':\n          decrementThumb(index, pageSize);\n          break;\n        case 'Home':\n          setThumbValue(index, getThumbMinValue(index));\n          break;\n        case 'End':\n          setThumbValue(index, getThumbMaxValue(index));\n          break;\n      }\n      setThumbDragging(index, false);\n    }\n  });\n\n  let {moveProps} = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n      state.setThumbDragging(index, true);\n    },\n    onMove({deltaX, deltaY, pointerType, shiftKey}) {\n      const {\n        getThumbPercent,\n        setThumbPercent,\n        decrementThumb,\n        incrementThumb,\n        step,\n        pageSize\n      } = state;\n      let {width, height} = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n\n      if (currentPosition.current == null) {\n        currentPosition.current = getThumbPercent(index) * size;\n      }\n      if (pointerType === 'keyboard') {\n        if ((deltaX > 0 && reverseX) || (deltaX < 0 && !reverseX) || deltaY > 0) {\n          decrementThumb(index, shiftKey ? pageSize : step);\n        } else {\n          incrementThumb(index, shiftKey ? pageSize : step);\n        }\n      } else {\n        let delta = isVertical ? deltaY : deltaX;\n        if (isVertical || reverseX) {\n          delta = -delta;\n        }\n\n        currentPosition.current += delta;\n        setThumbPercent(index, clamp(currentPosition.current / size, 0, 1));\n      }\n    },\n    onMoveEnd() {\n      state.setThumbDragging(index, false);\n    }\n  });\n\n  // Immediately register editability with the state\n  state.setThumbEditable(index, !isDisabled);\n\n  const {focusableProps} = useFocusable(\n    mergeProps(opts, {\n      onFocus: () => state.setFocusedThumb(index),\n      onBlur: () => state.setFocusedThumb(undefined)\n    }),\n    inputRef\n  );\n\n  let currentPointer = useRef<number | undefined>(undefined);\n  let onDown = (id?: number) => {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n\n    addGlobalListener(window, 'mouseup', onUp, false);\n    addGlobalListener(window, 'touchend', onUp, false);\n    addGlobalListener(window, 'pointerup', onUp, false);\n\n  };\n\n  let onUp = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, 'mouseup', onUp, false);\n      removeGlobalListener(window, 'touchend', onUp, false);\n      removeGlobalListener(window, 'pointerup', onUp, false);\n    }\n  };\n\n  let thumbPosition = state.getThumbPercent(index);\n  if (isVertical || direction === 'rtl') {\n    thumbPosition = 1 - thumbPosition;\n  }\n\n  let interactions = !isDisabled ? mergeProps(\n    keyboardProps,\n    moveProps,\n    {\n      onMouseDown: (e: React.MouseEvent) => {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n        onDown();\n      },\n      onPointerDown: (e: React.PointerEvent) => {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n        onDown(e.pointerId);\n      },\n      onTouchStart: (e: React.TouchEvent) => {onDown(e.changedTouches[0].identifier);}\n    }\n  ) : {};\n\n  useFormReset(inputRef, value, (v) => {\n    state.setThumbValue(index, v);\n  });\n\n  // We install mouse handlers for the drag motion on the thumb div, but\n  // not the key handler for moving the thumb with the slider.  Instead,\n  // we focus the range input, and let the browser handle the keyboard\n  // interactions; we then listen to input's onChange to update state.\n  return {\n    inputProps: mergeProps(focusableProps, fieldProps, {\n      type: 'range',\n      tabIndex: !isDisabled ? 0 : undefined,\n      min: state.getThumbMinValue(index),\n      max: state.getThumbMaxValue(index),\n      step: state.step,\n      value: value,\n      name,\n      disabled: isDisabled,\n      'aria-orientation': orientation,\n      'aria-valuetext': state.getThumbValueLabel(index),\n      'aria-required': isRequired || undefined,\n      'aria-invalid': isInvalid || validationState === 'invalid' || undefined,\n      'aria-errormessage': opts['aria-errormessage'],\n      'aria-describedby': [data['aria-describedby'], opts['aria-describedby']].filter(Boolean).join(' '),\n      'aria-details': [data['aria-details'], opts['aria-details']].filter(Boolean).join(' '),\n      onChange: (e: ChangeEvent<HTMLInputElement>) => {\n        state.setThumbValue(index, parseFloat(e.target.value));\n      }\n    }),\n    thumbProps: {\n      ...interactions,\n      style: {\n        position: 'absolute',\n        [isVertical ? 'top' : 'left']: `${thumbPosition * 100}%`,\n        transform: 'translate(-50%, -50%)',\n        touchAction: 'none'\n      }\n    },\n    labelProps,\n    isDragging: state.isThumbDragging(index),\n    isDisabled,\n    isFocused\n  };\n}\n"]},"metadata":{},"sourceType":"module"}